<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">


<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/sjn/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="一、秒杀业务note重点 I 短信登录 1.1 Redis替换Session的具体细节和操作流程 1.存储短信验证码时，key-value分别是phone和code，均为String类型（唯一性、方便携带），存储User对象时，采用hash类型（json格式数据） 2.存储用户数据&#x2F;需要返回给前端时，用phone作key不合适，暴露隐私，在后台生成一个随机串token（利用令牌技术）设置">
<meta property="og:type" content="article">
<meta property="og:title" content="基本框架增加优惠券业务">
<meta property="og:url" content="https://github.com/Ning565/Ning565.github.io/2024/12/17/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%A2%9E%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%9A%E5%8A%A1/index.html">
<meta property="og:site_name" content="SJN的个人小屋">
<meta property="og:description" content="一、秒杀业务note重点 I 短信登录 1.1 Redis替换Session的具体细节和操作流程 1.存储短信验证码时，key-value分别是phone和code，均为String类型（唯一性、方便携带），存储User对象时，采用hash类型（json格式数据） 2.存储用户数据&#x2F;需要返回给前端时，用phone作key不合适，暴露隐私，在后台生成一个随机串token（利用令牌技术）设置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653323595206.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653546070602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553998403.png">
<meta property="article:published_time" content="2024-12-16T23:04:48.000Z">
<meta property="article:modified_time" content="2025-01-20T13:48:02.214Z">
<meta property="article:author" content="NING565">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="互斥锁">
<meta property="article:tag" content="秒杀">
<meta property="article:tag" content="mybatisplus">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653323595206.png">

<link rel="canonical" href="https://github.com/Ning565/Ning565.github.io/2024/12/17/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%A2%9E%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%9A%E5%8A%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>基本框架增加优惠券业务 | SJN的个人小屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SJN的个人小屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">静水流深，无问西东</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/12/17/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%A2%9E%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%9A%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基本框架增加优惠券业务
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-16 23:04:48" itemprop="dateCreated datePublished" datetime="2024-12-16T23:04:48Z">2024-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-20 13:48:02" itemprop="dateModified" datetime="2025-01-20T13:48:02Z">2025-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一秒杀业务note重点">一、秒杀业务note重点</h1>
<h2 id="i-短信登录">I 短信登录</h2>
<h3 id="redis替换session的具体细节和操作流程">1.1
Redis替换Session的具体细节和操作流程</h3>
<p>1.存储短信验证码时，key-value分别是phone和code，均为String类型（唯一性、方便携带），存储User对象时，采用hash类型（json格式数据）</p>
<p>2.存储用户数据/需要返回给前端时，用phone作key不合适，暴露隐私，在后台生成一个随机串token（利用令牌技术）设置过期时间，完成识别认证</p>
<p>3.利用UUID随机生成token，将User对象转为Map（定制 beanToMap
转换行为），将<strong>每个字段的值</strong>转换为 String
类型，存储后返回token</p>
<span id="more"></span>
<h3 id="状态登录刷新解决方案">1.2 状态登录刷新解决方案</h3>
<p>设置两个拦截器，第一个拦截器拦截所有路径（拦截而不处理return
true），仅用于刷新token时间，同时将前来认证/访问的User放入ThreadLocal（利用UserHolder，自定义的工具类，存放读取线程池的信息）；</p>
<p>第二个拦截器做真正的拦截功能，拦截所有需要登录才能访问的路径，随后注册配置两个拦截器，注意先执行第一个拦截器，配置order</p>
<h2 id="ii-商户查询缓存">II 商户查询缓存</h2>
<h3 id="缓存更新策略双写一致">2.1 缓存更新策略、双写一致</h3>
<p>原本的添加缓存的机制为，提交商铺id、查询缓存、命中返回商铺信息，未命中去数据库查（数据库不存在该商铺返回404）、存在该商铺写入Redis，返回商铺信息</p>
<p>内存数据有限宝贵，不可以redis插入太多数据，适当更新机制：</p>
<p><strong>内存淘汰：</strong>自动进行，redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除</p>
<p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和<strong>数据库不一致</strong>问题</p>
<p>低一致性需求：内存淘汰</p>
<p>高一致性需求：主动更新为主、超时为辅</p>
<h4 id="解决一致性问题">解决一致性问题</h4>
<p>数据库数据域发生变化后，缓存数据没有同步，产生一致性问题</p>
<p><strong>解决方式：主动更新</strong>，实现方案：</p>
<p>Cache Aside Pattern
缓存调用者在更新完数据库后去更新缓存，称之为<strong>双写方案</strong>（主要采用）</p>
<p><em>利用缓存服务：</em></p>
<p><em>Read/Write Through Pattern :
由<strong>系统本身</strong>完成，数据库与缓存的问题交由系统本身去处理，调用者无需关心一致性</em></p>
<p><em>Write Behind Caching Pattern
：调用者只操作缓存，<strong>其他线程去异步</strong>处理数据库，实现最终一致</em></p>
<h4 id="双写一致方案">双写一致方案</h4>
<p>采用双写一致方案，明确操作内容：</p>
<p>1.每次更新动作是直接删除缓存，而非更新</p>
<p>2.缓存与数据库的操作的同时成功或失败，采用一个<strong>事务</strong></p>
<p>3.先操作数据库，再删除缓存，why：</p>
<ul>
<li>方案一：两个线程并发来访问时，线程1先来，删除缓存还没来得及更新数据库；此时线程2查询缓存数据并不存在，故查询旧数据库获取旧数据写入缓存；线程1再执行更新数据库动作时，造成数据库和缓存不一致</li>
<li>方案二：当缓存失效时（时间等各原因），线程1查发现没有，查数据库旧数据，此时线程2先更新数据库改为新数据，然后删除缓存（本来就是空）相当于没删，此时线程1来写缓存，写的是旧数据（但发生的概率较小，先更新数据库）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653323595206.png" alt="1653323595206" style="zoom:50%;" /></p>
<p>住：写缓存是ums级别的，但数据库操作比写缓存时间多很多</p>
<p><strong>实现：</strong></p>
<p>查询操作：在ShopServiceImpl的queryById方法中：<strong>设置redis缓存时添加过期时间</strong></p>
<p>修改确保双写一致操作：在update方法中，<strong>先更新数据库再删除缓存</strong></p>
<h3 id="缓存穿透问题">2.2 缓存穿透问题</h3>
<p>缓存穿透是指客户端恶意请求数据在缓存中和数据库中都不存在，这些请求都会打到数据库。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>缓存空对象：访问数据库也不存在的数据时，把这个数据存入到redis中，给null，下次来访问直接返回个null
<ul>
<li>实现简单，额外内存消耗，缓存中需要存储
带TTL的null，短期不一致（后来此字段出现了）</li>
</ul></li>
<li>布隆过滤：在客户端访问到达redis前，设置布隆过滤器，哈希思想，通过一个庞大的二进制数组，判断当前这个要查询的这个数据是否存在（存在放行，不存在拒绝）
<ul>
<li>内存占用较少，没有多余key，实现复杂，误判可能</li>
</ul></li>
</ul>
<p>主动解决方案：</p>
<ul>
<li>增强id的复杂度</li>
<li>避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h4 id="缓存空对象解决">缓存空对象解决</h4>
<p>原本：发现这个数据在mysql中不存在，直接就返回404</p>
<p>现在：会把这个数据写入到Redis中，并且将value设置为""，再次查询时，判断value为null，则为之前写的空数据，直接返回；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">     <span class="comment">// 2、判断是否存在</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">         <span class="comment">// 存在,直接返回</span></span><br><span class="line">         <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//判断命中的值是否是空值，说明此时shopJson有值，但是为blank（上一步没判断出来的），是奇怪的</span></span><br><span class="line">     <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//返回一个错误信息</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">// 5.不存在，采用缓存空对象解决</span></span><br><span class="line">     <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//将空值写入redis</span></span><br><span class="line">         stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">         <span class="comment">//返回错误信息</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;		</span><br><span class="line"></span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="缓存击穿问题">2.3 缓存击穿问题</h3>
<p>缓存击穿问题也叫<strong>热点Key问题</strong>，某个被高并发访问并且缓存重建业务较复杂的key突然<strong>失效</strong>了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>线程1查询缓存，未命中，去查询数据库然后重建缓存数据（耗费时间较长），在此过程中，若干线程执行同线程1的操作，同时在访问数据库执行重建操作；</p>
<p><strong>解决方案：</strong></p>
<h4 id="互斥锁">互斥锁</h4>
<p>锁能实现互斥性，第一个查询未命中的线程在重建的时候获得锁的资源，其他之后的线程来没有锁的资源，无法访问到数据库，只能休眠等待（定期回到查询缓存步骤），直到线程1释放锁。</p>
<ul>
<li>让查询的性能从并行变成了串行，只能一个线程在操作，其他在休眠，效率低；死锁风险</li>
<li>实现简单，无额外内存消耗</li>
<li>牺牲可用性，保证一致性</li>
</ul>
<p>实现思路：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653357860001-1734362376722.png"
alt="1653357860001" />
<figcaption aria-hidden="true">1653357860001</figcaption>
</figure>
<p>核心思路：</p>
<ul>
<li>获取锁的方式：利用redis的<strong>setnx方法</strong>（redis中如果没有这个key，则插入成功，返回1/true，如果存在这个key，则插入失败）</li>
<li>利用key-"1"，setIfAbsent方法，如果存在这个资源则不会操作，成功插入key的线程认为获得了锁；删除这个key-value即代表释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line"> <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">    shop = getById(id);</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 释放互斥锁</span></span><br><span class="line">    unlock(lockKey);</span><br></pre></td></tr></table></figure>
<h4 id="逻辑过期">逻辑过期</h4>
<p>逻辑过期：为key-value不设置实际的TTL，存储他们的时候采用一个expireTime字段，每次都需要判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则当前线程直接返回过期数据，同时开启一个独立线程，独立线程去获取锁重构数据，重构完成后释放互斥锁。</p>
<ul>
<li>线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据</li>
<li>不保证一致性，有额外的内存消耗，且实现复杂</li>
<li>牺牲一致性，提高性能</li>
</ul>
<p>实现思路：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653360308731-1734362376722.png"
alt="1653360308731" />
<figcaption aria-hidden="true">1653360308731</figcaption>
</figure>
<p><strong>核心思路：</strong></p>
<p>现在redis中存储的数据的value需要带上过期时间，采用<strong>组合方式</strong>，<strong>对原来代码没有侵入性</strong>：</p>
<p>新定义一个实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>修改<strong>ShopServiceImpl</strong>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建,开启新线程获取互斥锁重建</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br></pre></td></tr></table></figure>
<h3 id="缓存雪崩问题">2.4 缓存雪崩问题</h3>
<p>缓存雪崩是指在同一时段<strong>大量的缓存key</strong>同时失效或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。(服务器本身的问题)</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值（避免TTL一起到期）</li>
<li>利用Redis集群提高服务的可用性（Redis哨兵机制）</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存（不仅在service缓存，nginx也可以缓存，数据库等）</li>
</ul>
<h3 id="封装redis工具类">2.5 封装Redis工具类</h3>
<p>泛型是 Java 中引入的一种
<strong>参数化类型</strong>，让类、接口和方法可以使用
<strong>不确定的数据类型</strong>，泛型可以实现：代码重用、类型安全、增强可读性</p>
<p>泛型通常通过 <code>&lt;T&gt;</code>、<code>&lt;R&gt;</code>
等尖括号包裹的字母表示，其中：</p>
<ul>
<li><code>T</code>：表示类型（Type）。</li>
<li><code>R</code>：表示返回类型（Return）。</li>
<li><code>ID</code>：可以表示输入的参数类型（例如 ID）</li>
</ul>
<p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</p></li>
<li><p>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题</p></li>
<li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用<strong>缓存空值的方式解决缓存穿透</strong>问题</p></li>
<li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要<strong>利用逻辑过期解决缓存击穿</strong>问题</p></li>
<li><p>方法5：根据指定的key查询缓存，并反序列化为指定类型，需要<strong>利用互斥锁解决缓存击穿</strong>问题</p></li>
</ul>
<p>将逻辑进行封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">	<span class="comment">// 设置十个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法1：设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法2：设置逻辑过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法3，利用泛型手段，不局限于Shop类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="comment">// type 用来帮助框架或工具进行对象的反序列化，即将字符串或JSON 转换为具体的对象类型R（type告诉方法：把 JSON 转换成 R 类型的对象）</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="comment">// 接受参数 ID 并返回 R 类型的函数</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法4：利用逻辑过期解决缓存击穿问题</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法5：利用互斥锁解决缓存击穿</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获得锁和释放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ShopServiceImpl
中直接调方法<code>Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</code></p>
<h2 id="iii-优惠券秒杀">III 优惠券秒杀</h2>
<h3 id="全局唯一id">3.1 全局唯一ID</h3>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p><strong>全局ID生成器</strong>：为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653363172079-1734362376722.png"
alt="1653363172079" />
<figcaption aria-hidden="true">1653363172079</figcaption>
</figure>
<p>永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.生成时间戳</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.生成序列号</span></span><br><span class="line"><span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line"><span class="comment">// 2.2.自增长</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.拼接并返回，右移后 或 count，比加效率高</span></span><br><span class="line"><span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br></pre></td></tr></table></figure>
<h3 id="秒杀下单超卖问题">3.2 秒杀下单超卖问题</h3>
<p>数据库信息：</p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等
tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>tb_order_voucher：订单表，在用户每次特价优惠券秒杀成功后，都会创建订单，在此表增加一项秒杀订单信息（订单id、用户id、代金券id）</p>
<p>秒杀下单思考：下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p><strong>超卖问题：</strong>线程1过来查询库存，判断库存大于1，正准备去扣减库存，还没扣；此时线程2也去查询库存，发现数量也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。（优惠券库存变为负数，订单表条目超过库存数量），超卖问题是典型的多线程安全问题</p>
<p><strong>解决方案就是加锁：</strong></p>
<ul>
<li><p><strong>悲观锁：</strong>认为线程安全很重要，操作数据前必须先获得锁，确保数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p></li>
<li><p><strong>乐观锁：</strong>认为线程安全问题不一定会发生，因此不直接加锁。会有一个版本号version，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1
，如果大1
，则进行操作成功（如果大了其他，或version不对应了，证明数据被修改过）。乐观锁还有一些变种的处理方式比如cas</p></li>
</ul>
<p>自旋操作（spin
lock）：如果一个线程正在尝试获取某个资源，但该资源当前被其他线程占用，它就会不断重复检查该资源的状态，直到资源可用</p>
<p>CAS（Compare-and-Swap）操作：一种常用的原子操作，主要用于解决多线程中的竞争条件，原子性保证了在多线程环境下的操作是线程安全</p>
<h4 id="乐观锁解决超卖问题">乐观锁解决超卖问题</h4>
<p>实现时，是由seckillVouncher方法的最后，若库存充足则扣减库存，调用createVoucherOrder方法</p>
<p>VoucherOrderServiceImpl
在扣减库存时，createVoucherOrder函数中扣减部分改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">// where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>
<p>以上逻辑的核心含义是：只要扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存;</p>
<p>但是以上这种方式通过测试发现会有很多失败的情况，原因：使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中<strong>只有1个人能扣减成功</strong>，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败，导致商品虽然不会超卖，但也很多没卖出去，操作失败率高。</p>
<p><strong>改成stock大于0 </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>
<h3 id="优惠券秒杀一人一单问题逐步加锁">3.3
优惠券秒杀——一人一单问题——逐步加锁</h3>
<p>现在的情况是一个人可以无限制的抢这个优惠卷（黄牛），要求同一个优惠券，一个用户只能下一单</p>
<p>实现思路：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653371854389-1734362376722.png"
alt="1653371854389" />
<figcaption aria-hidden="true">1653371854389</figcaption>
</figure>
<p>在优惠券订单实现类的createVoucherOrder方法中，增加一人一单逻辑：函数上需要增加@Transactional事务注解（查询订单、扣减库存和创建订单一致性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">   <span class="comment">// 5.1.用户id</span></span><br><span class="line">   <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">   <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">   <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 用户已经购买过了</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 订单表中不存在的用户可以购买</span></span><br><span class="line">   <span class="comment">//6.扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//7.创建订单</span></span><br><span class="line">   <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">   <span class="comment">// 7.1.订单id</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">   voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">   voucherOrder.setUserId(userId);</span><br><span class="line">   <span class="comment">// 7.3.代金券id</span></span><br><span class="line">   voucherOrder.setVoucherId(voucherId);</span><br><span class="line">   save(voucherOrder);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Result.ok(orderId);</span><br></pre></td></tr></table></figure>
<p><strong>存在问题：</strong>同一个用户id的多个线程并发过来，第一次购买，查询数据库，都不存在订单，都可以走到第六步购买；</p>
<p>针对这个问题，我们还是需要加锁，但是乐观锁比较适合更新数据(不同线程带来不同版本，解决超卖)，而现在是插入数据(不同线程同时插入)，所以我们需要使用悲观锁操作</p>
<ol type="1">
<li><p>封装了一个<code>createVoucherOrder</code>方法，在方法上增加<code>synchronized</code>锁，当前锁是this，当前对象，此方法实现查询订单，扣减库存，创建订单，返回结果</p>
<ol type="1">
<li>问题：锁的范围过大，任何用户来了都得等锁，而非是同一用户，粒度太粗了</li>
<li>在使用锁过程中，控制<strong>锁粒度</strong>
是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住</li>
</ol></li>
<li><p>加锁的时候按照用户ID来加，同一用户加一把锁，不同用户不同锁，获取到代码，然后<code>synchronized(userId.toString().intern())&#123;剩下代码&#125;</code>，toString每次都是一个全新字符串，返回字符串的规范表示：从常量池中拿到数据，只按值判断；此时在方法内部加锁</p>
<ol type="1">
<li>问题：在方法内部加锁，在执行完逻辑代码，理论上锁已经释放了，其他线程可以进来，但是又有@transactional事务逻辑，若未提交事务时，其他线程面对的数据库还是之前的，仍然可以进来，产生订单安全问题</li>
<li>事务没提交而锁已经释放</li>
</ol></li>
<li><p>故应该加在整个函数的外面，锁住整个函数：在<code>seckillVoucher</code>方法中，添加以下逻辑，先获取ID，然后锁住要返回的函数（创建订单），函数执行完，事务一定已经提交，数据库已经更新，释放的锁才能被其他进程正确使用。保证事务特效同时也控制了锁的粒度；</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373434815-1734362376722.png"
alt="1653373434815" />
<figcaption aria-hidden="true">1653373434815</figcaption>
</figure>
<p>问题：调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效</p></li>
<li><p>Spring事务失效：事务是创建一个代理对象，对代理对象事务一致性操作；但是this.的方式调用的是非代理对象，目标对象；</p>
<ol type="1">
<li><p>需要拿到代理对象：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653383810643-1734362376722.png"
alt="1653383810643" />
<figcaption aria-hidden="true">1653383810643</figcaption>
</figure></li>
</ol></li>
<li><p>需要引入asproxy依赖，加@Enable...注解设置为true才能生效</p>
<p>​ <strong>还需要去掉sekillVouncher方法上面的注解</strong></p></li>
</ol>
<h3 id="分布式集群环境的并发问题">3.4 分布式集群环境的并发问题</h3>
<p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373887844-1734362376722.png"
alt="1653373887844" />
<figcaption aria-hidden="true">1653373887844</figcaption>
</figure>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373908620-1734362376722.png"
alt="1653373908620" />
<figcaption aria-hidden="true">1653373908620</figcaption>
</figure>
<p><strong>有关锁失效原因分析</strong></p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，同一JVM内部锁维护锁监视器对象(user_id)，利用同一常量池的id是可以实现互斥，但此时服务器JVM不一样时，又有两个线程但是却不是同一个锁监视器，故线程1和线程3就可以是同一个用户</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653374044740-1734362376722.png"
alt="1653374044740" />
<figcaption aria-hidden="true">1653374044740</figcaption>
</figure>
<p>故要使用跨集群的锁——<strong>分布式锁</strong></p>
<h3 id="分布式锁simplelock自己实现">3.5
分布式锁——simpleLock(自己实现)</h3>
<p>分布式锁需要满足：<strong>多进程可见、互斥</strong>、高可用、高并发（高性能）、安全性</p>
<p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且互斥的锁，原本一个JVM一个锁监视器，现在统一用一个锁监视器了</p>
<p><strong>常见分布式锁：</strong></p>
<p>Mysql：本身互斥锁机制，性能一般；Redis：常见方式，<strong>setnx</strong>方法，插入Key成功则成功获得锁，后续的人无法成功插入这个数据；Zookeeper：利用节点有序性和唯一性实现互斥</p>
<p><strong>Redis实现：</strong></p>
<p>获取锁：互斥（一次只能一个获取）、非阻塞（尝试一次、成功true，失败false，无法再重试）</p>
<p>释放锁：手动释放、超时释放（超时时间）</p>
<h4 id="核心思路与基本实现">3.5.1 核心思路与基本实现</h4>
<p><strong>setNx
方法：</strong>有多个线程进入时，第一个线程进入时，setnx key
value，其中key是携带用户id信息的，可以创建成功，即获取了锁，返回1，去执行业务，后删除锁delete
key实现退出锁逻辑；其他线程无法再设置这个key，执行返回0，需要等待一定时间后重试setnx。</p>
<ul>
<li><strong>加锁逻辑</strong></li>
</ul>
<p>utils下增加：<strong>接口：ILock</strong></p>
<p>实现两个方法<code>boolean tryLock(传入锁持有时间，过期自动释放)</code>和<code>void unlock()</code></p>
<p>utils下增加：<strong>SimpleRedisLock实现ILock</strong></p>
<p>有参构造，传入name和redistemplate实例化对象，</p>
<p>tryLock：获取线程标识，利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性（setnx
expire 一起执行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>释放锁逻辑：</strong></li>
</ul>
<p>直接删除<code>stringRedisTemplate.delete(KEY_PREFIX + name);</code></p>
<ul>
<li>设计完工具方法后，修改vouncherOrderService实现类的<strong>seckillVoncher</strong>方法：</li>
</ul>
<p>在发现库存充足后，此时不需要在<code>proxy.createVoucherOrder</code>外部利用synchronized上锁了（用分布式锁了，更高级，不需要刚才实现的防止一人一单的方法了）<strong>但是：</strong>分布式锁确保了同一时间只有一个用户能执行
<code>createVoucherOrder</code>
方法，而事务管理确保了方法执行过程中的一致性和原子性，所以此时仍需要代理对象</p>
<p>在判断库存后面上锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">// 创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">// 获取锁对象，加锁1200秒</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">// 加锁失败：证明同一用户正在下单了</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)：执行查询订单、扣减库存、创建订单</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="误删问题">3.5.2 误删问题</h4>
<p><strong>问题</strong>：我们设置了锁的自动过期时间，若持有锁的线程1在锁的内部出现了阻塞，导致他的锁自动释放，被其他线程获取；但线程1本身并不知晓，阻塞结束后继续执行本身逻辑，完成逻辑后删除锁（释放锁），此时删除的是属于线程2刚才获取的锁，这就是误删别人锁的情况；</p>
<p><strong>解决方案：</strong>每个线程释放锁的时候，去判断一下当前这把锁<strong>是否属于自己</strong>，属于自己则可以释放，是属于自己，证明已经被释放了，此时不删除锁。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653385920025-1734362376722.png"
alt="1653385920025" />
<figcaption aria-hidden="true">1653385920025</figcaption>
</figure>
<p><strong>实现方案：</strong>集群的模式下，直接利用threadID，不同JVM可能相同，因此在获取锁时存入线程标示（可以用该线程UUID
+ 线程ID），此时再拼接同一JVM的不同线程ID</p>
<p>UUID：全局唯一的标识符，区分不同的 JVM 实例</p>
<p>修改tryLock和unLock代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前JVM的唯一标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原子性问题lua脚本">3.5.3 原子性问题——Lua脚本</h4>
<p><strong>误删问题2：</strong>阻塞发生在线程判断标识一致和释放锁之间：线程1持有锁后执行业务逻辑，结束后他准备删除锁，此时发生阻塞，线程1锁在阻塞过程中到期已经自动释放。此时线程2进来，线程1阻塞完后会删除当前线程2获取的锁（因为他刚刚判断了锁是自己的，但是没来得及删），这就是删锁时的原子性问题。</p>
<p><strong>本质</strong>：线程1的拿锁，比锁，删锁，并不是原子性</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653387764938-1734362376722.png"
alt="1653387764938" />
<figcaption aria-hidden="true">1653387764938</figcaption>
</figure>
<p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的<strong>原子性</strong>。</p>
<p>重点介绍Lua脚本中Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>
<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<p>写好脚本以后，需要用Redis命令来调用脚本</p>
<p>脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653392438917-1734362376722.png"
alt="1653392438917" />
<figcaption aria-hidden="true">1653392438917</figcaption>
</figure>
<p>之前释放锁的业务流程是这样的：</p>
<p>1.获取锁的唯一线程标识</p>
<p>2.比较是否和当前线程标识一致</p>
<p>3.一致则删除；不一致则直接over</p>
<p><strong>Lua脚本实现：</strong></p>
<p>线程标识是key-value中的value即UUID+线程标识，key是userID</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="comment">-- 利用redis.call(&#x27;GET&#x27;, KEYS[1])先取Key（拼接lock:(order:userId传入)）对应的value（锁的线程标识），与当前线程标识比较</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>在Java代码中调用Lua脚本</strong>：</p>
<p>RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653393304844-1734362376722.png"
alt="1653393304844" />
<figcaption aria-hidden="true">1653393304844</figcaption>
</figure>
<p><strong>Java代码</strong></p>
<p><code>static</code> 的作用是确保指示 Lua 脚本
的变量<code>UNLOCK_SCRIPT</code> 只被加载和初始化一次</p>
<p><strong>静态代码块</strong>，它会在
<strong>类加载时自动执行</strong>，且只执行一次。它用于初始化静态变量
<code>UNLOCK_SCRIPT</code>，在静态代码块中被初始化为一个新的
<code>DefaultRedisScript</code> 对象，并且设置了 Lua
脚本的路径（<code>unlock.lua</code>）以及脚本的执行结果类型（<code>Long.class</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UNLOCK_SCRIPT是一个静态变量，它被声明为 static，它属于类本身，而不是类的实例，无论你创建多少个该类的实例，UNLOCK_SCRIPT 始终只有一个实例，UNLOCK_SCRIPT 只在类加载时初始化一次，且所有实例共享同一个对象，避免了重复的初始化操作（节省资源）</span></span><br><span class="line"><span class="comment">// final 关键字保证了 UNLOCK_SCRIPT 一旦被赋值就无法再改变它指向的对象。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁的时候判断和删除一起做</span></span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name), <span class="comment">//（脚本中的参数KEYS[1]）</span></span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId()); <span class="comment">// （脚本中的参数ARGV[1]）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>：添加过期时间，防止死锁问题的发生，但可能出现到期以后误删别人锁的问题，开始是利用删之前对比锁标识和自己标识，但可能出现原子性问题也会误删，通过lua表达式来解决这个问题。</p>
<p><strong>基于setnx分布式锁实现存在问题：</strong></p>
<p><strong>重入问题</strong>：获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，如A方法获得锁，调用B方法，而B方法也需要锁，则B在等待A释放，A调用的B未执行A没法释放，此时发生死锁；synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：目前的分布式中只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，自己锁已经释放，存在安全问题；利用redission也可以实现到期续约，不会误删别人的锁；</p>
<p><strong>主从一致性：</strong>
如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653546070602.png" alt="1653546070602" style="zoom: 38%;" /></p>
<h3 id="分布式锁redisson">3.6 分布式锁——redisson</h3>
<h4 id="redisson介绍与应用">3.6.1 Redisson介绍与应用</h4>
<p>Redisson在Redis的基础上实现的Java驻内存数据网格（In-Memory Data
Grid），是一个 <strong>Java Redis 客户端</strong>，它封装了 Redis
的基本操作，并且提供了许多高层次的抽象。Redisson 的目标是简化与 Redis
的交互，同时提供一些高级功能，如分布式锁、分布式集合、分布式缓存。简言之：Redis的儿子（增强版），更高级，交互更方便</p>
<p>引入依赖，注册配置客户端</p>
<p><strong>使用案例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span> <span class="comment">// 引入Redisson客户端实例</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 VoucherOrderServiceImpl注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="comment">// 在seckillVoucher函数块中部分核心代码：</span></span><br><span class="line"> <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 创建锁对象 下面代码不用了，因为我们现在要使用Redisson提供的锁，不用自己创建的simple锁了</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId); <span class="comment">// 锁的名称即key</span></span><br><span class="line">        <span class="comment">// 获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>利用以上RedissonClient提供的锁我们即可实现Reddision锁，解决上述的四个问题，下面我们剖析一下Reddisson实现这些功能的原理</p>
<h4 id="reddisson可重入可重试超时释放原理">3.6.2
Reddisson可重入、可重试、超时释放原理</h4>
<p>** 可重入**</p>
<p>Lock锁中，借助于底层的一个voaltile（关键字，修饰变量确保该变量的值对所有线程可见的）的一个state变量来记录重入的状态的，无人拥有此锁state
= 0，每有一个人拥有state +
1；对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，直到减少成0
时，表示当前这把锁没有被人持有；</p>
<p>在redission中，支持可重入锁：采用hash结构用来存储锁，其中key表示这把锁是否存在，field表示当前这把锁被哪个线程持有（线程标识）,value代表重入次数。分析源码：trylock调用tryLockAsync，返回
tryAcquireOnceAsync，函数中调用tryLockInnerAsync，其中存在lua表达式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"> <span class="string">&quot;end; &quot;</span> +</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]： 锁失效时间</strong></p>
<p><strong>ARGV[2]： id + ":" + threadId;
锁的小key，标识当前锁的被哪个线程持有</strong></p>
<ul>
<li><p>首先进行判断：exists 判断Redis数据库中是否存在
name：如果==0，就表示当前这把锁不存在，可以获取锁：</p>
<p><code>redis.call('hset', KEYS[1], ARGV[2], 1)</code>;此时他就开始往redis里边去写数据
，hash结构，锁名称通常是用户ID(KEYS[1])-线程标识符或
UUID（ARGV[2]），数字1代表当前线程已经获得锁；<code>pexpire</code>
命令为锁设置一个过期时间，单位是毫秒最后返回nil；</p></li>
<li><p>如果这把锁已经存在，<code>hexists</code>
命令检查这把锁是否是属于自己，即对比当前线程标识符ID和锁的标识符（key对应的value），如果是自己的，<code>hincrby</code>将当前这个锁的value进行+1
，然后再对其设置过期时间<code>redis.call('pexpire', KEYS[1], ARGV[1])</code>;返回nil</p></li>
<li><p>如果以上两个条件都不满足，即当前锁已被其他线程或进程占用且无法重入，脚本返回当前锁的剩余有效时间（<code>pttl</code>
命令返回的是锁的过期时间，单位毫秒；</p></li>
</ul>
<p>整体：<strong>加锁（无人获取）</strong>、<strong>重入锁（同一线程已经获取了锁，可以就行获取，重入增加次数，延长过期时间）</strong>、<strong>锁的过期（持锁线程在过期时间内没有释放锁，其他线程可以重新获取该锁。）</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653548087334-1734362376722.png"
alt="1653548087334" />
<figcaption aria-hidden="true">1653548087334</figcaption>
</figure>
<p>** 可重试**</p>
<p>** 实现思路：**</p>
<ul>
<li><strong>获取锁：</strong></li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241210123703596-1734362376722.png"
alt="image-20241210123703596" />
<figcaption aria-hidden="true">image-20241210123703596</figcaption>
</figure>
<p>ttl表示获取已有锁的过期时间，null表示当前没有已存在的锁，即可以成功获取锁；否则判断剩余等待时间，如果等待时间小于0了，则证明已经不需要等了，直接返回；如果大于0（证明还需要接着等），此时利用Lock的Pubsub订阅锁并等待释放，定期判断等待时间若超时则取消订阅并返回false，否则尝试获取；</p>
<p>leaseTime是释放时间（有效期），如果过了有效期，则可以重新获取锁，返回true；</p>
<p>如果在有效期内，则开启看门狗机制，watchDog不停更新锁的有效期</p>
<ul>
<li><strong>释放锁</strong>：</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241210123803989-1734362376723.png"
alt="image-20241210123803989" />
<figcaption aria-hidden="true">image-20241210123803989</figcaption>
</figure>
<p>unlock相对简单很多，执行释放脚本，释放成功发送释放消息publish，取消watchDog任务</p>
<p>** 超时释放**</p>
<p>renewExpiration此逻辑就是续约逻辑</p>
<p>分析lock()方法的源码解析</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>3、锁存在且不是这个线程，开始抢锁（尝试获取锁），即上面的执行流程图；</p>
<p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕；但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，此时有个while(
true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数则leaseTime是他本身，一个是不带参数默认传入leaseTime
= -1；leaseTime时间内都会去抢锁，抢锁过程的逻辑与之前相同。</p>
<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间
commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p><strong>ttlRemainingFuture.onComplete((ttlRemaining, e)</strong>
这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程，续约逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>
<p>commandExecutor.getConnectionManager().newTimeout（）方法：Method(
<strong>new</strong> TimerTask() {},参数2 ，参数3 )</p>
<p>通过参数2，参数3
去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask
就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mutilock应用">3.6.3 MutiLock应用</h4>
<p>利用redission锁可以实现上述的功能，但无法实现<strong>主从一致性</strong></p>
<p>Redis集群中，主节点：存数据；从节点：读数据。主从同步时，数据会有一定延时，如主节点获取锁，写在主节点的数据还没来得及写从节点上，此时主机宕机，哨兵发现，选举一个slave变成<strong>新的master</strong>，而此时新的master中实际上<strong>并没有锁信息</strong>，此时锁信息就已经丢掉了，其他线程可以获得锁了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553998403.png" alt="1653553998403" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>redission提出来了MutiLock锁，使用这把锁每个节点地位一致，<strong>加锁的逻辑需要写入到每一个主丛节点上</strong>，只有所有的服务器都写入成功，此时才是加锁成功；若一个节点挂了，其他乘虚而入的进程获得锁的时候，只要有一个节点的拿不到，就不算加锁成功。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653554055048-1734362376723.png"
alt="1653554055048" />
<figcaption aria-hidden="true">1653554055048</figcaption>
</figure>
<p><strong>MultiLock加锁原理：</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553093967-1734362376723.png"
alt="1653553093967" />
<figcaption aria-hidden="true">1653553093967</figcaption>
</figure>
<p>设置多个锁的时候，redisson将多个锁加入一个集合中，（在总的加锁时间内，这个时间是用需要加锁的个数
* 1500ms）并且while循环不断尝试拿锁，假设这时间内，所有的锁都加锁成功，
那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试。</p>
<p><strong>测试：</strong>test类中配置RedisClient中若干个主从节点redisClient1/2/3，给他们获取对应的lock1/2/3，创建multiLock，<code>lock  = redissonClient1/2/3.getMultiLock(lock1,lock2,lock3)</code></p>
<h4 id="小结redis解决四个问题">小结：Redis解决四个问题</h4>
<ol type="1">
<li><strong>可重入问题：</strong>同一线程(不同函数)可以调用自己的锁，获取锁：利用hash结构记录线程标识和重入次数；释放：每释放一次，重入-1，减为0，真正释放锁</li>
<li><strong>锁失败重试问题</strong>：失败后可以重试获取，而不是直接false，利用信号量和pubsub订阅（发布-订阅模式）功能实现等待、唤醒、获取锁失败的重试机制，也非无限制重试，有等待时间；</li>
<li><strong>锁超时释放（续约）问题：</strong>利用watchDog，开启定时任务，每隔一段时间重新配置expire，重置超时时间</li>
<li><strong>主从一致性问题：</strong>利用multipleLock，分布式锁实现</li>
</ol>
<p>此时我们便利用Redis解决四个问题<strong>：可重入问题、可重试、超时释放、主从一致性</strong>；至此，项目秒杀优惠券业务完成一人一单的优化，但是性能还可以做一定的优化</p>
<h2 id="iv-秒杀优化">IV 秒杀优化</h2>
<p>回顾一下购买优惠券下单流程：</p>
<p>用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：</p>
<p>1、查询优惠卷</p>
<p>2、判断秒杀<strong>库存是否足够</strong></p>
<p>3、查询订单</p>
<p>4、校验是否是<strong>一人一单</strong></p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>其中，查询优惠券、查询订单、扣减库存和创建订单都是对数据库的直接操作，且在一个线程内串行执行，效率较低；需要异步执行加速</p>
<h3 id="异步秒杀">4.1 异步秒杀</h3>
<h4 id="思路">4.1.1 思路</h4>
<ol type="1">
<li>将耗时比较短的逻辑判断放入到redis中，判断是否库存足够及一人一单，快速的逻辑判断后，将下单信息存入消息队列，然后直接给用户返回成功；</li>
<li>再在后台开一个线程，后台线程从队列取出下单信息，去执行和数据库相关逻辑；</li>
</ol>
<p><strong>两大问题：</strong></p>
<ul>
<li>redis中去快速库存判断和校验一人一单</li>
<li>由于校验和tomct下单是两个线程，如何知道到底是哪个单，以及最后是否成功</li>
</ul>
<p><strong>解决方案</strong>：库存判断利用key-value中的value，一人一单通过set集合区分该用户是否下过单；在redis操作完之后，我们会将一些信息（订单id）返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653561657295-1734362376723.png"
alt="1653561657295" />
<figcaption aria-hidden="true">1653561657295</figcaption>
</figure>
<p><strong>整体：</strong>用户下单-&gt;判断库存充足（不足结束）-&gt;
校验一人一单（不是结束）-&gt;
完成下单，扣除Redis库存，此后将用户id和优惠卷信息存入到redis（Lua
脚本实现原子性库存充足和校验需要原子性操作，否则超卖和重复下单）-&gt;
对Redis操作完毕返回值（0代表成功，1代表超卖，-1代表重复下单）-&gt;
成功即将刚才存入的信息放入queue，利用新线程异步下单</p>
<p>前端可以通过返回的订单id来判断是否下单成功，整体流程类似于饭店接单，服务员先接单给个小票（告诉顾客已经完成），同时告诉厨师可以炒了，厨师异步操作</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653562234886-1734362376723.png"
alt="1653562234886" />
<figcaption aria-hidden="true">1653562234886</figcaption>
</figure>
<h4 id="redis实现资格判断">4.1.2 Redis实现资格判断</h4>
<p>实现资格判断时，核心在于：管理端保存优惠券到Redis，用户端下单的时候基于Lua脚本判断库存容量和一人一单、成功下单后将优惠券id和用户id封装后存入阻塞队列、开启线程任务不断从阻塞队列中获取信息实现异步下单，共四步任务，<strong>实现代码</strong>如下：</p>
<p>用户购买进入Vounchercontroller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管理端增加优惠卷的时候，调用VoucherService接口，实现类VoucherServiceImpl中，<strong>实现保存优惠券到Redis</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户端下单购买优惠券的时候，会进入VouncherOrdercontroller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> voucherOrderService.seckillVoucher(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入优惠券ID，在VoucherOrderServiceImpl中，我们实现第二步：<strong>基于Lua脚本判断库存容量和一人一单</strong></p>
<p>再次修改seckillVouncher代码：此时创建订单和判断是否下单成功是异步操作，Redis
操作和库存更新、订单创建是分离的，<code>createVoucherOrder</code>
方法已经独立，不依赖代理对象的事务支持或锁逻辑；故</p>
<ol type="1">
<li><code>createVouncher</code>方法不需要再通过代理对象调用，去掉proxy</li>
<li>此外，现在去掉了@Transactional，将分布式锁直接加在了<code>createVouncher</code>上，通过
Redis 校验和分布式锁减少了对事务的依赖</li>
</ol>
<p>其实在Redis中我们已经判断一人一单和超卖问题了，因而无需在此时加锁再次判断，但为了以防万一，代码健壮性~，再次加锁再次判断一遍超卖和；</p>
<p>修改代码后，seckillVouncher仅用来对接用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建1024*1024的阻塞队列，ArrayBlockingQueue 是 Java 中的一个阻塞队列实现，基于 数组 实现</span></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 2.2.为0 ，有购买资格，把下单信息保存到阻塞队列</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的Lua脚本实现判断库存容量和一人一单：</p>
<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>seckill执行完以后，若可以创建订单，则开启另一个线程调用createVouncherOrder用来实现真正创建订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">        log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步下单：判断有没有资格，执行业务加各种锁，业务执行完耗时较久</p>
<p>异步下单：业务分成两部分，一部分是Redis进行抢购资格的判断（如果有资格，则立即下单成功）；耗时较久的下单部分（操作数据库）异步完成，放入阻塞队列</p>
<p>故接下来利用阻塞队列实现异步下单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    createVouncherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程池（<code>SECKILL_ORDER_EXECUTOR</code>）</strong>：</p>
<ul>
<li>创建了一个单线程的线程池（<code>Executors.newSingleThreadExecutor()</code>），用于异步处理订单。</li>
<li><code>orderTasks</code> 是一个阻塞队列，用于存储待处理的订单</li>
<li>利用 <code>@PostConstruct</code> 注解，在 Spring
容器初始化该类后便会执行init方法， 调用submit方法将
<code>VoucherOrderHandler</code> 任务提交到线程池</li>
<li><strong><code>VoucherOrderHandler</code> 任务的核心逻辑：</strong>
<ul>
<li><code>while (true)</code>：保证线程池中的线程
<strong>持续运行</strong>，不停从队列中获取订单进行处理。</li>
<li><code>orderTasks.take()</code>：
<ul>
<li>这是从阻塞队列中获取订单的逻辑，如果队列为空，<code>take()</code>
方法会阻塞线程，直到队列中有新的订单加入（实现高效的任务调度）。</li>
</ul></li>
<li><strong><code>createVoucherOrder(voucherOrder)</code>：</strong>取到订单后，调用
<code>createVoucherOrder</code> 方法完成实际的订单创建操作。</li>
</ul></li>
</ul>
<h3 id="redis消息队列">4.2 Redis消息队列</h3>
<h4 id="消息队列三种类型介绍">4.2.1 消息队列三种类型介绍</h4>
<p>消息队列是JVM以外独立服务，解决内存问题；存入磁盘，且需要消费者确认，不然一直投递到消费者。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653574849336-1734362376723.png"
alt="1653574849336" />
<figcaption aria-hidden="true">1653574849336</figcaption>
</figure>
<p><strong>基于List结构模拟消息队列</strong>：Redis的list数据结构是一个双向链表，很容易模拟出队列效果</p>
<p>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限，基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失（从队列中取走未消费，想去再取发现没了）</li>
<li>只支持单消费者</li>
</ul>
<p><strong>基于PubSub的消息队列</strong>：PubSub（发布订阅）是Redis2.0版本引入的消息传递模型，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化（更像是一个通道，未被订阅则消失）</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失（不在内存保存，数据在消费者有个缓存区域，做处理，处理较慢时空间超过则丢失）</li>
</ul>
<p><strong>基于Stream的消息队列</strong>：Redis 5.0
引入的一种新数据类型，可以实现一个功能非常完善的消息队列</p>
<h4 id="基于stream的消息队列实现">4.2.2 基于Stream的消息队列实现</h4>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li><strong>有消息漏读的风险</strong></li>
</ul>
<p><strong>漏读</strong>：如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p><strong>解决方案：</strong>利用消费者组</p>
<p>消费者组（Consumer
Group）：将多个消费者划分到一个组中，监听同一个队列；可以进行<strong>消息分流</strong>，队列中的消息会分流给组内的不同消费者（组内消费者竞争）、<strong>消息标识</strong>，消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费、<strong>消息确认</strong>，消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。</p>
<p>创建消费者组： <img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653577984924-1734362376723.png"
alt="1653577984924" /> key：队列名称 groupName：消费者组名称
ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息
MKSTREAM：队列不存在时自动创建队列</p>
<p><strong>小结：</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653578560691-1734362376723.png"
alt="1653578560691" />
<figcaption aria-hidden="true">1653578560691</figcaption>
</figure>
<p>修改lua表达式,新增3.6
，将消息发送到队列中，队列名称为stream.orders</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1656082824939-1734362376723.png"
alt="1656082824939" />
<figcaption aria-hidden="true">1656082824939</figcaption>
</figure>
<p>修改VouncherOrderServiceImpl代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中
handlePendingList即用来处理异常订单，即没有被ACK标记已经处理的订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们对于优惠券秒杀业务已经全部完成！下面是利用一些现成的mq，比如（kafka，<strong>rabbitmq</strong>）来实现消息队列，见五、RabbitMQ篇</p>
<h1 id="二新增业务数据库准备">二、新增业务数据库准备</h1>
<p>涉及到优惠券秒杀业务的数据库有：</p>
<p>管理端表 employee ：已经存在，<strong>实现增删优惠券</strong></p>
<p>用户表 user: 已经存在，<strong>实现抢购秒杀优惠券</strong></p>
<p>优惠券表voucher包括：优惠券标题、副标题、使用规则、支付金额、抵扣金额、劵类型、优惠券状态、创建时间和更新时间，<strong>实现记录优惠券信息</strong></p>
<p>优惠券订单表voucher_order包括：下单用户的ID、购买优惠券ID、支付方式、订单状态、下单时间、支付时间、核销时间、退款时间、更新时间，<strong>实现记录用户抢购的优惠券订单，普通券没库存</strong></p>
<p>秒杀券表voucher_seckill包括：关联的优惠券ID（主键）、库存、创建时间、生效时间、失效时间、更新时间、外键关联秒杀优惠券表，与优惠券是一对一关系</p>
<h2 id="接口设计和实体类设计">接口设计和实体类设计</h2>
<p>管理端操作优惠券：实现如下功能</p>
<p>路径：<code>http://localhost:8080/admin/voucher</code></p>
<ol type="1">
<li>添加普通券：路径不变、POST方式（传入VoucherDTO对象）、返回优惠券ID</li>
<li>添加秒杀券：路径：<code>/seckill</code>、Post方式（传入VoucherDTO对象，其中额外包括秒杀属性）、返回优惠券ID</li>
<li>分页查询优惠券列表：路径：<code>/list</code>、Get方式（传入VoucherPageQueryDTO），返回VoucherVO对象（包含voucher中部分属性：优惠券标题、副标题、使用规则、支付金额、抵扣金额、劵类型、优惠券状态）</li>
<li>下架优惠券，路径：<code>/delete/&#123;id&#125;</code>、DELETE方式，返回无，直接按照id删除对应优惠券</li>
</ol>
<p>实体类：</p>
<p>public class Voucher :包含属性同数据库属性</p>
<p>public class VouncherSeckill：仅含秒杀券的属性</p>
<p>public class VouncherDTO：普通券表 +
秒杀券表的额外属性，去掉创建和更新时间</p>
<p>客户端：</p>
<p>查询优惠券，路径同前面</p>
<p>购买优惠券：路径<code>http://localhost:8080/user/voucher/&#123;id&#125;</code>、POST请求路径参数传入购买的用户券ID、返回购买的优惠券ID或购买失败信息；</p>
<p>public class VouncherOrder：与订单表对应</p>
<h2 id="代码框架与实现思路">代码框架与实现思路</h2>
<p>管理端（小）：</p>
<p>controller层做接受信息，调用voucherService实现业务逻辑，在service中调用mapper实现数据库操作</p>
<ul>
<li><p>添加普通券：利用MybatisPlus在Service中直接实现save（）</p></li>
<li><p>添加秒杀券：调用service实现类，先利用mp添加优惠券，再保存秒杀信息，利用mp添加秒杀券</p></li>
<li><p>查询优惠券订单：调用service的Query方法，利用mp自定义实体类实现</p></li>
</ul>
<p>分页查询，利用插件设置分页参数，自动加入Limit语句（创建一个
<code>Page</code> 对象，这个 <code>Page</code> 对象用于 MyBatis Plus
的分页查询，它会自动计算 SQL 查询的分页偏移量
<code>LIMIT</code>），同时传入<code>wrapper</code>设置查询条件（注意if条件判断，如果没有就不加这个查询条件），返回<code>Page&lt;Voucher&gt;</code>
对象，它包含了查询结果和分页信息，再转换为voucherVO传给前端</p>
<p>传给前端时需要：new 一个PageResult对象</p>
<p><code>page.getTotal()</code>：获取分页结果的总记录数。</p>
<p><code>page.getRecords()</code>：获取分页后的数据记录（即
<code>VoucherVO</code> 对象的列表）。</p>
<ul>
<li>删除优惠券：通过路径参数传入删除的券ID，判断券是否是秒杀券类型，如果是还要删除秒杀券表中的信息；</li>
</ul>
<p>客户端（大）：</p>
<p>实现查询优惠券，分页查询，用redis实现，解决缓存击穿/穿透问题</p>
<p>购买时按照note中的逻辑实现：</p>
<p>建立User的Controller，Service，重点是serviceImpl</p>
<p>主要流程：</p>
<p>本质上是用户下单，减少库存，创建订单表</p>
<p>1.乐观锁解决超卖问题</p>
<p>2.redisson分布式锁解决集群模式下一人一单问题</p>
<p>3.秒杀优化中实现异步秒杀（Redis解决前面两个问题，多线程消息队列对接数据库操作）</p>
<p>实现思路（逻辑）：</p>
<p>Controller传入下单ID，orderService调用下单方法</p>
<p>下单方法实现：</p>
<ol type="1">
<li>创建订单全局唯一ID</li>
<li>执行lua脚本，全程在redis实现：判断库存是否充足（解决超卖）、判断用户是否下单（一人一单）、扣库存，下单（保存用户ID到redis），发送下单消息到消息队列</li>
<li>返回Lua脚本执行结果（1库存不足，2不能重复下单，0成功），成功直接返回订单全局唯一ID（返回给用户认为已经下单）</li>
</ol>
<p>异步下单：</p>
<ul>
<li>在下单方法的所在类初始化完成即会创建一个单线程的线程池，提交任务；</li>
<li>新定义任务类，不断地从消息队列取订单消息（利用GROUP），如果为null(没有消息时)，继续下一次循环；取到消息后解析数据，调用创建订单函数创建订单，发送ACK确认消息，代表取到消息了；一旦发送堵塞等某些异常消息，有未确认消息线程进入
Pending List，系统定期处理（与上面的一样的处理方式）</li>
<li>在创建订单部分，再次加锁（双重保证一人一单问题）</li>
</ul>
<p>实现了一个基于 Redis 和 Spring 的高性能秒杀系统，采用 Redis 的
<strong>Lua
脚本</strong>进行秒杀资格的快速校验，包括库存扣减和防止重复下单，同时将秒杀成功的订单数据写入
Redis <strong>Stream 队列</strong>。后台通过线程池异步监听队列，从
Stream 中消费订单数据并创建订单，保证主线程的响应速度。订单创建中使用
<strong>分布式锁</strong>（Redisson
实现）确保同一用户不会重复下单，并安全扣减库存。系统还实现了异常处理机制，通过
Pending List
确保未确认的订单消息不会丢失，从而实现了高并发场景下的订单创建、一人一单、库存安全以及消息可靠性保障的完整流程。</p>
<h3 id="秒杀总结流程图">秒杀总结流程图</h3>
<p>前置：1. 生成全局唯一ID 2.编写Lua脚本内容 3.创建常量，以及线程池</p>
<ol type="1">
<li>用户发起秒杀请求 → 执行 Redis Lua 脚本：
<ul>
<li>库存扣减，创建订单到消息队列</li>
<li>数据写入 Redis Stream 队列。</li>
</ul></li>
<li>后台线程不断监听 Redis Stream：
<ul>
<li>读取订单消息 → 解析数据 → 执行订单逻辑 → 确认消息。</li>
</ul></li>
<li>异常处理机制：
<ul>
<li>未确认消息进入 Pending List，系统定期处理。</li>
</ul></li>
</ol>
<h1 id="三实现过程中遇到的qa">三、实现过程中遇到的Q&amp;A</h1>
<ol type="1">
<li>mapper中方法对应的xml映射文件报错</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241213182608385.png"
alt="image-20241213182608385" />
<figcaption aria-hidden="true">image-20241213182608385</figcaption>
</figure>
<p>在升级为mp后，xml映射文件中的parameterType和resultType报错，传统的
MyBatis 配置中，如果 <code>parameterType</code> 和
<code>resultType</code> 中只写类名，MyBatis 会假定你的类在
<code>typeAliasesPackage</code> 配置中定义的包路径下；在 MyBatis-Plus
中，通常鼓励开发者使用注解而不是 XML 映射。MyBatis-Plus
并不会自动假设类的路径，因为它简化了传统的 XML
映射配置，所以现在需要加上全部路径的类名</p>
<p>2.请求路径正确，代码正确，如果发送没有反应，就检查@Requestbody是否添加（json格式数据接收时），如果也没问题，检查实体类和发送的json数据是否有不一样的地方，大多是类型不一样的时候（如BigDecimal需要带小数），测试的数据必须一点点排查</p>
<p>3.在批量删除时，也想利用save方法直接实现类似新增的一样，直接构建wrapper条件，不去调用其他的service/mapper，但是报错：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241214171044538.png"
alt="image-20241214171044538" />
<figcaption aria-hidden="true">image-20241214171044538</figcaption>
</figure>
<p>只能调用相对应的mapper进行，如果用Db去实现就会报错，db无法找到实体类对应的数据库表</p>
<p>4.分页查询mp版本与jsql不兼容，手动再引入</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241214174058272.png"
alt="image-20241214174058272" />
<figcaption aria-hidden="true">image-20241214174058272</figcaption>
</figure>
<p>JSqlParser 在 MyBatis-Plus
分页中的作用：分页操作中，<code>JSqlParser</code> 是由 MyBatis-Plus 的
<code>PaginationInnerInterceptor</code> 使用的，它的主要作用是
<strong>解析原始 SQL 并在其基础上自动添加分页逻辑</strong>。</p>
<p>5.设置用户端查询时，利用cacheclient的quryByID函数进行查询，改装函数，改进：1.缓存穿透和缓存击穿同时实现
2.解决第一次查询为null的问题</p>
<p>在缓存击穿的逻辑上增加穿透的实现，利用互斥锁，获得锁的线程去重建缓存数据，其开启一个新线程去重建数据，可以最多等待0.5秒获取新数据，其他没获得锁的线程返回旧的信息</p>
<p>6.TODO：当前缓存查询只能通过ID查询缓存并解决缓存击穿，不能通过其他属性类，且是按照ID，没法返回List（不确定）</p>
<p>7.添加优惠券到数据库的时候，会添加秒杀券到redis，虽然voucherSeckill.getStock()是一个Integer对象，但因为
<code>RedisTemplate</code>
的序列化方式存入Redis变成了乱码，导致在lua脚本无法识别数字</p>
<p><strong>解决办法</strong>：</p>
<p>无效尝试：在存储库存值时将 <code>Integer</code>
显式转换为字符串存储，还是有乱码只是少了点；</p>
<p><strong>有效方案：</strong>使用 <code>StringRedisTemplate</code>
来简化处理，<code>@Autowired</code>注入，然后利用其来保证存储正确数据；</p>
<p><code>stringRedisTemplate.opsForValue().set("seckill:stock:" + voucherSeckill.getVoucherId(), voucherSeckill.getStock().toString());</code></p>
<p>确保在 Lua 脚本中将 Redis 中存储的字符串值通过
<code>tonumber()</code> 转换为数字。</p>
<p>8.执行Lua脚本，始终返回1，代表库存不足，没找到原因</p>
<p>在Lua中添加调试信息：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> stock = redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;debug:stockKey_check&#x27;</span>, <span class="string">&#x27;StockKey is: &#x27;</span> .. stockKey)</span><br><span class="line"><span class="keyword">if</span> (stock == <span class="literal">false</span> <span class="keyword">or</span> <span class="built_in">tonumber</span>(stock) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2 库存不存在或不足则返回1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;debug:stock_check&#x27;</span>, <span class="string">&#x27;Stock is: &#x27;</span> .. <span class="built_in">tostring</span>(<span class="built_in">tonumber</span>(stock)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>发现stockKey的名称为乱码：seckill:stock:�� t
10，遂检查代码，发现执行脚本时也是redisTemplate，于是把所有的redisTemplate全部换成StringRedisTemplate</p>
<p>最终测试：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241216210259589.png"
alt="image-20241216210259589" />
<figcaption aria-hidden="true">image-20241216210259589</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241216222127491.png"
alt="image-20241216222127491" />
<figcaption aria-hidden="true">image-20241216222127491</figcaption>
</figure>
<p>最终结果：只有一个线程可以同时下单成功</p>
<h1 id="四mybatis-plus学习总结">四、Mybatis-plus学习总结</h1>
<p>配置mp：</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置：</p>
<p>application.yml:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="attr">mapper-locations:</span> <span class="string">$&#123;sky.mybatis-plus.mapper-locations&#125;</span> <span class="comment"># 如果使用 XML 映射文件</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">      <span class="attr">log-impl:</span> <span class="string">$&#123;sky.mybatis-plus.configuration.log-impl&#125;</span> <span class="comment"># 开启 SQL 日志</span></span><br></pre></td></tr></table></figure>
<p>配置实体类的别名扫描包：（一般都会默认配好）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure>
<p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD，因此自定义的Mapper只要实现了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.sky.entity.User;</span><br><span class="line"><span class="comment">// 泛型中的User就是与数据库对应的实体对象PO.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VoucherMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</p>
<ul>
<li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li>
<li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li>
<li>MybatisPlus会把名为id的字段作为主键</li>
</ul>
<p>至此我们已经配置好MP：1.引入pom文件，配置xml信息 2.实现BaseMapper</p>
<h2 id="基本的增删改查crud">基本的增删改查CRUD</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">void method ()&#123;</span><br><span class="line">	 userMapper.insert(user);</span><br><span class="line">	 User user = userMapper.selectById(5L);</span><br><span class="line">	 List&lt;User&gt; users = userMapper.selectBatchIds(List.of(1L, 2L, 3L, 4L, 5L));</span><br><span class="line">	 userMapper.updateById(user);</span><br><span class="line">	 userMapper.deleteById(5L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常见注解：</strong></p>
<p><code>@TableName</code>：用在实体类上，数据库注解，标识实体类对应的数据库表</p>
<p>属性：value（表名）、schema（schema如sky-take-out(.表)）</p>
<p><code>@TableId</code>：用在实体类的主键字段，主键注解，标识实体类中的主键字段、</p>
<p>属性：value（表名）和type（主键类型）</p>
<p><code>@TableField</code>：普通字段注解，一般不用</p>
<h2 id="核心用法">核心用法</h2>
<h3 id="where条件">Where条件</h3>
<p>因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件，参数中的<code>Wrapper</code>就是条件构造的抽象类</p>
<p>即<code>wrapper</code>是用来实现where条件的</p>
<p>一般常用的有四种：</p>
<p><strong>QueryWrapper</strong>：修改、删除、查询，都可以使用QueryWrapper来构建查询条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">        .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2.查询数据</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<p><strong>UpdateWrapper</strong>：SET的赋值结果是基于字段现有值的，需要利用UpdateWrapper的setSql功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line">        <span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前两种Wrapper写死了构造条件的字段值，下面利用Lambda的Wrapper更为常用（基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了）</p>
<p><strong>LambdaQueryWrapper/LambdaUpdateWrapper</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>) <span class="comment">//利用这种方式获取数据库的信息，后面的是传入的参数信息</span></span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义sql">自定义SQL</h3>
<p>在上面的测试案例中，SQL语句写在了Service层，是不可以的，现在要写到Mapper，自定义SQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在UserMapper中自定义SQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 下面的$&#123;ew.customSqlSegment&#125;是固定写法</span></span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UPDATE user SET balance = balance - #&#123;money&#125;</code>：更新
<code>user</code> 表中的 <code>balance</code>
字段，扣除指定金额，<code>#&#123;money&#125;</code> 是一个 MyBatis
的占位符，表示将方法参数 <code>money</code>
的值传入。而<code>$&#123;ew.customSqlSegment&#125;</code>则表示将
<code>QueryWrapper&lt;User&gt;</code> 类型的参数 <code>ew</code> 中的
<code>customSqlSegment</code> 内容插入到 SQL
语句中。<code>customSqlSegment</code> 是 <code>QueryWrapper</code>
对象中一个特殊的属性，它允许我们在查询条件中动态地插入额外的 SQL
片段（例如 <code>WHERE</code>
子句）。利用${}而不是#{}，因为#{}是参数替换，${}是字符串拼接</p>
<p><code>QueryWrapper&lt;User&gt;</code> 中的泛型是 <code>User</code>，
<code>QueryWrapper</code> 基于User实体类构建 <code>User</code> 表的 SQL
条件</p>
<p>MyBatisPlus不支持多表查询，我们可以利用Wrapper<strong>中自定义条件</strong>结合自定义SQL来实现多表查询的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在UserMapper中自定义方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="service接口">Service接口</h2>
<h3 id="基本用法">基本用法</h3>
<p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法</p>
<p><code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法</p>
<p>自定义IUserService接口继承IService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，编写<code>UserServiceImpl</code>类，继承<code>ServiceImpl</code>，实现<code>UserService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceImpl</code> 是 MyBatis-Plus
提供的一个基类，它是一个通用的服务类实现，封装了很多常见的 CRUD
操作。<code>ServiceImpl</code> 实现了 <code>IService</code>
接口，并且提供了 <code>IService</code> 中定义的方法的默认实现</p>
<p>有了Service接口，可以直接在Controller中操作到数据库</p>
<p>编写Controller层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> UserFormDTO userFormDTO)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.转换DTO为PO</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.copyProperties(userFormDTO, User.class);</span><br><span class="line">        <span class="comment">// 2.新增</span></span><br><span class="line">        userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">        userService.removeById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">        <span class="comment">// 2.处理vo</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUserByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">        <span class="comment">// 2.处理vo</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@RequiredArgsConstructor</code> 是 <strong>Lombok</strong>
提供的一个注解，它会自动生成一个构造函数，该构造函数包含所有
<strong><code>final</code></strong> 或
<strong><code>@NonNull</code></strong>
注解标注的字段。代码中的作用是自动为 <code>userService</code>
字段生成一个构造函数，以便在类初始化时注入依赖。（<code>@RequiredArgsConstructor</code>，不需要手动写构造函数，只需要标注
<code>final</code>
字段，它会自动完成依赖注入的工作，就不用@Autowired了）</p>
<p>上面的例子非常方便的实现了在Controller层的简单CRUD，但是业务逻辑代码就需要在Service层再写了</p>
<p>如：根据id扣减用户余额</p>
<p>需要先判断用户状态，然后判断余额，最后扣减</p>
<p>首先在UserController中定义一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;扣减用户余额&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@PathVariable(&quot;money&quot;)</span>Integer money)</span>&#123;</span><br><span class="line">    userService.deductBalance(id, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是UserService接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是UserServiceImpl实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 2.判断用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断用户余额</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.扣减余额 baseMapper是父接口</span></span><br><span class="line">        baseMapper.deductMoneyById(id, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是mapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deductMoneyById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;money&quot;)</span> Integer money)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="lambda功能简化">Lambda功能简化</h3>
<p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</p>
<p>接下来我们在UserController中定义一个controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组织查询条件的时候，我们加入了 <code>username != null</code>
这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<code>&lt;if&gt;</code>标签。这样就实现了动态查询条件效果了</p>
<p>进一步地，Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code></p>
<p>基于Lambda查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：</p>
<ul>
<li><code>.one()</code>：最多1个结果</li>
<li><code>.list()</code>：返回集合结果</li>
<li><code>.count()</code>：返回计数结果</li>
</ul>
<p><strong>同理：IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务</strong></p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是存在ABA问题：ABA 问题通常指的是在并发环境中，某个值在某个时刻从 A
变成了 B，然后又变回
A，外部系统无法检测到这个值曾经经历过变化，但实际上它已经发生了变化。这个问题常见于基于版本号或时间戳的乐观锁机制中。例如，乐观锁使用的是
<code>eq(User::getBalance, user.getBalance())</code>，这意味着在更新余额时，系统会校验当前数据库中的余额是否与用户获取的余额相同。如果中间有其他线程修改了余额，但最终余额恢复到原值，则当前线程会错误地认为数据没有变化，导致错误的更新操作，所以用<strong>version比较好</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lambdaUpdate()</span><br><span class="line">    .set(User::getBalance, remainBalance)</span><br><span class="line">    .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>)</span><br><span class="line">    .eq(User::getId, id)</span><br><span class="line">    .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">    .eq(User::getVersion, user.getVersion()) <span class="comment">// 校验版本号</span></span><br><span class="line">    .update();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="iservice中的批量新增功能">IService中的批量新增功能</h3>
<p>我们尝试逐条插入数据，发现时间非常慢，后调用mp的批量插入，发现效率也不高：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    userService.save(buildUser(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    list.add(buildUser(i));</span><br><span class="line">    <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        userService.saveBatch(list);</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看MP部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure>
<p>为了提高性能，我们希望插入语句是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:即开启重写批处理的<code>statement</code>语句</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure>
<p>可以大大提高效率啦~</p>
<h2 id="其他功能">其他功能</h2>
<p><code>MyBatisPlus</code>插件：直接配置数据库，然后code
generator即可</p>
<p>Service之间相互调用可能会出现循环依赖问题（在插入订单Service中，还需要调用插入订单详情的Service，maybe死锁，互相等待对方注入），MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能。</p>
<p>改造原本的UserVO：新增地址属性，List列表类型为AddressVO</p>
<p><code>@ApiModelProperty("收货地址列表")</code></p>
<p><code>private List&lt;AddressV0&gt;addresses:</code>首先在IUserService中定义方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line"></span><br><span class="line">    UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在UserServiceImpl中实现该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询收货地址</span></span><br><span class="line">    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)</span><br><span class="line">            .eq(Address::getUserId, userId)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));</span><br><span class="line">    <span class="keyword">return</span> userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p>
<h2 id="分页查询">分页查询</h2>
<p>在config中添加配置类</p>
<p>其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正查询代码</span></span><br><span class="line"> <span class="comment">//  1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="五rabbitmq学习总结">五、RabbitMQ学习总结</h1>
<h2 id="rabbitmq基础知识学习">5.1 RabbitMQ基础知识学习</h2>
<h3 id="rabbitmq-配置定义交换机队列和路由键">1. <strong>RabbitMQ
配置：定义交换机、队列和路由键</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;voucher_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="string">&quot;voucher_order_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义路由</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;voucher.order&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE).build(); <span class="comment">//队列持久化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换机exchange">1.1 交换机（Exchange）</h4>
<ul>
<li><strong>Exchange</strong> 是 <code>RabbitMQ</code>
中的一个核心概念，负责接收生产者发送的消息，并根据路由规则将消息分发到不同的队列。</li>
<li>这里定义了一个名为 <code>voucher_exchange</code> 的 <strong>direct
exchange</strong>，它将根据路由键将消息定向到具体的队列。</li>
<li>使用 <code>durable(true)</code> 表示交换机是持久化的，意味着即使
RabbitMQ 重启，交换机也不会丢失。</li>
</ul>
<h4 id="队列queue">1.2 队列（Queue）</h4>
<ul>
<li><strong>Queue</strong>
是消息的存储容器，消费者会从队列中获取消息进行处理。</li>
<li>这里定义了一个名为 <code>voucher_order_queue</code> 的队列，并且通过
<code>durable(true)</code>
设置队列持久化，确保消息在队列重启后不会丢失。</li>
</ul>
<h4 id="路由routing-key和绑定binding">1.3 路由（Routing
Key）和绑定（Binding）</h4>
<ul>
<li><strong>Routing Key</strong>
是一种路由机制，用于决定消息应发送到哪个队列。<code>voucher.order</code>
是一个简单的字符串，用来与交换机的绑定进行匹配。</li>
<li><strong>Binding</strong>
将交换机和队列通过路由键绑定起来。<code>BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs()</code>
表示将 <code>voucher_order_queue</code> 队列与
<code>voucher_exchange</code> 交换机通过路由键
<code>voucher.order</code> 进行绑定。</li>
</ul>
<h2 id="mq实现消息队列">5.2 MQ实现消息队列</h2>
<h3 id="rabbitmq-配置定义交换机队列和路由键-1">1. <strong>RabbitMQ
配置：定义交换机、队列和路由键</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;voucher_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="string">&quot;voucher_order_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义路由</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;voucher.order&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE).build(); <span class="comment">//队列持久化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交换机exchange-1">1.1 交换机（Exchange）</h3>
<ul>
<li><strong>Exchange</strong> 是 <code>RabbitMQ</code>
中的一个核心概念，负责接收生产者发送的消息，并根据路由规则将消息分发到不同的队列。</li>
<li>这里定义了一个名为 <code>voucher_exchange</code> 的 <strong>direct
exchange</strong>，它将根据路由键将消息定向到具体的队列。</li>
<li>使用 <code>durable(true)</code> 表示交换机是持久化的，意味着即使
RabbitMQ 重启，交换机也不会丢失。</li>
</ul>
<h3 id="队列queue-1">1.2 队列（Queue）</h3>
<ul>
<li><strong>Queue</strong>
是消息的存储容器，消费者会从队列中获取消息进行处理。</li>
<li>这里定义了一个名为 <code>voucher_order_queue</code> 的队列，并且通过
<code>durable(true)</code>
设置队列持久化，确保消息在队列重启后不会丢失。</li>
</ul>
<h3 id="路由routing-key和绑定binding-1">1.3 路由（Routing
Key）和绑定（Binding）</h3>
<ul>
<li><strong>Routing Key</strong>
是一种路由机制，用于决定消息应发送到哪个队列。<code>voucher.order</code>
是一个简单的字符串，用来与交换机的绑定进行匹配。</li>
<li><strong>Binding</strong>
将交换机和队列通过路由键绑定起来。<code>BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs()</code>
表示将 <code>voucher_order_queue</code> 队列与
<code>voucher_exchange</code> 交换机通过路由键
<code>voucher.order</code> 进行绑定。</li>
</ul>
<p>在 <code>RabbitMQ</code>
中，<strong>消息的路由</strong>是由交换机（Exchange）和路由键（Routing
Key）来控制的，发送者并不需要直接指定消息发送到具体的队列，而是通过交换机将消息发送到队列，当消息发送到
<code>voucher_exchange</code>
交换机时，交换机会根据绑定的路由规则将消息分发到相应的队列即配置类中的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>voucher_order_queue</code> 队列绑定到
<code>voucher_exchange</code> 交换机，并使用路由键
<code>voucher.order</code></p>
<p>此外，<strong>RabbitMQ</strong>
允许将同一条消息发送到多个队列，这是通过交换机的绑定关系来实现的，即创建两个<code>queue</code>，两个<code>binding</code>即可，如果不关心路由键，而是想把消息广播到多个队列，可以使用
<code>fanout</code> 类型的交换机;<code>fanout</code>
交换机会将所有消息广播到绑定到该交换机的所有队列，无论路由键是什么。</p>
<h3 id="发送消息到-rabbitmq">2. <strong>发送消息到
RabbitMQ</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> Result <span class="title function_">purchase</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1010108L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;同一用户不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建订单对象</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> VoucherOrder.builder().userId(userId).voucherId(voucherId).id(orderId).build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送消息到 RabbitMQ 队列</span></span><br><span class="line">    amqpTemplate.convertAndSend(RabbitMqConfig.EXCHANGE, RabbitMqConfig.ROUTING_KEY, voucherOrder);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;下单成功，订单号：&quot;</span> + orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.1 消息发送 </strong></p>
<ul>
<li>代码中通过 <code>amqpTemplate.convertAndSend()</code>
发送消息。<code>amqpTemplate</code> 是 Spring
提供的消息发送模板，它可以简化与 RabbitMQ 的交互。</li>
<li><strong><code>convertAndSend</code></strong>
方法将消息发送到指定的交换机、路由键和消息体。这里发送的是一个
<code>voucherOrder</code> 对象，表示用户下单的请求。</li>
<li><code>RabbitMqConfig.EXCHANGE</code>：交换机的名称，确保消息发送到正确的交换机。</li>
<li><code>RabbitMqConfig.ROUTING_KEY</code>：路由键，用于确定消息应该被路由到哪个队列。</li>
<li>消息体是 <code>voucherOrder</code> 对象，它封装了用户 ID、优惠券 ID
和订单 ID。</li>
</ul>
<h3 id="消费消息并处理订单">3. <strong>消费消息并处理订单</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@RabbitListener(queues = RabbitMqConfig.QUEUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(VoucherOrder voucherOrder, Channel channel, Message message)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理订单逻辑，创建订单并扣减库存</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建锁对象，防止重复下单</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order&quot;</span> + userId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 锁获取失败直接确认，不需要重新入队</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询订单是否已经存在</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> voucherOrderService.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建订单</span></span><br><span class="line">            voucherOrderService.save(voucherOrder);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;处理订单失败&quot;</span>, e);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 异常时，发送 nack，重新入队重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;确认消息失败&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.1 消费者（Consumer）</strong></p>
<ul>
<li><code>@RabbitListener</code>
注解用于声明该方法是一个消息监听器，它会自动从指定的队列（<code>voucher_order_queue</code>）接收消息。消费者监听该队列并处理队列中的消息。</li>
</ul>
<p><strong>3.2 锁机制</strong></p>
<ul>
<li>使用 Redisson 分布式锁 (<code>RLock</code>)
防止同一用户重复下单。当获取到锁时，处理业务逻辑；如果获取锁失败（表示当前请求正在被其他线程处理），则直接返回，并且确认消息（<code>channel.basicAck()</code>），确保该消息不再被消费。</li>
</ul>
<p><strong>3.3 消息确认（Acknowledgment）</strong></p>
<ul>
<li><code>channel.basicAck()</code>：手动确认消息。当消息成功处理时（比如订单创建成功），通过
<code>basicAck</code> 确认消息已处理，RabbitMQ 会将其从队列中移除。</li>
<li><code>channel.basicNack()</code>：如果处理失败（比如扣减库存失败，或者发生异常），使用
<code>basicNack</code>
将消息重新入队，以便重试。<code>requeue=true</code>
表示消息重新进入队列，待下次消费。</li>
</ul>
<p><strong>3.4 异常处理</strong></p>
<ul>
<li>如果在处理订单的过程中发生异常，<code>basicNack</code>
会重新将消息放回队列，并且设置
<code>requeue=true</code>，使得消息可以重新被消费。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/%E4%BA%92%E6%96%A5%E9%94%81/" rel="tag"># 互斥锁</a>
              <a href="/tags/%E7%A7%92%E6%9D%80/" rel="tag"># 秒杀</a>
              <a href="/tags/mybatisplus/" rel="tag"># mybatisplus</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/12/17/%E6%98%9F%E9%A3%9F%E9%93%BE%E2%80%94%E2%80%94Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="prev" title="星食链——Java学习总结">
      <i class="fa fa-chevron-left"></i> 星食链——Java学习总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/17/%E5%9F%BA%E6%9C%AC%E4%B8%9A%E5%8A%A1%E2%80%94%E2%80%94cq%E5%A4%96%E5%8D%96/" rel="next" title="基本业务——cq外卖">
      基本业务——cq外卖 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1note%E9%87%8D%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">一、秒杀业务note重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#i-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="nav-number">1.1.</span> <span class="nav-text">I 短信登录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E6%9B%BF%E6%8D%A2session%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82%E5%92%8C%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1
Redis替换Session的具体细节和操作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 状态登录刷新解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ii-%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">II 商户查询缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 缓存更新策略、双写一致</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">解决一致性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">双写一致方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 缓存穿透问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1%E8%A7%A3%E5%86%B3"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">缓存空对象解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 缓存击穿问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">逻辑过期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 缓存雪崩问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85redis%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 封装Redis工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iii-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="nav-number">1.3.</span> <span class="nav-text">III 优惠券秒杀</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 全局唯一ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 秒杀下单超卖问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">乐观锁解决超卖问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E5%8A%A0%E9%94%81"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3
优惠券秒杀——一人一单问题——逐步加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 分布式集群环境的并发问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81simplelock%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5
分布式锁——simpleLock(自己实现)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">3.5.1 核心思路与基本实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3.5.2 误删问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98lua%E8%84%9A%E6%9C%AC"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">3.5.3 原子性问题——Lua脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 分布式锁——redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redisson%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">3.6.1 Redisson介绍与应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reddisson%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8F%AF%E9%87%8D%E8%AF%95%E8%B6%85%E6%97%B6%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">3.6.2
Reddisson可重入、可重试、超时释放原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutilock%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">3.6.3 MutiLock应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93redis%E8%A7%A3%E5%86%B3%E5%9B%9B%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">小结：Redis解决四个问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iv-%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">IV 秒杀优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 异步秒杀</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1 思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%A0%BC%E5%88%A4%E6%96%AD"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2 Redis实现资格判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 Redis消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1 消息队列三种类型介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Estream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2 基于Stream的消息队列实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E6%96%B0%E5%A2%9E%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%86%E5%A4%87"><span class="nav-number">2.</span> <span class="nav-text">二、新增业务数据库准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.1.</span> <span class="nav-text">接口设计和实体类设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">2.2.</span> <span class="nav-text">代码框架与实现思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E6%80%BB%E7%BB%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">秒杀总结流程图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84qa"><span class="nav-number">3.</span> <span class="nav-text">三、实现过程中遇到的Q&amp;A</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9Bmybatis-plus%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">四、Mybatis-plus学习总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5crud"><span class="nav-number">4.1.</span> <span class="nav-text">基本的增删改查CRUD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%94%A8%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">核心用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#where%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.2.1.</span> <span class="nav-text">Where条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89sql"><span class="nav-number">4.2.2.</span> <span class="nav-text">自定义SQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#service%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.</span> <span class="nav-text">Service接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E5%8A%9F%E8%83%BD%E7%AE%80%E5%8C%96"><span class="nav-number">4.3.2.</span> <span class="nav-text">Lambda功能简化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iservice%E4%B8%AD%E7%9A%84%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD"><span class="nav-number">4.3.3.</span> <span class="nav-text">IService中的批量新增功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="nav-number">4.4.</span> <span class="nav-text">其他功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.5.</span> <span class="nav-text">分页查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94rabbitmq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">五、RabbitMQ学习总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rabbitmq%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 RabbitMQ基础知识学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rabbitmq-%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%98%9F%E5%88%97%E5%92%8C%E8%B7%AF%E7%94%B1%E9%94%AE"><span class="nav-number">5.1.1.</span> <span class="nav-text">1. RabbitMQ
配置：定义交换机、队列和路由键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BAexchange"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">1.1 交换机（Exchange）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97queue"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">1.2 队列（Queue）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1routing-key%E5%92%8C%E7%BB%91%E5%AE%9Abinding"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">1.3 路由（Routing
Key）和绑定（Binding）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mq%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 MQ实现消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rabbitmq-%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%98%9F%E5%88%97%E5%92%8C%E8%B7%AF%E7%94%B1%E9%94%AE-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">1. RabbitMQ
配置：定义交换机、队列和路由键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BAexchange-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">1.1 交换机（Exchange）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97queue-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">1.2 队列（Queue）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1routing-key%E5%92%8C%E7%BB%91%E5%AE%9Abinding-1"><span class="nav-number">5.2.4.</span> <span class="nav-text">1.3 路由（Routing
Key）和绑定（Binding）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0-rabbitmq"><span class="nav-number">5.2.5.</span> <span class="nav-text">2. 发送消息到
RabbitMQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E5%B9%B6%E5%A4%84%E7%90%86%E8%AE%A2%E5%8D%95"><span class="nav-number">5.2.6.</span> <span class="nav-text">3. 消费消息并处理订单</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NING565"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">NING565</p>
  <div class="site-description" itemprop="description">记录下学习与生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NING565</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
        访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">
        访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/sjn/anime.min.js"></script>
  <script src="/sjn/velocity/velocity.min.js"></script>
  <script src="/sjn/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/js/markmap.js"></script></body>
</html>
