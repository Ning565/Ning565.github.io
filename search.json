[{"title":"Day0","url":"/2024/03/15/Day0/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"密码错误，请重试\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"96a51d94d3c6e254116d82d98bc48706a5452b4a8ea7e40868b50c8098f75478\">6a4b093bf02c6c1ac2e1303d775d4753d052aee6cface0269d992c8cbccbb4f98acc4892b4c037af92801e6696646fa603062b4ca7e42b7d62c0b24d56735e4ac0353a8615ef066e93d887d760a858534beeafdd689e45209e46bf2fc7dd80958f155f51b49ee7c52f186b7f47d575e4f322be821969aed13caaeaae5a50f16de806eed2d50abca5f39fbe4c7feb49f6cc05f45120c03041cd442b0ad2e3504e90d0d897295ff11da7741819afce957ab1da20f0fc9d7e508ca987e8440e57aefd8105efb6656608f2f8be718bc7ed2135c380d7f21cd61f2271cac17568501d3ba8d0e07c46351e8d935bf6d44a6da9b4fb2aaeeaa837ce6776d86b7ede85c27d4b4abb6f85386966811d1e8a93a2021d0af8f43b98545ef410d2ba9d216e347ee15c5dcd41770395141d502ce4d3577b54a7f96121ae3f6407b4f812ee31b1bb936384226fa263c805166ba73b554f4df2a71fe9ec356c2c3013487552ff8d47293babead832ca8c812eda8e94dcfd5154b858b314558b1bb163d10a8cdc6100e903ab406c41431cdcbbc51046871a2398c9e39b5cb71977952506b5175a15275182a1d080b0fa7fce7316469296cdc7b99241a3cd981b34ffb488ab6ee3674684b5773bb86b07e64f0dded7d1ccc21a94af4b2bc568aed06e80888721ac9b43ac9593b9e4cf45f9fd918ad422aa872a0f98088d59984355416b756bd5770aa815171cf0bd1e72766a13387b0270da207716a31b04505a2d31d3346f3d2ea6124d391a7e896bde96b29a22bbad2f6d91a4027660bd7d8d06a44c7b832ed1533a9be281d35f5b5d0b22adfec3ecab15e99a5b288059374a1e90bae5973ddc71bef442066479b01e1db2b1dbe4538a8fc282026474d1894d284ddec2b3fff1cc3bfd61b528ba9d9f8e280d6b1fa5c37467b092a2b0f354be3908cfe91ba367803ff9f6fd76b9003d45541a1a3a469230ef06d9d0399969812e95bf374494e18835ada88789016526d75fb4cb7a3923978f439cbdfa8597fd0b0fa48ddcac95eebd6643acf7ad75582d6fa8467348be7a707f9cd5d16aeaa7094c3a7d8da78532d86f84445c6a5617e9618a1b0a10193ccc48e8fd104dd9bc372966fd6dd80d038485fab0e27ce1dd2d6953195c74e48c5f42d284b5083e270fe79720f925b6a64ae95c448b4a9d1483749887545f6d0aeea6c5fbc68a253d9e98d73d2f436971521d6587ee11f8473f71e58d4cc7689fba2cd0726f37c7eb193a083b423306fa72ca765d14c4b7a770a8f7d224090cbf41412fb5bda13cc18957f881afbb9b2b25baa7f0253a361b096e33858b3502357855b575657d7ea63813929813d1d8ff7659c63f125366c413f954fc969c30048e299ec10cd1afa38f21c8e0e2f2c14e78169f1e1cb5fa7396f2d1b363521e0b8c3c76c4dc4712ceb5651fc7e25cd104e7515aba907a6d9cefeba2664c944c50e25a60bb160059b5af841841e5911a68559dd439bba09c879ddfac45d08b9d34c0763f4d4dc078b549ac7663f93dbe35833ae40e4c8519c5cb7c560bfb2ddf644559963481170b71be5259ecc3a013e1f9004f1bda6eab8f6826b40a63b001c231901f871a55e2a476e515b78f132f365bcef2447ae5fd2793b20e923bbd83c36f224ad5bc8455b3ce96a27fc4409bd82667905e1193b525e38a0f6df308016619ee9d171e2a1363d866a1189585789abf984c417b7f293a47296c91da876610594dd6cc02106264febba13de02bd9bfcabf40e2298700162077229692d6db0ba0ba49e06b02e737bde84e603da23ee2df2aa853db7d28780ed25dfe10198f0c051baad56aff9af5e457d2536117dfc3d02825d706a763af66e2fe431f21a76e1b88328bcff3bc1b0870d310731b34a34c87d5da9dac9cfb047f582851878fd7b0ba0338910dd85384f61725701f4e7b52ca881b9b5ce868e4e321e67f9d37de9ff97111576e2735d24bf12536616beddb57cdfa7e378c1c5a3bac8467a4e68598f218ee638de94db1309c7945f9383c18da805e822344a2a2c5928985e2cae3bd56e12a6c9bb9868df96f6ddf0200bc7c469844ec728f779a59e7631900ac5331643b8fa9bac2869b9449fcb5091b49dc7c505ae61434cab6cc634de2d4d0e0234d8233dfa8f2297c3dd86bcb0c7d51ba360445768fbf7e59831af5e3f3c989d0f8830f098d3a8661e2dc58a5c5532b98f0bdecc3f8bb5c447b3d7ce287bef4a02365bc0c20a29c6e876b835c8e8ed3372a6fc00c757f4c8f3def234bb559542c5892357f74b432a351e10788c6437b26427c6a0424738f012367f4a3cdabb1eb638c567805f1886269d8c577476010e38f530a8cca5b9445b629881d36b42a888fd6b25010ffff61c5e3ff4941b26e58fc2e3c59997725e2320673a762c82021c87090652bec3cba052c257d0ab270a702308d2459e77b34118c6a3fc761ec2c99e48db713c965212f5aa7ffd610ee87e61881a42e6186156d7311fd0545ad1eb0ce13f01536175b9dadc8be173586a38ab4c3bb5399d3b2e68fbf0720930778c29824a4111ed2478f55dd443fc47b5ae1869d3ed5633e3a9eb5d071c8bb7619d249f3758fa35a8bf0ed54da2e3018d40553b3679467bac67cf9bf34a36315dac000effd5caa622d620c28cd02a9faf30f806078fe3d1bdf152a10ac65309a3fdc5f1e2d95eec0e0ff2ef0030c76d81865bedb94e59ce8c73d380fbf71d561c76a056335e398221981d50134639a38c31e5921414b935a8f33bc0ca1333e40713c5ace4299b41f0f10b0afdae0e92e7cd3a295c84d2cf56fb41eefb34295e2aaab7d72a282f59521c23da094adeaaacda3a9536b21f87d1d98404e592add447d93094df96de0c405bc6be764e4288dfe0b2092360680ec97f68fb7d9c3d1a755ac63f93ab736db245b0d70b3038267c3c88e651e367b5d3ccb6cbd353c022038708cdc094a29a572e80e097ce6caf1ae91f0f789d7911001c79d280531364b3a6f95e0fa7dfafa368ca633cb7b245176661232001d589f9b04e8587df7ce3e22bf5704378bf48670fcbcc3831228f5428d57b3a15ec6a0eaa6d01872f149c0d88228339e2cc814e4542ce5c4ddd35c59cf8223fbd5f0fb861543c42706740194d118fab969514e4fb33c233a10af222c36b33eb5474571821a5e97336fb1549976ddeb0d01f48187c675a7bc6d2b5fdadbeb8344de3360051a810d60a60ea4b51cc256d92f082238859b9ea4968a560a1d82f7c87c1a25a7103c19f610c64cfb6714ad3e488d77e0d647fbd5e4111b4dcd61fb7204e9254a518ce24d535fd7289e61bdb6eb8ff0ca2b1c9b8247a7d4333361eaac02a0cfe4a9ee049127b652cbf451c4f45b11f696686550d198073c19453cf61898408bb4a8e8bbbb25577d89be80800535f5d099c746986ef972ae7844d035329a424e08002647ec626da7d4382c6250c83fb9a26d103a1facf9d0f3eac9e9ac1d3de9ef31ae78385d37ecd6577a39b55256e8afd3895ddca46b047caeadea19463a102f4b4bea174be9dd38efedfbfc908f49eac6ecdbdeec470ba7d0ccac320e14ac0f5f8aeac95ce27c8e5bc51412452e6c12226712c27c76afb07874465cba75e3a55cc72bd14a7d03a9770090eed3f7477160f588b0d1781c4461b7d039432f3c89d53d3ccc5b8c178dfbba85609de4b5dc3ed4165efed79a1760bba43d6c2b504579f1d79698905bad63053915d04853638e0389de3dc0c6006fadd84294e5da0a0b4a8b7daa168a46dda78190c4c48a67d6f52b71c7b113b13eb986ecbf7896c51ef1eddb46bc4daa99a85ffba58bd92363e52a40accf4fb268c9af8954ab9a55416c8f67f7eb1bb973d02416c8100213c491f981acd66c59aa54debe709aa5074f5f03c42318afe2abb93e4a4f079505ab795d8817627c7a82b804f88400ebc5d524ab8cb651d27e4cb8dbd666a4238270c5cdae0df88bc27be6032ddf4f9d25257f2c9062ed0f81e83fdb7dcd26bff890441d517bebacea7729ce61b60f605c9d499cb9b14b6fa2be6a37a1c71d9a64e32c58544571d45a7c651b92dda818053c93ae4f3ae6020142400349853803cafda2b72bd17a27e603b7b301ee794c1e50581986dfc14e8d2defddafb801663f939d52c0eb9a1a1ba16127b51010ab9f42e58f2b4d082973c73af4e5b2268f65d4f64dd36a682a0b8fc7a3784aabe9185d608ce46d8f9ff35c5331cb90a5f960047692006ba62e7855b225c0d2e05e55926ca68fc85cde70c9a27ad3e5cbfe371582626c2100bcdf9dd7d077c82dbad60e95c80f123fc9f7010ff18095bcd1fdc1db7b20ad3ea796346e6efc1f15681bca89b75b73d506a990e0f1d38cb71b3b014644f892fa66de04e947d486fc061132ca2576221794cea8cbc8fcef483ddd0332dcdb2aaa977e610d07dda02e4e4489935acf01518ae155c09514a2d1f0b8d249965e21920fb9490d416cd8c659734f228b5ff56402c013fbd8ce677be1e206ad6855d1f2e90ad28bc351f4a05712e1ae2c4012deb343e637359405ffba9aacc257532ce0966a3045bd918d6769fcce6e8f0c2ae3849343b77abb4fbe3f75386af1d415106cf25b1b0ef4ade751b66190802066cbbc69363f31f544c813a901cf0822e899fdee4c57c7b7c93a17f20790a0b956a45dc72b94b44a8695dfaa5723bce0b8a4fd625ca7471dfcb3f6245f641ea3ed0202020d883602fd621bc3e6a1a8ebb57b60b11ea64a164e2be7baa869461746a0f9260d03cb4a0c0d2df2a0e8a30984c7520190762db66df5ab8dbd1388686dd628ddd4f48d4efb6870a4401aabdef27ac0c5fff039dd7e0d395e3bb36063b65f79edeab5ddb0314d9ee3a40de4f6ae7ee3db39e830366ada21f2cbc529f073f508b8d392eb1064fea5e8ae6f633a58cfb798ae52dfe37b9446b932cb034460a43721627b87c5a596388a6dc2036434f46445bc40b66d62f10b314ae5c901cc2f86da79e7712b719b857b5745a39cf77ddc1cc1ae6c5f23a545fa10a10bb337d03d391eef4e8d460d573e6bd6093e5322556d0ad94dc68e94197b15b3d6db23417019e47fd63d007c735034ed151a9ff627e270322ce7c7333bf2bd1a7c3b3712cbe6f4a70c7987cfdd4c9a6512f3c20ba43378381159198f7e2058d55743d11b7a9705334538a13103fac78135bfa1db54faa7f80ec4be419df0daffec7f15aca6ecf47d3e553d2e2949f8d9b4c1666b6372d95f0f16c0099e9558b80c2b6666a8942c220c7cca9c9f0ca071ce19699c046a2b1ec3d057336f3483e76a7fd8f553d7a9d57b30eb6ed149e550b251342c3b7d2bf16ad7e48b724b2442e5e980ac9089daca7ad85a8090245fe4bf6b7c334d6b823eccfbf49fe25b4f1cf23fa788a44391ee10cc2de9f27b02bc46c0dc6b50a604931e1edb2308148b5c9f7d295e9d27c6275835ae24acb4cf72a78298975cbd1155a4210c1af5f96b993c666cecfd82837c3b05628558c3ed9308afca1a779099ec227d34cf7b8e4a16781a9dcdf76013f86c1fc9c704fa7750c87d4f201bdc2bf9d906ff06a941b80e6de90dbc223434f8e34f60b4ef5e1a12b4175af5bee8aac9fbbd9328846c6372152c75b87813cc948c934bd316b2355d0243e567ce1aa5a7cfc7492fc0e159220b727f5ad8c895fd3ca805a448f93dcfd4279152a8c51484afbe515c8719763c9edf4d9d8b6ce850d5e36dac284de6370dfa00c6d911a334ce52bac212878e0bd436393cd63d35ca25beaf9384b4def07ff5d7b5d1603f57c1e0aa99ef4d0f286e575549aff8e56829ce70dbb3a341e3b8b05e362c07645cf2daf4255757eba6cde57b13e060136058cda757ffd28a07059fb2645daa42c4f7cbb9fdf53a8b67de00014184169b7da517115c8a7bc29a089fbeff37f8e7efeea98c0d9ee6fa4b92f74fa3a491b68c19e91281957867a5fce597337ea4aab55580fc997261e5eec24586992337a12136cecdab701fa4b44fea7c7e3680b3115cbddc64acc7a2a685372e2583c181e8fef853f445db8c6969faf18e569db55f8fe570fad77fa740fa33917007b3382c2ffadb8f148fec5059ebaac1e92666bcc3992cb9c85db72d7305befcd847b2f5d84a3073270b243bd0b529c03d783666bc0bb574622f9534709b50b9fac399c9240cf239c179c77a984ffd16bb3166fee8a2637391b798d4e5a4c2ecda5c642a6596b9211fb73c018741d4f0054b3e0b175b9f1872c60186466977e200738db1a4b38e35d6648fc397794c2d874832968fc2a22477ef93e0aa97f8c5dd61bde8c89d278e11d6103976dbd07587450be7eee800fab6b9baba839ae4e5025422468ec6eece4d0f28eef7608219de5258a11bcde1d2a570c985298f2f6e14676c73a28b68ca0ccdf1c3a4438acda2a80bb81516275adde6875d7eae280413b71a82e3821000580214646ec5ca38709e79e7cd1fa75b7f3add2eea6af72d498f5598354c90b3518d2405b37be4f6eae0567a68ddda30653dada22a83076f82102a49648e092474cb2390fc5d37c53fd46e172e5b94e50edc485d4e95f06bc55664bddcf1d186ed135c03a21f7042b5a6583974f5e1bf08425acd7025c9a1a7e0c93db6bd94791726ed6c642469eb7df94c263a492d1f28e0805d828d044ce521a8aa3ab2314d1eb0d22587b9be0357c1d6aeda3a1c26f9de92b282d18c856e802588d3a2901c8445aed19e8dccbe4c1f1047dc7664db5e1f643318c07b528dbb03a47c43bd9f6f6fd2876b2faaddac821dd504e40832be4965af6856496c023fb3256bfbf666a2d808fcbfb9a30fd9fd84bbb87812ac70b7611fce0985e36b13b5bef2d68c3e27b1a2e419beaf702cdd0b20a7f93bd58da00d49a317233d35b0ce26db5a3de9b68a890b1d3469d47cb461626b6ef9932c18bf2d80ba1553e2ff7b7ac8dd872db26e1b0e2d7bc066fc1a5398d93b0259fa27a98ddb27727f1710704c03c5649d707ae9f99ddf90ea920672888af8481e72c41fac72bc4f5a3c6dafc5ba3ff778a5bdb1e6af2be96e2bcc6d05d30db18302117fe8716e720e4661871d90aa70cc288a5c02264faff1138ec07c2d4497ca24ff6266bb397738b95c3b3530ac97958d1d242014618728f100610ff2dda6d1ef68b88dfd9b5d9c77d8ed740d3af814a94808967ea1661bdc546d3266dc882e9d0be0bec8b849b25d8455400f8548c7167c05cbffdeaf325ef97324acaf60edac5a89577db6063fa7844133af286f76563d79f2cb7d8b6904072b0e9553d8b84679c7071ef6921d5361d44649cc736c4efccdf5d17d6f46408f9b0a28be56d3ee6041b93b613068e546d37b4ee6392139c5f4c9056a7f43cb10b33a6a6ac8d8e5483cf6b8e62ce0fd45e457fe9c0de35f68e558b9d74b8cd7d70e6f8b3ec4a1bfe6ccf0b9cf42002148f61c290dbb4054180a2ffe1a8196430d865343689c00c5ccd4bbeb7557efb2ee55710a8208033bf71d6b69e5e52448abfa438a9a3f77ae3cf8511af4d50267976855dce2ee1b8460e05a5e6444399663d1c5656e3ce0a11f800f87d77f25eb35f6f6be768d759d7298e6507d639ddcc507d094fac444850a01ad872870820b0e61ffa0ff7b02898591285c5d3394a66f3ce328af75513b31af3f58008097112ecb4d8911b068d7ac5731e93ad0b701d8389778983470b874f59263f30fe25b005593b1025ee68fdbedec8319164e6a992ba43e6b431988bd5bf4c6daf862d6f1597b56dcdf735fe7308c35bf9e6b00750e484900e9094e90d4eb521fa7096a6057861530a124db1b14e9da0218f00ecf6f0c24dedb6437806e75bc402d18b25e797682d7a8f649f573c951edb454770830629e1baf692318118ad08bc97aaa5bbb860416c301c255245debb2c23531f0a59f2ab5580c4ebd0c324bfc41d0ebe50714c55a8717e67e318b84bf8d192e7437c2d9f9ed61aff26c4090c21fb4a38f413ca5a6b2697145e94683866fcae46ff2d86738965c35e759d1678426bf35d7604e08f9a19ad25fac816940d59fec33b7ab0a9e0be14642ea69af9614e5f3e67dd1f243d367e600a0ad4e1172212310c7d183296affac87c0fa3c8377550218666dd69ceab3e1e9baa13174a83b525f0d82f9283d02e2911e79f23286677dcb16482aceb71317a9ee4de21195049e7307a142d0d1651204b73a920daadc5518e709c7d407f88de81c61aa25e8d0a6fa4a4f9ed543d6123b9483946d32a4c3b251387975a02ad95790c53d1ea9d7997732d7e4dd5ed10184206c7dd2ce2d27587ce779f53d20fd8dba5f85cf6df09547467da37b9df9c5614fc396785f63d4f5263fd6f269b294d62220fe27c973c44c26cd1ed8048655da0d7bd6b3751375b6cbb983666c3f730df3663a3f46676f90fbdc5600f820e8d47270f0ef4633dba5a93313ce94ebbb9579ee454e7c71eaa697375925542bbf28a5e59c5b8df1e365c49fa67ab2fbe25df23e4886a489f6a3387ce06414a7076526cc9100e6177c99728021922af1cc197a1e4ed4f13f0af8455c464fa8fae20ce41360c4bdc1b70c91ea26f89e9e1dab88002f760babc60ec2a11831746201440fe1abab60bd496ff7a03ea65c23bd70ef083703ad19b01a1413f716128d96aebf958794e4e0958992aa874b18bf42d6f0e815395e8723a13d01eb9e5215a868f82ad22af680faa1edb333918cc476057ad34c1c932592c7cb3f6ecd1ffe280547c9604ac82392682edba0f280767dae14744fd069fc93ceb5c1c5099443cbe76ea747b54d1677433dcd751ffeb14bd90a1c01f2badcdcaad1ece9620e33f6982948c76cb797f32c9bb28d17f6532ad3c5c03e588f899f4a1b3016634954ddd41d1db804ccdc4ef95ce8f8df1393f6c70fa9c1aca205877a7165b68fa6b60a44521c4c48cbb05da601fafcbb7d16fcecfde04a949435e715c2632d3fd39690c93046468fdcfac3699eab74e581d0aca4301ee50b0bdfebbbca6f08c45d2eb2e087876431297f11992bed26b4ce7891a6bc0561539742476738131872a0a9270e5ecdd009bf2498cef42fb17925c2a595705d44422e45ef43e924434c72f34d43868b1ae278fdd7d9826250d93b1b9f59229de20794b8078701f8df198b8fd9c7b62b4ed7da46e877ff2d1e038724db2a5f577f0f5c032da780fff3e72db57b11fddabffd896004ff7ce7465d5993df4d3c49fd9a88d84dfa2c1e2d39e13bac99b81199d2ee2f43f3918a98393c7e3a746512d9e71da8dc1720efc49499a7bdc9385c4506bac78f3e8c2b1cccad49df376f9dae9fec75e16b4b4a9aea25b53f0d8f075ea74a2edbfb96c3f0381e31a6e07c9471995e434c226fc89fe1bad640d0ea275d51035da3ecb232bb9188f5d1cc3a121de1b090ac1e60ec0c0f5763e181bfa107b2f7449d233b4faaed33de80322a5cfba18137d75a4b28d2e0dfc2d30cf047e3b78072282e1236369d3d89a3986fb10dfffa32d009fc9f78a7358ea50a996df58e5f36a531c575219e341669c51b34331e72f32731012f155fd1703bd6b76b2eaa9162c500ca4db9aef1a33a40a18be16bffec7d12d0624f458abcc68278221e40f949b6a773b0a03a8d287eb528b6a98179f381da39f8deab1fb98578e64b08247815cd16dc2bbb038949cfb9d22190fe271104833960baf9adb52817c6823cd73b3baa6fd08e11f4e76d51ffa34237bb9c67ca10d6c4de05d40ef479ce150f6a3134c2253a9eecacbe72e8184a7bd4e431319df210199c58228f8a7ed79af16af141c83cfb9e70d3a3796cfa9c88084dd1bfab432ce59948789fb511373d6f7f2ef47829b61a9639f42911098841b7f714c6117af3905aebbf4efc5e893fdb6d28d9ed95da74a36742f2a7628a4be866ee7108c9c3e3598fdc8f4fbeb3e028249c277b01b253c4d1b18c90dd07bccfc3cdaff48441fa840cd83e66ea2f8003fd4f4147886a3b8a83c8cea47d34e4a798f4ceb077ff6bc1d4a607e4db594bf3883ecded438df23f9b81b8b5fb1cf9b41c0dc136ef79d7a0639e5112012d993462a1c4aedd19dd70f59960e87c72717efe407731bffeda63783cc27f631b708546da777bb2ddc959cc9b54e9629f4cba0350fa94480e9ba6b5350baa1b9e24b5761b320b546b075b159a2cf6ccf369ef2707e1a8b83833f461e482a7dfb55d0e3a17ab79bcc737feda63f5b3b7e836a03711ccb4224d511eb7a6ec54392b44fdb3b6db1ee427c23a6652c1aec5b066dd03145f8635dc398e65a7a28562251fe2175758c1bb662ce4945a0cc31ca5413424b7ff80c1c7c9f17e2dd3cff3e84c2d2a03fec2</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-up\">\n      <input class=\"hbe hbe-input-field hbe-input-field-up\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-up\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-up\">内容加密，输入密码后阅读</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["进厂学习记录"]},{"title":"Day2","url":"/2024/03/20/Day2/","content":"<p>总结一下最近没来得及总结的内容与今日学习内容，由于Java\r\nWeb开发目前没学完，于是边学边补不会的内容：</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"项目开发\">项目开发</h1>\r\n<h2 id=\"软件开发与角色\">1.软件开发与角色</h2>\r\n<h3 id=\"软件开发\">软件开发</h3>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106162815172.png\"\r\nalt=\"image-20221106162815172\" />\r\n<figcaption aria-hidden=\"true\">image-20221106162815172</figcaption>\r\n</figure>\r\n<p><strong>软件开发流程</strong>：</p>\r\n<p>需求分析：完成需求规格说明书、产品原型编写。</p>\r\n<p>设计：UI设计、数据库设计、接口设计</p>\r\n<p>编码：编写项目代码、并完成单元测试。</p>\r\n<p>测试：测试人员,对部署在测试环境的项目进行功能测试,\r\n并出具测试报告。</p>\r\n<p>上线运维：会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后，\r\n再将我们开发好的项目，部署在服务器上运行。</p>\r\n<h3 id=\"角色分工\">角色分工</h3>\r\n<p><strong>招聘/升职岗位</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 33%\" />\r\n<col style=\"width: 27%\" />\r\n<col style=\"width: 39%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\">岗位/角色</th>\r\n<th>对应阶段</th>\r\n<th style=\"text-align: left;\">职责/分工</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">项目经理</td>\r\n<td>全阶段</td>\r\n<td style=\"text-align: left;\">对整个项目负责，任务分配、把控进度</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">产品经理</td>\r\n<td>需求分析</td>\r\n<td\r\nstyle=\"text-align: left;\">进行需求调研，输出需求调研文档、产品原型等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">UI设计师</td>\r\n<td>设计</td>\r\n<td style=\"text-align: left;\">根据产品原型输出界面效果图</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">架构师</td>\r\n<td>设计</td>\r\n<td style=\"text-align: left;\">项目整体架构设计、技术选型等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\"><font color='red'>开发工程师</font></td>\r\n<td><font color='red'>编码</font></td>\r\n<td style=\"text-align: left;\"><font color='red'>功能代码实现</font></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">测试工程师</td>\r\n<td>测试</td>\r\n<td style=\"text-align: left;\">编写测试用例，输出测试报告</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">运维工程师</td>\r\n<td>上线运维</td>\r\n<td style=\"text-align: left;\">软件环境搭建、项目上线</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"大厂研发流程\">大厂研发流程</h3>\r\n<p>需求文档（确定需求包括的功能/确定开发包括的难点） -&gt;\r\n架构图（模块间的依赖关系，角色的分工） -&gt;\r\n确定协议（后端间，前后端间通讯协议，兼容性+易于维护） -&gt;\r\n设计数据结构和算法（格式/容器处理数据，算法大多直接调包） -&gt;\r\n预估容量与性能 -&gt; 考虑部署（环境，分布式，风险意识）-&gt;\r\n设计评审（彼此评审，多方面评价）-&gt;\r\n写代码（不仅在一个地方看到写代码是脑力活了）-&gt; 自测 -&gt;\r\n联调（费时费力，一定先自测好） -&gt; 交给测试岗 -&gt; code\r\nreview（反复修改） -&gt; 合入主干 -&gt; 发布（考虑兼容性）</p>\r\n<h2 id=\"sky项目初步介绍\">2.sky项目初步介绍</h2>\r\n<h3 id=\"技术栈\">技术栈</h3>\r\n<p><strong>用户层：</strong>系统管理后台的前端页面</p>\r\n<p><strong>网关层：</strong>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。</p>\r\n<p>Nginx中还有两个比较重要的作用： <strong>反向代理和负载均衡</strong>，\r\n在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p>\r\n<p><strong>应用层：</strong></p>\r\n<p>SpringBoot： 快速构建Spring项目, 采用 \"约定优于配置\" 的思想,\r\n简化Spring项目的配置开发。</p>\r\n<p>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。</p>\r\n<p>Spring Task: 由Spring提供的定时任务框架。</p>\r\n<p>httpclient: 主要实现了对http请求的发送。</p>\r\n<p>Spring Cache: 由Spring提供的数据缓存框架</p>\r\n<p>JWT: 用于对应用程序上的用户进行身份验证的标记。</p>\r\n<p>阿里云OSS: 对象存储服务，在项目中主要存储文件，如图片等。</p>\r\n<p>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</p>\r\n<p>POI: 封装了对Excel表格的常用操作。</p>\r\n<p>WebSocket:\r\n一种通信网络协议，使客户端和服务器之间的数据交换更加简单，用于项目的来单、催单功能实现。</p>\r\n<p><strong>数据层：</strong></p>\r\n<p>MySQL： <strong>关系型数据库</strong>,\r\n本项目的核心业务数据都会采用MySQL进行存储。</p>\r\n<p>Redis： 基于key-value格式存储的内存数据库, 访问速度快,\r\n经常使用它做<strong>缓存</strong>。</p>\r\n<p>Mybatis：\r\n本项目<strong>持久层</strong>（项目的持久层是指在软件开发中负责处理数据持久化的部分，也称为数据访问层或数据持久化层）将会使用Mybatis开发。</p>\r\n<p>pagehelper: 分页插件。</p>\r\n<p>spring data redis: 简化java代码操作Redis的API。</p>\r\n<p><strong>工具：</strong></p>\r\n<p>git: 版本控制工具, 在团队协作中,\r\n使用该工具对项目中的代码进行管理。</p>\r\n<p>maven: 项目构建工具。</p>\r\n<p>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</p>\r\n<p>postman:\r\n接口测工具，模拟用户发起的各类HTTP请求，获取对应的响应结果。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106185646994.png\"\r\nalt=\"image-20221106185646994\" />\r\n<figcaption aria-hidden=\"true\">image-20221106185646994</figcaption>\r\n</figure>\r\n<h3 id=\"idea搭建环境\"><strong>IDEA搭建环境</strong></h3>\r\n<p><strong>Git</strong>:<a\r\nhref=\"https://blog.csdn.net/weixin_43252521/article/details/123959391\">在\r\nIDEA 中使用 Git 图文教程_idea连接git-CSDN博客</a></p>\r\n<p>更改文件夹后出错，导致无法commit and push：</p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/tcjy1000/article/details/127129224\">git\r\nfatal: detected dubious ownership in repository 解决方法_detected\r\ndubious ownership in repository at-CSDN博客</a></p>\r\n<p><strong>连接数据库</strong>：</p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/Royalic/article/details/119604763\">超详细的Idea与MySQL的连接（从入门到精通）_idea连接数据库-CSDN博客</a></p>\r\n<p>更改mysql文件夹名称，出现ERROR2003:</p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/661201217\">【已解决】mysql：ERROR\r\n2003 (HY000): Can't connect to MySQL server on 'localhost:3306' (10061)\r\n- 知乎 (zhihu.com)</a></p>\r\n<h3 id=\"nginx作用\">nginx作用</h3>\r\n<h4 id=\"反向代理\">反向代理</h4>\r\n<p>前端请求地址：http://localhost/api/employee/login</p>\r\n<p>后端接口地址：http://localhost:8080/admin/employee/login</p>\r\n<p>很明显，两个地址不一致，那是如何请求到后端服务的呢？</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221107152041371.png\"\r\nalt=\"image-20221107152041371\" />\r\n<figcaption aria-hidden=\"true\">image-20221107152041371</figcaption>\r\n</figure>\r\n<p><strong>nginx 反向代理</strong>，就是将前端发送的动态请求由 nginx\r\n转发到后端服务器，而不是不直接发给后端</p>\r\n<p><strong>好处：</strong></p>\r\n<ul>\r\n<li><p>提高访问速度</p>\r\n<p>因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</p></li>\r\n<li><p>进行负载均衡</p>\r\n<p>所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</p></li>\r\n<li><p>保证后端服务安全</p>\r\n<p>因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。</p></li>\r\n</ul>\r\n<p><strong>配置：</strong></p>\r\n<p><strong>nginx 反向代理的配置方式 conf文件中：</strong></p>\r\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"section\">location</span> /api/&#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:8080/admin/; <span class=\"comment\">#反向代理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>proxy_pass：</strong>该指令是用来设置代理服务器的地址，可以是主机名称，IP地址加端口号等形式。</p>\r\n<h4 id=\"负载均衡\">负载均衡</h4>\r\n<p>当如果服务以集群的方式进行部署时，那nginx在转发请求到服务器时就需要做相应的负载均衡。其实，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。</p>\r\n<p><strong>nginx 负载均衡的配置方式：</strong></p>\r\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">upstream</span> webservers&#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.100.128:8080</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.100.129:8080</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"section\">location</span> /api/&#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://webservers/admin;<span class=\"comment\">#负载均衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>upstream：</strong>如果代理服务器是一组服务器的话，我们可以使用upstream指令配置后端服务器组。</p>\r\n<p>如上代码的含义是：监听80端口号， 然后当我们访问\r\nhttp://localhost:80/api/../..这样的接口的时候，它会通过 location /api/\r\n{} 这样的反向代理到\r\nhttp://webservers/admin，根据webservers名称找到一组服务器，根据设置的负载均衡策略(默认是轮询)转发到具体的服务器。</p>\r\n<p><strong>注：</strong>upstream后面的名称可自定义，但要上下保持一致。</p>\r\n<p><strong>nginx 负载均衡策略：</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th><strong>名称</strong></th>\r\n<th><strong>说明</strong></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>轮询</td>\r\n<td>默认方式</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>weight</td>\r\n<td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>ip_hash</td>\r\n<td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>least_conn</td>\r\n<td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>url_hash</td>\r\n<td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>fair</td>\r\n<td>依据响应时间方式，响应时间短的服务将会被优先分配</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"加密登录\">加密登录</h3>\r\n<p><strong>STEP1</strong>：修改数据库中的密码password值，为md5（一个hash算法）加密后的内容</p>\r\n<p><strong>STEP2</strong>：修改Java代码，将前端提交的代码通过md5加密再对比数据库中固定内容</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"导入接口文档\">导入接口文档</h3>\r\n<p><strong>方式：</strong>YApi导入.json数据 https://yapi.pro/</p>\r\n<p>YApi是一个开源的接口管理平台，它主要用于帮助团队更好地管理和维护API（Application\r\nProgramming Interface）接口文档。</p>\r\n<h3 id=\"后端自测\">后端自测</h3>\r\n<p><strong>利用Swagger</strong>：</p>\r\n<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful\r\n风格的 Web 服务(<a href=\"https://swagger.io/\"\r\nclass=\"uri\">https://swagger.io/</a>)。 它的主要作用是：</p>\r\n<ol type=\"1\">\r\n<li><p>使得前后端分离开发更加方便，有利于团队协作</p></li>\r\n<li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li>\r\n<li><p>功能测试</p>\r\n<p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox\r\n，即可非常简单快捷的使用Swagger。</p></li>\r\n</ol>\r\n<p>目前都使用knife4j框架：Java\r\nMVC框架集成Swagger生成文档API增强解决方案</p>\r\n<p>1.导入Maven依赖 pox.xml</p>\r\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.xiaoymin<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>2.在配置类中加入 knife4j 相关配置</p>\r\n<p>3.设置静态资源映射，否则接口文档页面无法访问</p>\r\n<p>4.访问测试，接口文档路径在原路径后加入：/doc.html(静态资源映射)</p>\r\n<p>接口测试:测试登录功能</p>\r\n<p>Swagger常用注解：通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 28%\" />\r\n<col style=\"width: 72%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th><strong>注解</strong></th>\r\n<th><strong>说明</strong></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><strong><span class=\"citation\"\r\ndata-cites=\"Api\">@Api</span></strong></td>\r\n<td>用在类上，例如Controller，表示对类的说明</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><strong><span class=\"citation\"\r\ndata-cites=\"ApiModel\">@ApiModel</span></strong></td>\r\n<td>用在类上，例如entity、DTO、VO</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><strong><span class=\"citation\"\r\ndata-cites=\"ApiModelProperty\">@ApiModelProperty</span></strong></td>\r\n<td>用在属性上，描述属性信息</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><strong><span class=\"citation\"\r\ndata-cites=\"ApiOperation\">@ApiOperation</span></strong></td>\r\n<td>用在方法上，例如Controller的方法，说明方法的用途、作用</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Swagger PK YApi</strong>：</p>\r\n<p>1、Yapi 是设计阶段使用的工具，管理和维护接口</p>\r\n<p>2、Swagger 在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</p>\r\n<h2 id=\"实现功能\">3.实现功能</h2>\r\n<p>实现任何一个功能都要有如下几步：</p>\r\n<p><strong>需求分析与设计-&gt;代码开发-&gt;功能测试-&gt;代码完善</strong></p>\r\n<p>一般在做需求分析时，往往都是对照着产品原型进行分析，因为产品原型比较直观，便于我们理解业务，设计出来表单内容/文档/接口</p>\r\n<p><strong>代码开发</strong>是根据需求分析的内容，结合代码的原本框架，根据功能添加新的部分（选择实现功能的方法）</p>\r\n<p><strong>功能测试实现方式：</strong></p>\r\n<ul>\r\n<li>通过接口文档测试 swagger的doc/html，向后端发送数据</li>\r\n<li>通过前后端联调测试：nginx启动http服务，在前端直接发送数据到后端</li>\r\n</ul>\r\n<p><strong>代码完善：</strong>针对功能测试中程序出现的问题，调整代码的内容，接下来在实现功能中，我们将记录重点集中在<strong>代码开发和代码完善</strong></p>\r\n<h3 id=\"新增员工\">新增员工</h3>\r\n<h4 id=\"代码开发\">代码开发</h4>\r\n<p>根据新增员工接口设计对应的DTO（当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据）</p>\r\n<p><strong>什么是DTO？</strong></p>\r\n<p>Java是<strong>面向对象（object）的</strong>，在开发过程中，我们会封装各种各样的实体类</p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/680050977\">一篇文章带你搞懂Controller、Service等各层的功能与作用\r\n- 知乎 (zhihu.com)</a></p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 41%\" />\r\n<col style=\"width: 58%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th><strong>实体类</strong></th>\r\n<th><strong>说明</strong></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>PO持久化对象（Persistent Object）</td>\r\n<td>用于表示数据库中的实体或表的映射 通常与数据库表的结构和字段对应\r\nPO的属性对应数据库表的字段，可以进行持久化操作（新增、查询、更新、删除）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><strong>VO值对象（Value Object）</strong></td>\r\n<td>VO是值对象，用于封装数据，通常是不可变的，用于传递数据而不包含业务逻辑，VO可以用于在不同层之间传递数据，如前端和后端之间，后端的返回的到前端的数据只需要保留必要的字段就可以，将这些必要的字段封装起来就是VO</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>BO业务对象（Business Object）</td>\r\n<td>BO是业务对象，用于封装业务逻辑和操作包含与业务相关的方法和属性，用于实现业务规则和操作，BO通常与领域模型紧密相关，用于表示业务概念和业务流程</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>DO数据对象（Data/Domain Object）</td>\r\n<td>DO通常与BO和PO相对应，用于实现领域模型和业务逻辑，用于表示从数据存储中得到的数据</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>DAO数据访问对象（Data Access Object）</td>\r\n<td>DAO是数据访问对象，用于封装对数据库的访问操作，也就是我们常说的Dao层<br/>提供对数据库的增删改查等操作的接口<br/>DAO可以隐藏底层数据库的具体实现细节，使得业务逻辑层与数据库解耦</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><strong>DTO数据传输对象（Data Transfer Object）</strong></td>\r\n<td>DTO是<strong>数据传输对象</strong>，用于在不同层之间传输数据<br/>通常用于优化数据传输的性能和减少网络通信的开销。<br/>DTO可以封装多个对象的数据，以减少网络请求次数<br/>如果说VO一般用于前端和后端之后传输数据，那么DTO就是在后端的不同层之间传递数据，例如controller层和service层或者在服务之间结构调用的时候使用DTO</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>POJO普通Java对象（Plain Old Java Object）</td>\r\n<td>POJO是一个简单的Java对象，没有特定的限制和约束<br/>是一种普通的Java类，不依赖于特定的框架或接口</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Service层：服务层</strong>\r\n由于Dao里面存放了对表操作的方法，entity类中存放了映射表的POJO类。Service的作用就是将Dao和entity类整合起来，进行再次封装，封装成一个方法，我们调用这个方法，就实现了对某个表的增删改查操作。</p>\r\n<p><strong>Controller：控制层</strong>\r\n负责请求转发，接受页面传递过来的参数，根据参数的不同，是调用不同的Service层方法进行操作，操作完成后将返回结果传递给页面。</p>\r\n<p><strong>数据访问层：</strong></p>\r\n<p><strong>Mapper：</strong>Mapper模式通常是指对象-关系映射（ORM）中的组件。它负责将<strong>领域对象和数据库表</strong>之间进行映射，实现数据的读取和写入。Mapper将<strong>数据库操作转换为对象操作</strong>，屏蔽了底层数据库的细节，使得开发人员可以使用<strong>面向对象</strong>的方式操作数据。\r\n它可以处理对象与关系型数据库之间的转换，包括查询、插入、更新和删除等操作。</p>\r\n<p><strong>DAO：</strong>DAO全称是（Data Access Objects)\r\n，数据库访问对象，主要的功能就是用于进行数据操作的，在程序的标准开发架构中属于数据访问层的操作。可以简单理解为一张数据表，就有一个DAO与之对应，与数据库的操作，增删改查等方法。DAO层可以实现对数据的持久化操作，使得业务逻辑可以通过DAO的接口来访问数据，而不需要关心具体的数据访问实现方式。</p>\r\n<p><strong>STEP1：自定义DTO类。</strong></p>\r\n<p>进入sky-pojo模块，在com.sky.dto包下，已定义EmployeeDTO</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sky.dto;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeDTO</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String idNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>STEP2：Controller层操作</strong></p>\r\n<p><strong>EmployeeController中创建新增员工方法</strong></p>\r\n<p>进入到sky-server模块中，在com.sky.controller.admin包下，在EmployeeController中创建新增员工方法，接收前端提交的参数。</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 新增员工</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeeDTO</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">   <span class=\"meta\">@ApiOperation(&quot;新增员工&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Result <span class=\"title function_\">save</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;新增员工：&#123;&#125;&quot;</span>,employeeDTO);</span><br><span class=\"line\">       employeeService.save(employeeDTO);<span class=\"comment\">//该方法后续步骤会定义</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.success();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>注：</strong>Result类定义了后端统一返回结果格式。（success(有无参数)\r\nerror）</p>\r\n<p><strong>STEP3：Service层接口与实现</strong></p>\r\n<p><strong>在EmployeeService接口中声明新增员工方法</strong></p>\r\n<p>进入到sky-server模块中,com.sky.server.EmployeeService</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 新增员工</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeeDTO</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">save</span><span class=\"params\">(EmployeeDTO employeeDTO)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>在接口的实现中：</p>\r\n<p><strong>在EmployeeServiceImpl中实现新增员工方法</strong></p>\r\n<p>com.sky.server.impl.EmployeeServiceImpl中创建方法</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 新增员工</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeeDTO</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">save</span><span class=\"params\">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//对象属性拷贝</span></span><br><span class=\"line\">       BeanUtils.copyProperties(employeeDTO, employee);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//设置账号的状态，默认正常状态 1表示正常 0表示锁定，StatusConstant表示状态常量</span></span><br><span class=\"line\">       employee.setStatus(StatusConstant.ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//设置密码，默认密码123456，加密后的</span></span><br><span class=\"line\">       employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//设置当前记录的创建时间和修改时间</span></span><br><span class=\"line\">       employee.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">       employee.setUpdateTime(LocalDateTime.now());</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//todo 设置当前记录创建人id和修改人id</span></span><br><span class=\"line\">       employee.setCreateUser(<span class=\"number\">10L</span>);<span class=\"comment\">//目前写个假数据，后期修改</span></span><br><span class=\"line\">       employee.setUpdateUser(<span class=\"number\">10L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       employeeMapper.insert(employee);<span class=\"comment\">//后续步骤定义</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>STEP4：Mapper层</strong></p>\r\n<p><strong>在EmployeeMapper中声明insert方法</strong></p>\r\n<p>com.sky.EmployeeMapper中添加方法</p>\r\n<p>由于SQL语句不是很复杂，因而此处用注解@Insert实现：注意在values值后加的内容要用驼峰命名法（application.yml已开启驼峰命名），而不是和数据库中的名称一致</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 插入员工数据</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employee</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +</span></span><br><span class=\"line\"><span class=\"meta\">           &quot;values &quot; +</span></span><br><span class=\"line\"><span class=\"meta\">           &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(Employee employee)</span>;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"功能测试\">功能测试</h4>\r\n<p><strong>1.接口文档测试</strong></p>\r\n<p><strong>启动服务：</strong>访问http://localhost:8080/doc.html，进入新增员工接口</p>\r\n<p>json数据：</p>\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;idNumber&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;111222333444555666&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xiaozhi&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;phone&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;13812344321&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;sex&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;username&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;小智&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\r\n<p>响应码：401\r\n报错，原因：JwtTokenAdminInterceptor拦截器，需要校验token，由于JWT令牌校验失败，导致EmployeeController的save方法没有被调用，被拦截器拦截了</p>\r\n<p><strong>解决方法：</strong>调用员工登录接口获得一个合法的JWT令牌，使用admin用户登录获取令牌，将合法的JWT令牌添加到全局参数中</p>\r\n<p>文档管理--&gt;全局参数设置--&gt;添加参数，使得每次发送的json信息都会增加一个token头部，是合法的令牌；</p>\r\n<p><strong>什么是JWT？</strong></p>\r\n<p>https://blog.csdn.net/java_mindmap/article/details/123343404</p>\r\n<p><strong>JWT概念</strong></p>\r\n<p>JWT ， 全写JSON Web Token,\r\n是开放的行业标准RFC7591，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>\r\n<p>JWT加密JSON，保存在客户端，不需要在服务端保存会话信息，可以应用在前后端分离的用户验证上，后端对前端输入的用户信息进行加密产生一个令牌字符串，\r\n前端再次请求时附加此字符串，后端再使用算法解密。</p>\r\n<p><strong>JWT使用场景：</strong></p>\r\n<ul>\r\n<li>Authorization (授权) :\r\n这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li>\r\n<li>Information Exchange (信息交换) :\r\n对于安全的在各方之间传输信息而言，JSON Web\r\nTokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</li>\r\n</ul>\r\n<p><strong>流程：</strong></p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/56e4f404cc63cfc2ac31283c8e944613.png\"\r\nalt=\"56e4f404cc63cfc2ac31283c8e944613.png\" />\r\n<figcaption\r\naria-hidden=\"true\">56e4f404cc63cfc2ac31283c8e944613.png</figcaption>\r\n</figure>\r\n<p>JSON Web\r\nToken由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>\r\n<ul>\r\n<li><p>Header：Header 部分是一个 JSON\r\n对象，存放Token类型和加密算法。加密算法常见的有MD5、SHA、HMAC（ Hash\r\nMessage Authentication Code）。</p></li>\r\n<li><p>Payload：存放有效信息，包括</p>\r\n<ul>\r\n<li>标准的声明，类似开发语言总的关键字，如\r\n<ul>\r\n<li>iss（Issuser） - 签发者</li>\r\n<li>sub Subject 面向主体</li>\r\n<li>aud Audience 接收方</li>\r\n<li>exp Expiration time 过期时间戳</li>\r\n<li>nbf Not Before, 开始生效时间戳</li>\r\n<li>iat(Issued at) 签发时间</li>\r\n<li>jti(JWT ID)： 唯一标识</li>\r\n</ul></li>\r\n<li>公共的声明：一般添加业务相关的必要信息，因为可解密，不建议敏感信息。</li>\r\n<li>私有的声明：提供者和消费者共同定义的声明，Base64对称解密，不建议敏感信息</li>\r\n</ul></li>\r\n<li><p>Signature签名：对前两个部分的签名，防止数据篡改。</p>\r\n<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用\r\nHeader 里面指定的签名算法（默认是 HMAC\r\nSHA256），按照下面的公式产生签名。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HMACSHA256(</span><br><span class=\"line\">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class=\"line\">  base64UrlEncode(payload),</span><br><span class=\"line\">  secret)</span><br></pre></td></tr></table></figure>\r\n<p>算出签名以后，把 Header、Payload、Signature\r\n三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。</p>\r\n<p>secret-密钥\r\n使用header中声明的加密算法对Header和payload的加密连接字符串进行secret组合加密。密钥保存在服务端，服务端根据密钥进行解密验证。</p></li>\r\n</ul>\r\n<p>标准的声明，类似开发语言总的关键字</p>\r\n<p>格式：xxxx.yyyy.zzzz</p>\r\n<p><strong>java-jwt/jjwt</strong></p>\r\n<p>java-jwt是Java语言中推荐的JWT实现库，使用Maven导入如下：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\"> &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class=\"line\"> &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class=\"line\"> &lt;version&gt;<span class=\"number\">3.8</span><span class=\"number\">.3</span>&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\r\n<p><strong>产生加密Token</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> JWT.create()</span><br><span class=\"line\">  .withExpiresAt(newDate(System.currentTimeMillis()))  <span class=\"comment\">//设置过期时间</span></span><br><span class=\"line\">  .withAudience(<span class=\"string\">&quot;user1&quot;</span>) <span class=\"comment\">//设置接受方信息，一般时登录用户</span></span><br><span class=\"line\">  .sign(Algorithm.HMAC256(<span class=\"string\">&quot;111111&quot;</span>));  <span class=\"comment\">//使用HMAC算法，111111作为密钥加密</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>解密Token获取负载信息并验证Token是否有效</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> JWT.decode(token).getAudience().get(<span class=\"number\">0</span>);</span><br><span class=\"line\">Assertions.assertEquals(<span class=\"string\">&quot;user1&quot;</span>, userId);</span><br><span class=\"line\"><span class=\"type\">JWTVerifier</span> <span class=\"variable\">jwtVerifier</span> <span class=\"operator\">=</span> JWT.require(Algorithm.HMAC256(<span class=\"string\">&quot;111111&quot;</span>)).build();</span><br><span class=\"line\">jwtVerifier.verify(token);</span><br></pre></td></tr></table></figure>\r\n<p>所谓的Token，其实就是服务端生成的一串加密字符串、以作客户端进行请求的一个“令牌”。当用户第一次使用账号密码成功进行登录后，服务器便生成一个Token及Token失效时间并将此返回给客户端，若成功登陆，以后客户端只需在有效时间内带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>\r\n<p><strong>2.前后端联调测试</strong></p>\r\n<p>启动nginx,访问\r\nhttp://localhost，通过前端员工管理界面添加信息，查看emplyee表，发现测试成功</p>\r\n<h4 id=\"代码完善\">代码完善</h4>\r\n<p>目前，程序存在的问题主要有两个：</p>\r\n<ul>\r\n<li>录入的用户名已存在，抛出的异常后没有处理</li>\r\n<li>新增员工时，创建人id和修改人id设置为固定值</li>\r\n</ul>\r\n<p>接下来，我们对上述两个问题依次进行分析和解决。</p>\r\n<p><strong>问题一的解决</strong>：</p>\r\n<p>使得每次录入存在用户名时，前端会收到提示消息，通过全局异常处理器来处理，进入到sky-server模块，com.sky.hander包下，GlobalExceptionHandler.java添加方法</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理SQL异常</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> ex</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@ExceptionHandler</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Result <span class=\"title function_\">exceptionHandler</span><span class=\"params\">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//Duplicate entry &#x27;zhangsan&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> ex.getMessage();</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(message.contains(<span class=\"string\">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class=\"line\">           String[] split = message.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> split[<span class=\"number\">2</span>];</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> username + MessageConstant.ALREADY_EXISTS;<span class=\"comment\">//Message...是提前定义好的常量类</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> Result.error(msg);</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> Result.error(MessageConstant.UNKNOWN_ERROR);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>问题二的解决：</strong></p>\r\n<p><strong>在员工登录成功后会生成JWT令牌并响应给前端：</strong></p>\r\n<p>JWT响应过程：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221111201922482.png\"\r\nalt=\"image-20221111201922482\" />\r\n<figcaption aria-hidden=\"true\">image-20221111201922482</figcaption>\r\n</figure>\r\n<p>后续请求中，前端会携带<strong>JWT令牌</strong>，通过JWT令牌可以<strong>解析出</strong>当前登录员工id，解析出登录员工id后，如何传递给Service的save方法？</p>\r\n<p>通过<strong>ThreadLocal</strong></p>\r\n<p>ThreadLocal 并不是一个Thread，而是Thread的局部变量。\r\nThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p>\r\n<p><strong>常用方法：</strong></p>\r\n<ul>\r\n<li>public void set(T value) 设置当前线程的线程局部变量的值</li>\r\n<li>public T get() 返回当前线程所对应的线程局部变量的值</li>\r\n<li>public void remove() 移除当前线程的线程局部变量</li>\r\n</ul>\r\n<p>于是在初始工程中已经封装了 ThreadLocal\r\n操作的工具类前提下，修改代码：</p>\r\n<p>在拦截器中interceptor解析出当前登录员工id，并放入<strong>线程局部变量中\r\n-&gt;在Service中获取线程局部变量中的值</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">Long</span> <span class=\"variable\">empId</span> <span class=\"operator\">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;当前员工id：&quot;</span>, empId);</span><br><span class=\"line\">            <span class=\"comment\">/////将用户id存储到ThreadLocal////////</span></span><br><span class=\"line\">            BaseContext.setCurrentId(empId);</span><br><span class=\"line\">            <span class=\"comment\">///////////////////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在save方法中加入：</span></span><br><span class=\"line\">employee.setUpdateUser(BaseContext.getCurrentId());</span><br><span class=\"line\"><span class=\"comment\">//从线程池局部变量取值</span></span><br></pre></td></tr></table></figure>\r\n<p>即可完成创建人id的更新</p>\r\n<p>开始刷，随后有时间再去看acwing的算法基础课、提高课、labulagu等（侧重于系统化长时间学习，ACMer，针对思维）</p>\r\n","categories":["进厂学习记录"],"tags":["nginx","软件开发"]},{"title":"Day1","url":"/2024/03/19/Day1/","content":"<h1 id=\"如何学习技术\">如何学习技术</h1>\r\n<p>1.八股入手教程，入个门，材料作为学习提纲，真正使用，实操，理论点实操去落地，项目去反作用理论</p>\r\n<p>2.简历做提纲：包装一些实习经历，做的项目，包装的项目中所做的内容，落地的东西，面试官深挖，深度参与度，思路</p>\r\n<p>3.平时去投递小厂/大厂，通过面试去练，日常都可以投，多面几次，出题内容等，查漏补缺，把平时面当成模拟面试，面试多总结</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"总体路线\">总体路线</h1>\r\n<p>现在想先找个日常实习，为自己打个底，目前的计划路线主要分为三步，分别是：</p>\r\n<ol type=\"1\">\r\n<li>Java基础的巩固 -&gt;\r\nJavaWeb开发（选学核心部分如SpringBoot）-&gt;直接开苍穹外卖项目，改项目，总结内容</li>\r\n<li>背八股：根据Java知识体系框架（JavaGuide和小林） +\r\n各大公司的面经开始背诵</li>\r\n<li>刷算法：起步开始刷或许很困难，坚持下来吧</li>\r\n</ol>\r\n<h1 id=\"规划\">规划</h1>\r\n<p>作为一个测了三次都是infj的纯种i规划人，上次写完了自己的一些背景和总体路线，当成一个情绪抒发文，在正式开始的第一天，想随便写一下自己以后要学些什么内容。</p>\r\n<p><strong>前期：</strong>在3月初参加了华为在西电的双选会，抱着试一试的心态投递了简历，结果今天接到了HR的电话，告诉我两件事：</p>\r\n<ol type=\"1\">\r\n<li><p>理论上实习生不能要我这样保完研的，因为不确定性太大了，只要应届生，这是规定；但是<strong>美赛的F奖</strong>是华为内部认可的，于是可以给我争取投一个见习的名额，标为优秀学生标签；</p></li>\r\n<li><p>投递的部门出现了问题，应该是ICT的计算产品线（\r\n因为这件事搞了好几次，自己一直在犯蠢o(╥﹏╥)o ）</p></li>\r\n</ol>\r\n<p>简历已经投递完毕了，大概的面试在4.5月份，所以还有充足的时间进行准备，所以现在想简单说一下准备的内容：</p>\r\n<p>还是上面的三个路线，只不过要具象化三个路线：</p>\r\n<ol type=\"1\">\r\n<li>先把<strong>黑马的外卖</strong>基本上过一遍，总结笔记内容，不会的地方及时搜索，整理，在过程中就自然而然学会了Java的一些内容如Redis等；</li>\r\n<li>日常的<strong>Leetcode</strong>刷题需要严格落实，每天至少1-2道题刷题，先刷hot\r\n100，再看华为的机试题，多刷，多总结，多反思，有代码启示录和labuladong算法小抄的加持，多看多总结多思考，不能光看不总结，自己的优点也是学习特点就是<strong>爱总结</strong>，保持<strong>好习惯</strong>；</li>\r\n<li>重点针对简历上的内容进行学习背诵，其次结合热门常考题，<strong>八股八股</strong>，就是背背背~在面试前看项目</li>\r\n</ol>\r\n<p><br></p>\r\n<p><strong>坚持学习，让乏味的生活多姿多彩。</strong></p>\r\n","categories":["进厂学习记录"]},{"title":"Day3","url":"/2024/03/21/Day3/","content":"<h1 id=\"算法\">算法</h1>\r\n<h2 id=\"编程素养\">编程素养</h2>\r\n<p>跟着代码随想录刷代码之前，看到了有一些编程的基本素养，先总结一下，养成一个良好的习惯再开始</p>\r\n<h3 id=\"命名\"><strong>命名</strong></h3>\r\n<p>主流有如下三种变量规则：</p>\r\n<ul>\r\n<li>小驼峰、大驼峰命名法</li>\r\n<li>下划线命名法</li>\r\n<li>匈牙利命名法</li>\r\n</ul>\r\n<p>小驼峰，第一个单词首字母小写，后面其他单词首字母大写。例如\r\n<code>int myAge;</code></p>\r\n<p>大驼峰法把第一个单词的首字母也大写了。例如：<code>int MyAge;</code></p>\r\n<span id=\"more\"></span>\r\n<p>通常来讲\r\njava和go都使用<strong>驼峰</strong>，C++的函数和结构体命名也是用大驼峰</p>\r\n<p>匈牙利命名法是：变量名 = 属性 + 类型 +\r\n对象描述，例如：<code>int iMyAge</code>，这种命名是一个来此匈牙利的程序员在微软内部推广起来，然后推广给了全世界的Windows开发人员。</p>\r\n<p>这种命名方式在没有IDE的时代，可以很好的提醒开发人员遍历的意义，例如看到iMyAge，就知道它是一个int型的变量，而不用找它的定义，缺点是一旦改变变量的属性，那么整个项目里这个变量名字都要改动，所以带来代码维护困难。</p>\r\n<h3 id=\"空格\"><strong>空格</strong></h3>\r\n<p>经常看到有的同学的代码都堆在一起，看起来都费劲，或者是有的间隔有空格，有的没有空格，很不统一，有的同学甚至为了让代码精简，把所有空格都省略掉了。</p>\r\n<ul>\r\n<li><p>操作符左右一定有空格 <code>i = i + 1'</code></p></li>\r\n<li><p>分隔符（<code>,</code>\r\n和<code>;</code>）前一位没有空格，后一位保持空格，例如：<code>int i, j</code></p></li>\r\n<li><p>大括号和函数保持同一行，并有一个空格例如：</p>\r\n<p><code>while (n) &#123;</code></p>\r\n<p>​ <code>n--;</code></p>\r\n<p><code>&#125;</code></p></li>\r\n<li><p>控制语句（while，if，for）后都有一个空格</p></li>\r\n</ul>\r\n<p>Google规范是 大括号和\r\n控制语句保持同一行的，我个人也很认可这种写法，因为可以缩短代码的行数，特别是项目中代码行数很多的情况下，这种写法是可以提高阅读代码的效率。</p>\r\n<p><strong>代码风格其实统一就行，没有严格的说谁对谁错</strong>。</p>\r\n<h3 id=\"库函数\"><strong>库函数</strong></h3>\r\n<p>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</p>\r\n<p>如果库函数仅仅是\r\n解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，那么直接用库函数。</p>\r\n<h3 id=\"核心模式-vs-acm模式\">核心模式 VS ACM模式</h3>\r\n<p>平时大家在力扣上刷题，就是\r\n核心代码模式，即给你一个函数，直接写函数实现，例如这样：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code-thinking-1253855093.file.myqcloud.com/pics/20231109193631.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>而ACM模式，是程序头文件，main函数，数据的输入输出都要自己处理，例如这样：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code-thinking-1253855093.file.myqcloud.com/pics/20231109193743.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>笔试的话，基本都是 ACM模式。</p>\r\n<p>面试的话，看情况，有的面试官会让你写一个函数实现就可以，此时就是核心代码模式。</p>\r\n<p>有的面试官会\r\n给你一个编辑器，让你写完代码运行一下看看输出结果，此时就是ACM模式。</p>\r\n<h3 id=\"markdown\">MarkDown</h3>\r\n<p>markdown所有用法：<a\r\nhref=\"https://markdown-it.github.io/\">markdown-it demo</a></p>\r\n<h2 id=\"力扣刷法\">力扣刷法</h2>\r\n<p>按照力扣的HOT\r\n100或剑指offer容易忘，所以推荐以下<strong>刷题方法：</strong></p>\r\n<p><strong>刷题条件：</strong>编程语言基础+数据结构算法的知识</p>\r\n<p><strong>分类刷题：</strong>按照模块，刷同模块的题</p>\r\n<ul>\r\n<li>数据结构篇：先刷基本的数据结构如数组，链表，栈和队列，堆，<strong>二叉树</strong>，字符串，哈希表；</li>\r\n<li>算法技巧篇：<strong>回溯算法、贪心算法、动态规划、排序</strong>、双指针法，滑动窗口，数学运算，等常见算法</li>\r\n</ul>\r\n<p><strong>刷题方式：</strong></p>\r\n<ul>\r\n<li><p>目前是跟着代码随想录的编排刷，拿到典型题目，先自己想，至少暴力算法有思路，然后看一下<strong>随想录的解法</strong>，理解其思想，带着算法思想阅读细节，最后自己写一遍；</p></li>\r\n<li><p>写完去查看一些高热度题解，适合自己的就是最好的，通过他人的题解来提高自己，弥补自己思考的不足。</p></li>\r\n<li><p>最后再看相同类型的题，自己写出来相同类型的题</p></li>\r\n</ul>\r\n<p><strong>循环刷题：</strong>第一遍过，第二遍过，过的基本差不多了，可以拿起来思考一下就懂思路时，直接上hot100或剑指offer这种系统性/框架性的刷</p>\r\n<p><strong>重点在及时复习</strong></p>\r\n<p>应试：使用<strong>codetop</strong></p>\r\n<p>codetop汇集了一些公司面试的高频题目，在具体准备某公司面试/笔试时，可以额外再刷这些高频题目</p>\r\n<h1 id=\"其他\">其他</h1>\r\n<p>根据<a\r\nhref=\"https://www.liaoxuefeng.com/wiki/896043488029600\">Git教程 -\r\n廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\r\n<p>学习总结一下<strong>Git</strong>的基本用法</p>\r\n<h2 id=\"git简介\">1.Git简介</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://www.liaoxuefeng.com/files/attachments/918921150461184/0\"\r\nalt=\"git-tutorial\" />\r\n<figcaption aria-hidden=\"true\">git-tutorial</figcaption>\r\n</figure>\r\n<p>官网介绍：</p>\r\n<p>Git is a <a\r\nhref=\"https://git-scm.com/about/free-and-open-source\">free and open\r\nsource</a> distributed version control system designed to handle\r\neverything from small to very large projects with speed and\r\nefficiency.Git is <a href=\"https://git-scm.com/doc\">easy to learn</a>\r\nand has a <a href=\"https://git-scm.com/about/small-and-fast\">tiny\r\nfootprint with lightning fast performance</a>. It outclasses SCM tools\r\nlike Subversion, CVS, Perforce, and ClearCase with features like <a\r\nhref=\"https://git-scm.com/about/branching-and-merging\">cheap local\r\nbranching</a>, convenient <a\r\nhref=\"https://git-scm.com/about/staging-area\">staging areas</a>, and <a\r\nhref=\"https://git-scm.com/about/distributed\">multiple workflows</a>.</p>\r\n<p>Git 是一个<a\r\nhref=\"https://git-scm.com/about/free-and-open-source\">免费开源</a>分布式版本控制系统，旨在快速高效地处理从小到大的项目。Git\r\n<a href=\"https://git-scm.com/doc\">易于学习</a> 并且<a\r\nhref=\"https://git-scm.com/about/small-and-fast\">占用空间小，性能快如闪电</a>\r\n。 它超越了 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具，具有<a\r\nhref=\"https://git-scm.com/about/branching-and-merging\">廉价的本地分支</a>、方便的<a\r\nhref=\"https://git-scm.com/about/branching-and-merging\">暂存区域</a>等功能\r\n/git-scm.com/about/staging-area）和<a\r\nhref=\"https://git-scm.com/about/distributed\">多个工作流程</a>。</p>\r\n<p>Git是目前世界上最先进的分布式版本控制系统</p>\r\n<h3 id=\"分布式版本控制\">分布式版本控制</h3>\r\n<p>用word写了长篇大论，不同时间写不同版本，就会_v几，_v几，想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，就会变得很乱</p>\r\n<p>如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p>\r\n<p>每次改动都会像下面一样：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\">版本</th>\r\n<th style=\"text-align: left;\">文件名</th>\r\n<th style=\"text-align: left;\">用户</th>\r\n<th style=\"text-align: left;\">说明</th>\r\n<th style=\"text-align: left;\">日期</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">1</td>\r\n<td style=\"text-align: left;\">service.doc</td>\r\n<td style=\"text-align: left;\">张三</td>\r\n<td style=\"text-align: left;\">删除了软件服务条款5</td>\r\n<td style=\"text-align: left;\">7/12 10:38</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">2</td>\r\n<td style=\"text-align: left;\">service.doc</td>\r\n<td style=\"text-align: left;\">张三</td>\r\n<td style=\"text-align: left;\">增加了License人数限制</td>\r\n<td style=\"text-align: left;\">7/12 18:09</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">3</td>\r\n<td style=\"text-align: left;\">service.doc</td>\r\n<td style=\"text-align: left;\">李四</td>\r\n<td style=\"text-align: left;\">财务部门调整了合同金额</td>\r\n<td style=\"text-align: left;\">7/13 9:51</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">4</td>\r\n<td style=\"text-align: left;\">service.doc</td>\r\n<td style=\"text-align: left;\">张三</td>\r\n<td style=\"text-align: left;\">延长了免费升级周期</td>\r\n<td style=\"text-align: left;\">7/14 15:17</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>于是，Git便来了</p>\r\n<h2 id=\"git安装\">2.Git安装</h2>\r\n<p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git //linux</span><br></pre></td></tr></table></figure>\r\n<p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git\r\nBash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>\r\n<p>安装完成后，还需要最后一步设置，因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\r\n<p>在命令行输入：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global user.name <span class=\"string\">&quot;Your Name&quot;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global user.email <span class=\"string\">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>\r\n<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>\r\n<h3 id=\"创建版本库\">创建版本库</h3>\r\n<p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\r\n<p>所以，创建一个版本库非常简单：</p>\r\n<p><strong>STEP1</strong>:首先，选择一个合适的地方，创建一个空目录：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> learngit</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> learngit</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/Users/michael/learngit</span><br></pre></td></tr></table></figure>\r\n<p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p>\r\n<p>(windows系统尽量不带中文)</p>\r\n<p><strong>STEP2:</strong></p>\r\n<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git init</span></span><br><span class=\"line\">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure>\r\n<p>可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。（如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见）</p>\r\n<h2 id=\"git本地使用\">3.Git本地使用</h2>\r\n<p>修改一个文件后，运行<strong><code>git status</code></strong>命令看看结果，<code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>\r\n<p>如果想具体看看修改了什么内容呢？需要用<strong><code>git diff</code></strong>这个命令:</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git diff readme.txt</span> </span><br></pre></td></tr></table></figure>\r\n<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>\r\n<p>知道了作什么修改后，将其提交到仓库：</p>\r\n<p>首先是<code>git add</code>：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git add readme.txt</span></span><br></pre></td></tr></table></figure>\r\n<p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态，<code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git commit -m <span class=\"string\">&quot;add distributed&quot;</span></span></span><br><span class=\"line\">[master e475afc] add distributed</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\r\n<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态。</p>\r\n<p>在Git中，我们用<code>git log</code>命令，就可以看到我们操作的日志</p>\r\n<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p>\r\n<p><strong>退回到上个版本：</strong></p>\r\n<p>Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，上100个版本：<code>HEAD~100</code></p>\r\n<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git reset --hard HEAD^</span></span><br><span class=\"line\">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>\r\n<p>查看readme.txt内容：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> readme.txt</span></span><br></pre></td></tr></table></figure>\r\n<p>但是这样，最新的版本就没有了，回不到最新的版本了，log日志查看直接回到以前了，想回去：</p>\r\n<p>或者如果有commit id的话，可以直接：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git reset --hard 1094a</span></span><br></pre></td></tr></table></figure>\r\n<p>找不到commit id？：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git reflog</span></span><br></pre></td></tr></table></figure>\r\n<p>用来记录你的每一次命令，查看命令历史</p>\r\n<p>其实本质是：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────┐</span><br><span class=\"line\">│HEAD│</span><br><span class=\"line\">└────┘</span><br><span class=\"line\">   │</span><br><span class=\"line\">   └──▶ ○ append GPL</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ○ add distributed</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>\r\n<p><strong>Git操作的暂存区</strong></p>\r\n<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>\r\n<p><strong>工作区（Working\r\nDirectory）</strong>：在电脑里能看到的目录</p>\r\n<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://www.liaoxuefeng.com/files/attachments/919020037470528/0\"\r\nalt=\"git-repo\" />\r\n<figcaption aria-hidden=\"true\">git-repo</figcaption>\r\n</figure>\r\n<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>\r\n<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>\r\n<p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支</p>\r\n<p>一旦提交以后，又没有对工作区做修改，工作区就变\"干净\"了：</p>\r\n<p>（<code>git status</code>随时都能查看状态）</p>\r\n<p>版本库变成了这样，暂存区就没有任何内容了：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://www.liaoxuefeng.com/files/attachments/919020100829536/0\"\r\nalt=\"git-stage-after-commit\" />\r\n<figcaption aria-hidden=\"true\">git-stage-after-commit</figcaption>\r\n</figure>\r\n<p>Git跟踪并管理的是修改，而非文件</p>\r\n<p>修改两次文件，顺序变成：</p>\r\n<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt;\r\n<code>git commit</code></p>\r\n<p>Git管理的是修改，当用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>\r\n<p>修改以后必须add，才能进暂存区</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>\r\n<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>\r\n<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到<strong>和版本库</strong>一模一样的状态；</p>\r\n<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到<strong>添加到暂存区后</strong>的状态。</p>\r\n<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>\r\n<p>在Git中，删除也是一个修改操作</p>\r\n<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">rm</span> test.txt</span></span><br></pre></td></tr></table></figure>\r\n<p>确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">rm</span> test.txt</span></span><br><span class=\"line\">rm &#x27;test.txt&#x27;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git commit -m <span class=\"string\">&quot;remove test.txt&quot;</span></span></span><br><span class=\"line\">[master d46f35e] remove test.txt</span><br><span class=\"line\"> 1 file changed, 1 deletion(-)</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>\r\n<p>现在，文件就从版本库中被删除了。</p>\r\n<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>\r\n<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\r\n<h2 id=\"远程仓库\">4.远程仓库</h2>\r\n<p>这个世界上有个叫<a\r\nhref=\"https://github.com/\">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>\r\n<p><strong>第1步：创建SSH\r\nKey</strong>。在用户主目录（windows1.在powershell：ssh-keygen -t rsa\r\n2.输入要保存密钥文件的路径和名称。例如：C:.ssh_rsa，可以选择保留默认名称，因为它已经被\r\nSSH\r\n所识别（id_rsa）3.在弹出的窗口中输入密码，或者直接敲击回车键选择不设置密码；\r\n4.得到公共密钥（id_rsa.pub）和一个私有密钥（id_rsa））下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git\r\nBash），创建SSH Key：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"string\">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>\r\n<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>\r\n<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH\r\nKey的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>\r\n<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>\r\n<p>然后，点“Add SSH\r\nKey”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容\r\n-&gt; 点“Add Key”，你就应该看到已经添加的Key</p>\r\n<p><strong>GitHub需要SSH\r\nKey：</strong>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。（类似电子签名，私钥签名，公钥验证）</p>\r\n<p>GitHub允许添加多个Key，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了</p>\r\n<p>在GitHub上免费托管的Git仓库，任何人都可以看到（但只有自己才能改），可以设置公开的仓库变成私有的</p>\r\n<p><strong>注：可以搭一个Git服务器，因为是你自己的Git服务器，相当简单，公司内部开发必备</strong></p>\r\n<h3 id=\"添加远程仓库\">添加远程仓库</h3>\r\n<p>已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>\r\n<p>Github创建仓库（首先，登陆GitHub，然后，在右上角找到“Create a new\r\nrepo”按钮，创建一个新的仓库）</p>\r\n<p>在<strong>Repository\r\nname</strong>填入<code>learngit</code>，其他保持默认设置，点击“Create\r\nrepository”按钮，就成功地创建了一个新的Git仓库</p>\r\n<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\r\n<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git remote add origin git@github.com:自己的用户名/learngit.git</span></span><br></pre></td></tr></table></figure>\r\n<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>\r\n<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git push -u origin master</span></span><br></pre></td></tr></table></figure>\r\n<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>\r\n<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\r\n<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>\r\n<p>从现在起，只要本地作了提交，就可以通过命令：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git push origin master</span></span><br></pre></td></tr></table></figure>\r\n<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>\r\n<p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class=\"line\">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>\r\n<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>\r\n<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>\r\n<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>\r\n<h3 id=\"删除远程仓库\">删除远程仓库</h3>\r\n<p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git remote -v</span></span><br><span class=\"line\">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class=\"line\">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure>\r\n<p>然后，根据名字删除，比如删除<code>origin</code>：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git remote <span class=\"built_in\">rm</span> origin</span></span><br></pre></td></tr></table></figure>\r\n<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>\r\n","categories":["进厂学习记录"],"tags":["git用法","编程素养","算法"]},{"title":"Day5","url":"/2024/04/09/Day5/","content":"<h1 id=\"规划\">规划</h1>\r\n<p>上一次写博客还在上次，3月底规划了一下清明节假期的旅行计划，最终确定和睿睿一起去了南京。读万卷书，行万里路。去了明朝的旧京都，碰巧的是这段时间一直在读《明朝那些事儿》。从宏观上看，没有任何人建立的模型可以理想化的存在下去，个人的行为改变不了历史的洪流，同时感慨中国古代的能人异士浩如烟海，能在历史这本书上留名的也不计其数；从微观上看，朱家皇帝所做的一切努力都是在历史这个大模型下的涓涓细流，这细流恰是对当前统治的一种映射，对当朝现状的一种映射。对我最大的启发不仅在于感慨历史的有趣，更多的是让我知道仅靠仁德，仁心，仁义是无法取得一个很高的成就的，对比现在的很多学子都带着严重的学生思维，可是社会是残酷的，面对残酷的社会，要展示出自己的手段，才能一步步走到理想的位置。</p>\r\n<p>此外，《沉思录》中提到：“我们听到的一切都是一个观点，不是事实。我们看见的一切都是一个视角，不是真相。”要可以静下心来思考，去用心感受，体会内涵，才能接触到事物的本质，正如<strong>递归思想</strong>，不断调用自己，思考层层调用的含义，最后才会触底反弹，一切都恍然大悟。</p>\r\n<p>昨天突然意识到不能这么漫无目的没有规划的学下去了，需要做点最近的规划，以便减少内心焦虑，规划的方向如下：</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"毕设\">毕设</h2>\r\n<p>毕设主要是两部分：最后方案的仿真 +\r\n毕设论文的撰写，两部分同步进行，一边在仿真一边写毕设论文</p>\r\n<p>方案仿真：仿真结合蚁群算法的AODV协议 -&gt; 缝合结合安全属性的AODV协议\r\n-&gt; 二者缝合在一起</p>\r\n<p>参考几篇重点论文的缝合方案，数据结果，将结果导向理想的方向。</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 13%\" />\r\n<col style=\"width: 43%\" />\r\n<col style=\"width: 43%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">时间安排</th>\r\n<th style=\"text-align: center;\">任务计划1</th>\r\n<th style=\"text-align: center;\">任务计划2</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">4.10 — 4.16</td>\r\n<td style=\"text-align: center;\">完成结合蚁群算法的AODV协议仿真</td>\r\n<td style=\"text-align: center;\">搭建毕设论文框架 + 写完背景介绍</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">4.16 — 4.22</td>\r\n<td\r\nstyle=\"text-align: center;\"><strong>完成缝合安全数学的AODV协议仿真</strong></td>\r\n<td style=\"text-align: center;\">写完毕设论文基础知识与改进核心内容</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">4.22 —4.28</td>\r\n<td style=\"text-align: center;\">缝合二者结合，实现理想结果</td>\r\n<td style=\"text-align: center;\">完善毕设论文基础知识与改进核心内容</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"实习\">实习</h2>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 12%\" />\r\n<col style=\"width: 31%\" />\r\n<col style=\"width: 56%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">时间安排</th>\r\n<th style=\"text-align: center;\">任务计划1</th>\r\n<th style=\"text-align: center;\">任务计划2</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">4.10 — 4.16</td>\r\n<td style=\"text-align: center;\">二叉树专题 + 总结</td>\r\n<td\r\nstyle=\"text-align: center;\">背诵学习：Java基础、集合、并发、面向对象和设计模式</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">4.16 — 4.22</td>\r\n<td style=\"text-align: center;\">回溯/贪心算法常见问题 + 总结</td>\r\n<td style=\"text-align: center;\">背诵学习：MySQL Redis常见问题内容</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">4.22 —4.28</td>\r\n<td style=\"text-align: center;\">热门手撕面试题 + 背诵总结</td>\r\n<td style=\"text-align: center;\">背诵学习：Spring等一系列框架 +\r\n常用面试题</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/M5W592%24L8VJH4ERBINRBPSC.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h1 id=\"算法\">算法</h1>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240409214012675.png\"\r\nalt=\"image-20240409214012675\" />\r\n<figcaption aria-hidden=\"true\">image-20240409214012675</figcaption>\r\n</figure>\r\n<p>今日收获：</p>\r\n<p>学会非递归的方式实现二叉树的层次遍历，在层次遍历模版的基础上可以解决若干遍历问题</p>\r\n<p>非递归方式实现：</p>\r\n<p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p>\r\n<p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上</strong></p>\r\n<p>利用队列出入队，两层循环，分别是队列是否为空（到最后一层），和当前队列（同一层）是否遍历完成</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 102.二叉树的层序遍历</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">levelOrder</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//checkFun01(root,0);</span></span><br><span class=\"line\">        checkFun02(root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> resList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//DFS--递归方式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFun01</span><span class=\"params\">(TreeNode node, Integer deep)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        deep++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resList.size() &lt; deep) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class=\"line\">            List&lt;Integer&gt; item = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">            resList.add(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resList.get(deep - <span class=\"number\">1</span>).add(node.val);</span><br><span class=\"line\"></span><br><span class=\"line\">        checkFun01(node.left, deep);</span><br><span class=\"line\">        checkFun01(node.right, deep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//BFS--迭代方式--借助队列</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFun02</span><span class=\"params\">(TreeNode node)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        que.offer(node);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; itemList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> que.size();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//遍历每一层</span></span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">tmpNode</span> <span class=\"operator\">=</span> que.poll();<span class=\"comment\">//poll方法</span></span><br><span class=\"line\">                itemList.add(tmpNode.val);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmpNode.left != <span class=\"literal\">null</span>) que.offer(tmpNode.left);<span class=\"comment\">//offer方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmpNode.right != <span class=\"literal\">null</span>) que.offer(tmpNode.right);</span><br><span class=\"line\">                len--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            resList.add(itemList);<span class=\"comment\">//将每一层的遍历结果添加</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>额外看到一道括号匹配的题：</p>\r\n<p><strong>括号匹配是使用栈解决的经典问题。</strong>题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。编译原理中提到：编译器在\r\n词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。</p>\r\n<p>再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd a/b/c/../../</span><br></pre></td></tr></table></figure>\r\n<p>这个命令最后进入a目录，系统是如何知道进入了a目录呢\r\n，这就是栈的应用</p>\r\n<p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return\r\nfalse</p>\r\n<p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return\r\nfalse</p>\r\n<p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return\r\nfalse</p>\r\n<p>只有这三种return false</p>\r\n<p>基本思想：其他情况，遇到左括号压相应的右括号到栈中，直到遇到第一个右括号，此时逐个弹栈，对比和刚才压入栈中的右括号是否一致，注意：<strong>如果栈空了或者不一致</strong>，则直接返回false即可，最后的返回结果是栈是否为空</p>\r\n<h1 id=\"毕设-1\">毕设</h1>\r\n<p>总结了几篇结构相似/内容研究方向相同的文章，写完了自己论文的目录部分和各个部分要写什么内容的提纲，明天开始动笔写绪论</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240409213915559.png\"\r\nalt=\"image-20240409213915559\" />\r\n<figcaption aria-hidden=\"true\">image-20240409213915559</figcaption>\r\n</figure>\r\n","categories":["进厂学习记录"],"tags":["规划","二叉树算法","毕业设计"]},{"title":"Day7","url":"/2024/04/20/Day7/","content":"<h1 id=\"算法\">算法</h1>\r\n<p>这几天努了努力，把代码随想录的二叉树专题全刷完了：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240419210357930.png\"\r\nalt=\"image-20240419210357930\" />\r\n<figcaption aria-hidden=\"true\">image-20240419210357930</figcaption>\r\n</figure>\r\n<p>简单按照网站中(<a\r\nhref=\"https://www.programmercarl.com/周总结/20201017二叉树周末总结.html#周一\">二叉树系列</a>)总结一下这几天刷的二叉树内容，然后对二叉树专题进行一个大总结。</p>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>合并两个二叉树时，平时我们都习惯了操作一个二叉树，一起操作两个树可能还有点陌生。其实套路是一样，只不过一起操作两个树，递归法还是同样的原理，无非是两个树同时开始比较；</p>\r\n<p><strong>迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</strong></p></li>\r\n<li><p>涉及到二叉搜索树（Binary Search Tree，BST）\r\n，开始要换一个思路了，大多是二叉搜索树的题目，其实都离不开<strong>中序遍历</strong>，因为这样就是有序的，迭代法在处理某些情况也是很简单的，因为之间对比数值即可以控制root的左右变化</p></li>\r\n<li><p>如果在验证BST的时候：首先在此强调一下二叉搜索树的特性：</p>\r\n<ul>\r\n<li>节点的左子树只包含小于当前节点的数。</li>\r\n<li>节点的右子树只包含大于当前节点的数。</li>\r\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\r\n</ul>\r\n<p>涉及到BST的陷阱：<strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>，而是左子树<strong>都</strong>小于中间节点，右子树<strong>都</strong>大于中间节点，因为有可能左子树的右节点比左子树本身的节点大这种情况。</p>\r\n<p>推荐要通过中序遍历（得到有序数组），然后记录前一个数值（pre）和后一个数值比较（cur），得出最值。</p>\r\n<p><strong>在二叉树中通过两个前后指针作比较，会经常用到</strong>。</p></li>\r\n<li><p>在求众数集合的时候有一个技巧，因为题目中众数是可以有多个的，所以一般的方法需要<strong>遍历两遍</strong>才能求出众数的集合。</p>\r\n<p><strong>但可以遍历一遍就可以求众数集合，使用了适时清空结果集的方法</strong>，这个方法还是很巧妙的。</p></li>\r\n<li><p>公共祖先问题：<strong>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者\r\n左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong>此外，实现从底向上遍历判断最好的方式是：<strong>后序遍历</strong></p></li>\r\n</ol>\r\n<h2 id=\"二叉树专题总结\">二叉树专题总结</h2>\r\n<p>到现在已经刷了30+二叉树经典题目，在每一道二叉树的题目中，使用递归三部曲来分析题目，看到二叉树，看到递归，都会想：<strong>返回值、参数是什么？终止条件是什么？单层逻辑是什么？</strong></p>\r\n<ul>\r\n<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>\r\n<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li>\r\n<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>\r\n</ul>\r\n<p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯<strong>求深度</strong>就用前序，<a\r\nhref=\"https://programmercarl.com/0257.二叉树的所有路径.html\">二叉树：找所有路径\r\n(opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/20211030125421.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>随记：刷二叉树专题最后的时候，一直都比较晕晕的，每次遇到递归的时候，都要看着具体例子走一遍才能理解，不能做到深入浅出，宏观上把握，微观上约束，现在有点陷入微观上观察解题，而不注重回归递归的本质，还需要多做题，多总结。</p>\r\n<p>此外，刷题也有一段时间了，今天浅看了一下已经刷了65道题了，数量见长的同时遗忘也随之而来，这就是没有做到及时总结的坏处，总是现看现总结，学过了就过了，没有做到很好地整理、反思、记录、总结，这是非常非常重要的，也是很贴合我自己的学习方法，需要坚持总结，坚持复盘，才能行稳致远。</p>\r\n<h1 id=\"毕设\">毕设</h1>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240419205929107.png\"\r\nalt=\"image-20240419205929107\" />\r\n<figcaption aria-hidden=\"true\">image-20240419205929107</figcaption>\r\n</figure>\r\n<p>目前毕设初稿已经基本完成，基本的逻辑框架和核心内容均已写完，预测总页数达到60余页。</p>\r\n<p>尚未完成：</p>\r\n<ul>\r\n<li>绪论中研究工作部分，比较麻烦，一直没来得及整理研究工作的逻辑和发展；</li>\r\n<li>文章中几乎所有的图片，都需要重制，保证清晰度，尽可能使用矢量图；</li>\r\n<li>最后的实验仿真结果，也是最复杂的地方，还没完成实验仿真，也没法进行结果分析</li>\r\n</ul>\r\n","categories":["进厂学习记录"],"tags":["二叉树算法","毕业设计","Maven"]},{"title":"Day6","url":"/2024/04/17/Day6/","content":"<p>最近几天，每天的基本工作就是写毕设paper，同时做毕设实验，最后就是刷算法题，学习一下JavaWeb和背一下八股。</p>\r\n<p>基本安排和内容都是这样，比较忙和紧张，\r\n没有做到每天都总结，总结一下最近学的内容。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"算法\">算法</h1>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240416214750331.png\"\r\nalt=\"image-20240416214750331\" />\r\n<figcaption aria-hidden=\"true\">image-20240416214750331</figcaption>\r\n</figure>\r\n<p>这是最近一段时间做的算法题，主要都是二叉树的相关内容，总结内容和结构如下：</p>\r\n<p>1.红黑树和二叉平衡搜索树弄分开了，其实红黑树就是一种二叉平衡搜索树，这两个树不是独立的，所以C++中map、multimap、set、multiset的底层实现机制是二叉平衡搜索树，再具体一点是红黑树。</p>\r\n<p>2.二叉树的顺序遍历（前序、中序、后序）分为：递归和迭代遍历，迭代是利用栈这一数据结构模拟递归的思想；层次遍历分为：迭代和递归，迭代是最常见和实用的，利用队列先进先出特点。</p>\r\n<p>3.递归 VS\r\n迭代在实现迭代法的过程中，有同学问了：递归与迭代究竟谁优谁劣呢？从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。递归更容易让程序员理解，但收敛不好，容易栈溢出。这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。</p>\r\n<p><strong>在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。</strong></p>\r\n<p>4.涉及到二叉树的遍历问题（Maybe隐含的，如翻转二叉树，对称二叉树，求深度/高度），一定要弄清用哪种遍历方法，不同问题用的不同顺序是不一样的；<strong>一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代</strong></p>\r\n<p>5.在<a\r\nhref=\"https://programmercarl.com/0257.二叉树的所有路径.html\">二叉树：找我的所有路径？\r\n(opens new\r\nwindow)</a>中正式涉及到了回溯，回溯和递归都是相伴相生的，涉及到路径的问题（需要二叉树的节点返回出来结果时），就要回溯了！<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong></p>\r\n<p>6.递归函数什么时候需要返回值？什么时候不需要返回值？一般情况下：<strong>如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</strong></p>\r\n<p>这里总结如下三点：</p>\r\n<ul>\r\n<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况是113.路径总和II）</li>\r\n<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。\r\n（这种情况我们在<a\r\nhref=\"https://programmercarl.com/0236.二叉树的最近公共祖先.html\">236.\r\n二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>\r\n<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112.路径总和的情况）</li>\r\n</ul>\r\n<p>7.习惯了利用节点自身属性判断节点特征时，平时习惯了使用通过节点的左右孩子判断本节点的属性，但发现使用这个思路无法判断左叶子。此时需要相连的三层之间构成的约束条件，也就是要通过节点的父节点以及孩子节点来判断本节点的属性。</p>\r\n<p>8.在构造二叉树时，<strong>有三个注意的点：</strong></p>\r\n<ul>\r\n<li>分割时候，坚持区间不变量原则，左闭右开，或者左闭又闭。</li>\r\n<li>分割的时候，注意后序 或者\r\n前序已经有一个节点作为中间节点了，不能继续使用了。</li>\r\n<li>如何使用切割后的后序数组来切合中序数组？利用中序数组大小一定是和后序数组的大小相同这一特点来进行切割。</li>\r\n</ul>\r\n<p>9.注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过<strong>下标索引直接在原数组上</strong>操作，这样可以节约时间和空间上的开销。</p>\r\n<p>10.一般情况来说：如果让<strong>空节点（空指针）进入递归，就不加if</strong>，如果<strong>不让空节点进入递归，就加if限制一下</strong>，\r\n终止条件也会相应的调整。</p>\r\n<h1 id=\"毕设\">毕设</h1>\r\n<p>目前毕业论文有效内容已经写了30余页：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240416220125695.png\"\r\nalt=\"image-20240416220125695\" />\r\n<figcaption aria-hidden=\"true\">image-20240416220125695</figcaption>\r\n</figure>\r\n<p>但是最后实验仿真和性能分析的部分害没有做出来，甚至设计都是一个很困难的问题，希望快点搞出来吧</p>\r\n<h1 id=\"其他\">其他</h1>\r\n<p>学习 and\r\n复习了Web前端开发的基础知识，如Web后端开发的基础(HTTP协议、请求响应)，并且也复习了数据库MySQL，以及通过Mybatis框架如何来完成数据库的基本操作。</p>\r\n<p>还没学到案例部分，接下来学习的就是就通过一个案例（智能学习系统），来将前端开发、后端开发、数据库整合起来，涉及到SpringBootWeb的案例、登录认证、AOP等知识。</p>\r\n","categories":["进厂学习记录"],"tags":["二叉树算法","毕业设计"]},{"title":"Day4","url":"/2024/03/27/Day4/","content":"<h1 id=\"前言\">前言</h1>\r\n<p>最近这几天忙着毕业设计的中期答辩和一些形式工作，昨天和今天刚刚抽出时间来学习进厂知识，昨天刷了力扣的几道数组题，今天继续刷了链表的部分题，还有就是看了看外卖项目内容，感觉进度艰难，一些地方听不懂，而且学习的不系统，所以打算写完上次课的项目内容，从下次开始先暂停一下项目内容，先把基础的框架学一下，在JavaWeb开发篇中学习基础框架包括但不限于：<strong>SpringBoot、MySQL、Mybatis</strong>等，先把基础的框架弄明白，可能再去看项目会收获更大。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"项目开发\">项目开发</h1>\r\n<p>接着上次，写完了新增员工，该写员工分页查询了</p>\r\n<h2 id=\"员工分页查询\">员工分页查询</h2>\r\n<h3 id=\"产品原型\">产品原型</h3>\r\n<p><strong>查询员工原型：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221111215309289.png\" alt=\"image-20221111215309289\" style=\"zoom: 67%;\" /></p>\r\n<p><strong>业务规则</strong>：</p>\r\n<ul>\r\n<li>根据页码展示员工信息</li>\r\n<li>每页展示10条数据</li>\r\n<li>分页查询时可以根据需要，输入员工姓名进行查询</li>\r\n</ul>\r\n<h3 id=\"代码开发\">代码开发</h3>\r\n<h4\r\nid=\"设置数据类型dto类主要是数据类型类的参数封装pageresult后面所有的分页查询统一都封装为pageresult对象\">1.设置数据类型——DTO类（主要是数据类型，类的参数），封装<strong>PageResult</strong>，后面所有的分页查询，统一都封装为PageResult对象</h4>\r\n<p>根据请求参数进行封装，在<em>sky-pojo模块</em>中</p>\r\n<p>在<em>sky-common模块</em>，封装PageResult对象，参数为</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> total; <span class=\"comment\">//总记录数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List records; <span class=\"comment\">//当前页数据集合</span></span><br></pre></td></tr></table></figure>\r\n<p>员工信息分页查询后端返回的对象类型为: Result<PageResult></p>\r\n<h4\r\nid=\"controllerservicemapper层实现\">2.Controller、Service、Mapper层实现</h4>\r\n<p>在sky-server模块中，com.sky.controller.admin.EmployeeController中添加分页查询方法。</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 员工分页查询</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeePageQueryDTO</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@GetMapping(&quot;/page&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@ApiOperation(&quot;员工分页查询&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Result&lt;PageResult&gt; <span class=\"title function_\">page</span><span class=\"params\">(EmployeePageQueryDTO employeePageQueryDTO)</span>&#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;员工分页查询，参数为：&#123;&#125;&quot;</span>, employeePageQueryDTO);</span><br><span class=\"line\">       <span class=\"type\">PageResult</span> <span class=\"variable\">pageResult</span> <span class=\"operator\">=</span> employeeService.pageQuery(employeePageQueryDTO);<span class=\"comment\">//后续定义</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.success(pageResult);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p>在EmployeeService接口中声明<strong>pageQuery</strong>方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 分页查询</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeePageQueryDTO</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   PageResult <span class=\"title function_\">pageQuery</span><span class=\"params\">(EmployeePageQueryDTO employeePageQueryDTO)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>接口声明以后要实现：</p>\r\n<p>在EmployeeServiceImpl中实现pageQuery方法：</p>\r\n<p>在EmployeeServiceImpl中实现pageQuery方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 分页查询</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeePageQueryDTO</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> PageResult <span class=\"title function_\">pageQuery</span><span class=\"params\">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// select * from employee limit 0,10</span></span><br><span class=\"line\">       <span class=\"comment\">//开始分页查询</span></span><br><span class=\"line\">       PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());</span><br><span class=\"line\"></span><br><span class=\"line\">       Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);<span class=\"comment\">//后续定义</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> page.getTotal();</span><br><span class=\"line\">       List&lt;Employee&gt; records = page.getResult();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PageResult</span>(total, records);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>注意：</strong>此处使用 mybatis 的分页插件\r\n<strong>PageHelper</strong>\r\n来简化分页代码的开发（在pom.xml文中添加依赖），底层基于 mybatis\r\n的拦截器实现。</p>\r\n<p>Mapper层：</p>\r\n<p>在 EmployeeMapper 中声明 pageQuery 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 分页查询</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeePageQueryDTO</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   Page&lt;Employee&gt; <span class=\"title function_\">pageQuery</span><span class=\"params\">(EmployeePageQueryDTO employeePageQueryDTO)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>在 src/main/resources/mapper/EmployeeMapper.xml 中编写SQL：</p>\r\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">&lt;</span><span class=\"keyword\">select</span> id<span class=\"operator\">=</span>&quot;pageQuery&quot; resultType<span class=\"operator\">=</span>&quot;com.sky.entity.Employee&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> employee</span><br><span class=\"line\">        <span class=\"operator\">&lt;</span><span class=\"keyword\">where</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;name != null and name != &#x27;&#x27;&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">                <span class=\"keyword\">and</span> name <span class=\"keyword\">like</span> concat(<span class=\"string\">&#x27;%&#x27;</span>,#&#123;name&#125;,<span class=\"string\">&#x27;%&#x27;</span>)</span><br><span class=\"line\">            <span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">where</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> create_time <span class=\"keyword\">desc</span></span><br><span class=\"line\">    <span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">select</span><span class=\"operator\">&gt;</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"代码完善\">代码完善</h3>\r\n<p>发现问题：</p>\r\n<ol type=\"1\">\r\n<li>在前后端联调和Swagger测试（接口文档）时，发现操作时间格式不正确，</li>\r\n</ol>\r\n<p><strong>解决方式：</strong></p>\r\n<p><strong>1). 方式一</strong></p>\r\n<p>在属性上加上注解，对日期进行格式化</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221112103501581.png\" alt=\"image-20221112103501581\" style=\"zoom:67%;\" /></p>\r\n<p>但这种方式，需要在每个时间属性上都要加上该注解，使用较麻烦，不能全局处理。</p>\r\n<p><strong>2). 方式二（推荐 )</strong></p>\r\n<p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对所有的日期类型进行格式处理</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 扩展Spring MVC框架的消息转化器</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> converters</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">extendMessageConverters</span><span class=\"params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;扩展消息转换器...&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//创建一个消息转换器对象</span></span><br><span class=\"line\">       <span class=\"type\">MappingJackson2HttpMessageConverter</span> <span class=\"variable\">converter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MappingJackson2HttpMessageConverter</span>();</span><br><span class=\"line\">       <span class=\"comment\">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span></span><br><span class=\"line\">       converter.setObjectMapper(<span class=\"keyword\">new</span> <span class=\"title class_\">JacksonObjectMapper</span>());</span><br><span class=\"line\">       <span class=\"comment\">//将自己的消息转化器加入容器中，设置index为0，优先级很高</span></span><br><span class=\"line\">       converters.add(<span class=\"number\">0</span>,converter);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p>添加后，再次测试，发现日期正常</p>\r\n<h2 id=\"启用禁用员工账号\">启用/禁用员工账号</h2>\r\n<h3 id=\"代码开发-1\">代码开发</h3>\r\n<p><strong>启禁用员工原型：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221112112359233.png\" alt=\"image-20221112112359233\" style=\"zoom:67%;\" /></p>\r\n<p><strong>业务规则：</strong></p>\r\n<ul>\r\n<li>可以对状态为“启用” 的员工账号进行“禁用”操作</li>\r\n<li>可以对状态为“禁用”的员工账号进行“启用”操作</li>\r\n<li>状态为“禁用”的员工账号不能登录系统</li>\r\n</ul>\r\n<h4 id=\"controller层\">1.Controller层</h4>\r\n<p>在sky-server模块中，根据接口设计中的请求参数形式对应的在\r\nEmployeeController 中创建启用禁用员工账号的方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 启用禁用员工账号</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> status</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@ApiOperation(&quot;启用禁用员工账号&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Result <span class=\"title function_\">startOrStop</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer status,Long id)</span>&#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;启用禁用员工账号：&#123;&#125;,&#123;&#125;&quot;</span>,status,id);</span><br><span class=\"line\">       employeeService.startOrStop(status,id);<span class=\"comment\">//后绪步骤定义</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.success();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"service层接口和实现类\">2.Service层接口和实现类</h4>\r\n<p>在 EmployeeService 接口中声明启用禁用员工账号的业务方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 启用禁用员工账号</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> status</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">startOrStop</span><span class=\"params\">(Integer status, Long id)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>在 EmployeeServiceImpl 中实现启用禁用员工账号的业务方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 启用禁用员工账号</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> status</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startOrStop</span><span class=\"params\">(Integer status, Long id)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> Employee.builder()</span><br><span class=\"line\">               .status(status)</span><br><span class=\"line\">               .id(id)</span><br><span class=\"line\">               .build();</span><br><span class=\"line\"></span><br><span class=\"line\">       employeeMapper.update(employee);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"mapper层\">3.Mapper层</h4>\r\n<p>在 EmployeeMapper 接口中声明 update 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 根据主键动态修改属性</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employee</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Employee employee)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>在 EmployeeMapper.xml 中编写SQL：</p>\r\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">&lt;</span><span class=\"keyword\">update</span> id<span class=\"operator\">=</span>&quot;update&quot; parameterType<span class=\"operator\">=</span>&quot;Employee&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">update</span> employee</span><br><span class=\"line\">        <span class=\"operator\">&lt;</span><span class=\"keyword\">set</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;name != null&quot;<span class=\"operator\">&gt;</span>name <span class=\"operator\">=</span> #&#123;name&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;username != null&quot;<span class=\"operator\">&gt;</span>username <span class=\"operator\">=</span> #&#123;username&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;password != null&quot;<span class=\"operator\">&gt;</span>password <span class=\"operator\">=</span> #&#123;password&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;phone != null&quot;<span class=\"operator\">&gt;</span>phone <span class=\"operator\">=</span> #&#123;phone&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;sex != null&quot;<span class=\"operator\">&gt;</span>sex <span class=\"operator\">=</span> #&#123;sex&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;idNumber != null&quot;<span class=\"operator\">&gt;</span>id_Number <span class=\"operator\">=</span> #&#123;idNumber&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;updateTime != null&quot;<span class=\"operator\">&gt;</span>update_Time <span class=\"operator\">=</span> #&#123;updateTime&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;updateUser != null&quot;<span class=\"operator\">&gt;</span>update_User <span class=\"operator\">=</span> #&#123;updateUser&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            <span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;status != null&quot;<span class=\"operator\">&gt;</span>status <span class=\"operator\">=</span> #&#123;status&#125;,<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">set</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> #&#123;id&#125;</span><br><span class=\"line\">    <span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">update</span><span class=\"operator\">&gt;</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"编辑员工信息\">编辑员工信息</h2>\r\n<h3 id=\"代码开发-2\">代码开发</h3>\r\n<p><strong>修改页面原型</strong>：</p>\r\n<p>注：点击修改时，数据应该正常回显到修改页面。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221112144842825.png\" alt=\"image-20221112144842825\" style=\"zoom: 67%;\" /></p>\r\n<h4 id=\"回显员工信息功能\">1.回显员工信息功能</h4>\r\n<p><strong>1). Controller层</strong></p>\r\n<p>在 EmployeeController 中创建 getById 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 根据id查询员工信息</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@ApiOperation(&quot;根据id查询员工信息&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Result&lt;Employee&gt; <span class=\"title function_\">getById</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Long id)</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> employeeService.getById(id);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.success(employee);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p>通过id查询</p>\r\n<p><strong>2). Service层接口和实现类</strong></p>\r\n<p>在 EmployeeService 接口中声明 getById 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据id查询员工</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Employee <span class=\"title function_\">getById</span><span class=\"params\">(Long id)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>在 EmployeeServiceImpl 中实现 getById 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 根据id查询员工</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Employee <span class=\"title function_\">getById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> employeeMapper.getById(id);</span><br><span class=\"line\">      employee.setPassword(<span class=\"string\">&quot;****&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> employee;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>3). Mapper层</strong></p>\r\n<p>在 EmployeeMapper 接口中声明 getById 方法：通过注解实现</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 根据id查询员工信息</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)</span></span><br><span class=\"line\">   Employee <span class=\"title function_\">getById</span><span class=\"params\">(Long id)</span>;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"修改员工信息功能\">2 修改员工信息功能</h4>\r\n<p><strong>1). Controller层</strong></p>\r\n<p>在 EmployeeController 中创建 update 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 编辑员工信息</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> employeeDTO</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">   <span class=\"meta\">@ApiOperation(&quot;编辑员工信息&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Result <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;编辑员工信息：&#123;&#125;&quot;</span>, employeeDTO);</span><br><span class=\"line\">       employeeService.update(employeeDTO);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.success();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>2). Service层接口</strong></p>\r\n<p>在 EmployeeService 接口中声明 update 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 编辑员工信息</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> employeeDTO</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(EmployeeDTO employeeDTO)</span>;</span><br></pre></td></tr></table></figure>\r\n<p><strong>3). Service层实现类</strong></p>\r\n<p>在 EmployeeServiceImpl 中实现 update 方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 编辑员工信息</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> employeeDTO</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Employee</span> <span class=\"variable\">employee</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">      <span class=\"comment\">//因为是DTO类型的，需要把参数赋给employee</span></span><br><span class=\"line\">      BeanUtils.copyProperties(employeeDTO, employee);</span><br><span class=\"line\"></span><br><span class=\"line\">      employee.setUpdateTime(LocalDateTime.now());</span><br><span class=\"line\">      employee.setUpdateUser(BaseContext.getCurrentId());</span><br><span class=\"line\"></span><br><span class=\"line\">      employeeMapper.update(employee);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\r\n<p>在实现<strong>启用禁用员工账号</strong>功能时，已实现employeeMapper.<strong>update</strong>(employee)，在此不需写Mapper层代码，只需要传进去参数。</p>\r\n<h1 id=\"算法\">算法</h1>\r\n<p><strong>数组篇</strong></p>\r\n<p><a href=\"https://www.programmercarl.com/\">代码随想录\r\n(programmercarl.com)</a></p>\r\n<h2 id=\"二分查找\">704.二分查找</h2>\r\n<p><a\r\nhref=\"https://leetcode.cn/problems/binary-search/\">力扣题目链接(opens\r\nnew window)</a></p>\r\n<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target\r\n，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回\r\n-1。</p>\r\n<h3 id=\"思路\">思路</h3>\r\n<p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>\r\n<p>对于二分法，需要定义mid的前后两个区间，区间的定义就是不变量。要在二分查找的过程中，<strong>保持不变量</strong>，就是在while寻找中<strong>每一次边界的处理</strong>都要坚持根据区间的定义来操作，这就是循环不变量规则。</p>\r\n<p>写二分法，区间的定义一般为两种，左闭右闭即[left,\r\nright]，或者左闭右开即[left, right)</p>\r\n<ol type=\"1\">\r\n<li>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left,\r\nright]区间，所以有如下两点：</strong></li>\r\n</ol>\r\n<ul>\r\n<li>while (left &lt;= right) 要使用 &lt;= ，因为left ==\r\nright是有意义的，所以使用 &lt;=</li>\r\n<li>if (nums[middle] &gt; target) right 要赋值为 middle -\r\n1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是\r\nmiddle - 1</li>\r\n</ul>\r\n<ol start=\"2\" type=\"1\">\r\n<li>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right)\r\n，那么二分法的边界处理方式则截然不同。</li>\r\n</ol>\r\n<ul>\r\n<li>while (left &lt; right)，这里使用 &lt; ,因为left ==\r\nright在区间[left, right)是没有意义的</li>\r\n<li>if (nums[middle] &gt; target) right 更新为\r\nmiddle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>\r\n</ul>\r\n<h3 id=\"代码\">代码</h3>\r\n<p><strong>版本一</strong>：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">search</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &lt; nums[<span class=\"number\">0</span>] || target &gt; nums[nums.length - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target)</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>版本二</strong>：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">search</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target)</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"移除元素\">27.移除元素</h2>\r\n<h3 id=\"思路-1\">思路</h3>\r\n<p><a\r\nhref=\"https://leetcode.cn/problems/remove-element/\">力扣题目链接(opens\r\nnew window)</a></p>\r\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val\r\n的元素，并返回移除后数组的新长度。</p>\r\n<p>不要使用额外的数组空间，你必须仅使用 O(1)\r\n额外空间并<strong>原地</strong>修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\r\n<p><strong>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p>\r\n<p>暴力破解：两层循环，一个for循环遍历数组元素\r\n，第二个for循环更新数组</p>\r\n<p><strong>双指针法</strong>：</p>\r\n<p>双指针法（快慢指针法）：\r\n<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>\r\n<p>定义快慢指针</p>\r\n<ul>\r\n<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>\r\n<li>慢指针：指向更新 新数组下标的位置</li>\r\n</ul>\r\n<p>很多同学这道题目做的很懵，就是不理解\r\n快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。</p>\r\n<p>删除过程如下：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/27.%25E7%25A7%25BB%25E9%2599%25A4%25E5%2585%2583%25E7%25B4%25A0-%25E5%258F%258C%25E6%258C%2587%25E9%2592%2588%25E6%25B3%2595.gif\"\r\nalt=\"27.移除元素-双指针法\" />\r\n<figcaption aria-hidden=\"true\">27.移除元素-双指针法</figcaption>\r\n</figure>\r\n<p>很多同学不了解</p>\r\n<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>\r\n<h3 id=\"代码-1\">代码</h3>\r\n<p><strong>快慢指针法</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">removeElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 快慢指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">slowIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">fastIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[fastIndex] != val) &#123;</span><br><span class=\"line\">                nums[slowIndex] = nums[fastIndex];</span><br><span class=\"line\">                slowIndex++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slowIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>相向指针法</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相向双指针法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">removeElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &gt;= <span class=\"number\">0</span> &amp;&amp; nums[right] == val) right--; <span class=\"comment\">//将right移到从右数第一个值不为val的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[left] == val) &#123; <span class=\"comment\">//left位置的元素需要移除</span></span><br><span class=\"line\">                <span class=\"comment\">//将right位置的元素移到left（覆盖），right位置移除</span></span><br><span class=\"line\">                nums[left] = nums[right];</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(right &gt;= <span class=\"number\">0</span> &amp;&amp; nums[right] == val) right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"有序数组的平方\">27.有序数组的平方</h2>\r\n<h3 id=\"思路-2\">思路</h3>\r\n<p><a\r\nhref=\"https://leetcode.cn/problems/squares-of-a-sorted-array/\">力扣题目链接(opens\r\nnew window)</a></p>\r\n<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方\r\n组成的新数组，要求也按 非递减顺序 排序。</p>\r\n<p><strong>暴力：</strong>每个数平方之后，排个序，代码如下：</p>\r\n<p><strong>双指针法：</strong></p>\r\n<p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>\r\n<p>那么数组平方的<strong>最大值就在数组的两端</strong>，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>\r\n<p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p>\r\n<p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code>\r\n那么<code>result[k--] = A[j] * A[j];</code> 。</p>\r\n<p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code>\r\n那么<code>result[k--] = A[i] * A[i];</code> 。</p>\r\n<p><strong>从两端开始，太妙了</strong></p>\r\n<h3 id=\"代码-2\">代码</h3>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortedSquares(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] * nums[l] &gt; nums[r] * nums[r])&#123;</span><br><span class=\"line\">                res[j--] = nums[l] * nums[l++];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                res[j--] = nums[r] * nums[r--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>若不从两端开始，从中间开始，找到第一个负数在哪里，向两端逐渐把最小的平方数放进结果数组，然后再把剩下的数组内容平方加到result中：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortedSquares(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到负数的第一个坐标</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">negative</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                negative = i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, i = negative, j = negative + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> || j &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//理论上处理完一个指针，直接将剩下未处理的指针全部赋值即可，分两步</span></span><br><span class=\"line\">            <span class=\"comment\">//以下思路是合并处理两步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ans[index] = nums[j] * nums[j];</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == n) &#123;</span><br><span class=\"line\">                ans[index] = nums[i] * nums[i];</span><br><span class=\"line\">                --i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class=\"line\">                ans[index] = nums[i] * nums[i];</span><br><span class=\"line\">                --i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans[index] = nums[j] * nums[j];</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2\r\nid=\"在排序数组中查找元素的第一个和最后一个位置\">34.在排序数组中查找元素的第一个和最后一个位置</h2>\r\n<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值\r\n<code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>\r\n<p>如果数组中不存在目标值 <code>target</code>，返回\r\n<code>[-1, -1]</code>。</p>\r\n<p>你必须设计并实现时间复杂度为 <code>O(log n)</code>\r\n的算法解决此问题。</p>\r\n<h3 id=\"思路代码\">思路代码</h3>\r\n<p><strong>直接解法：</strong>直接遍历所有内容，记录start和end，如果找到了目标值，找到第一个为此值的index为start值，一直遍历直到记最后一个为此value的index为end值</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] searchRange(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>, end = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//不能先使用nums[0]，因为nums=[]就已经越界了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span> || nums[<span class=\"number\">0</span>] &gt; target || nums[nums.length-<span class=\"number\">1</span>]&lt; target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;start,end&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == target)&#123;</span><br><span class=\"line\">                end = i;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(start == - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    start = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;start,end&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>二分：</strong>两次二分法分别寻找start和end，第一次二分寻找start，找到target以后，记此次index为start，同时，<strong>右端区间变成此时index左边的（右端向左缩）</strong>，即区间右端不断向左缩达到二分，继续找左边有target的位置，一直到找到第一个；</p>\r\n<p>第二次二分找end，因为是要找最左区间向右缩，找到任何一个target，将左区间继续向右走，一直到找到最后一个target</p>\r\n<p>没找到target时与二分处理步骤一致</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] searchRange(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>, end = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//不能使用nums[0]，因为nums=[]就已经越界了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span> || nums[<span class=\"number\">0</span>] &gt; target || nums[nums.length - <span class=\"number\">1</span>] &lt; target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;start, end&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//寻找第一个位置,左区间不变，右区间一直在向左缩</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">                start = mid;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;<span class=\"comment\">//核心，一直向左缩，直到找到第一个target位置</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//寻找第二个位置，左区间一直向右靠</span></span><br><span class=\"line\">        left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        right = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">                end = mid;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;<span class=\"comment\">//核心</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;start, end&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"长度最小的子数组\">27.长度最小的子数组</h2>\r\n<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥\r\ns 的长度最小的 连续\r\n子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>\r\n<p>示例：</p>\r\n<ul>\r\n<li>输入：s = 7, nums = [2,3,1,2,4,3]</li>\r\n<li>输出：2</li>\r\n<li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>\r\n</ul>\r\n<h3 id=\"思路-3\">思路</h3>\r\n<p><strong>暴力解法：</strong>这道题目暴力解法当然是\r\n两个for循环，然后不断地寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p>\r\n<p><strong>双指针：（又为滑动窗口）</strong></p>\r\n<p>只用一个for循环，那么这个循环的索引，一定是表示\r\n滑动窗口的终止位置。</p>\r\n<ul>\r\n<li><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p></li>\r\n<li><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向0前移动了（也就是该缩小了）。</p></li>\r\n<li><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针00，也就是for循环里的索引。</p></li>\r\n</ul>\r\n<p>即看作是队列：</p>\r\n<p><code>[2,3,1,2,4,3]</code> 举例</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/10ca012c2f0170afcac5e5996add20c32c36a82f4bb4a6187897bb948ace5fe2-image.png\"\r\nalt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/2da8cf86a2a3df3c95ed7d95add574dca2d8bae8420addd0fa6b8c55fa3db081-image.png\"\r\nalt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>数组内的一直入队出队：</p>\r\n<p>起初一直入队，直到队列中的元素大于目标值了，记录此时的num数，才能出队</p>\r\n<p>出队以后如果总和小于目标值了，继续入队下一个数组元素，直到大于目标值，取此时num和之前num较小者</p>\r\n<p>直到所有数组元素完成，此时num就是最小长度的子数组</p>\r\n<h3 id=\"代码-3\">代码</h3>\r\n<p>快慢指针思想，是连续子数组，不是任意的数都可以</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length, slowIndex = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>, minLen = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">fastIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; fastIndex &lt; len; fastIndex++) &#123;</span><br><span class=\"line\">            sum += nums[fastIndex];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= target) &#123;</span><br><span class=\"line\">                minLen = Math.min(minLen, fastIndex - slowIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">                sum -= nums[slowIndex++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minLen == Integer.MAX_VALUE ? <span class=\"number\">0</span> : minLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["进厂学习记录"],"tags":["算法","SpringBoot","MySQL"]},{"title":"Day9","url":"/2024/04/26/Day9/","content":"<h1 id=\"算法\">算法</h1>\r\n<p>继续刷回溯专题的内容，今天效率有些低，就写了两道题，都是组合总和的题，在回溯中，很多剪枝技巧都是很妙的，可遇而不可求，需要记住，理解，在代码中体会。</p>\r\n<span id=\"more\"></span>\r\n<p>去重操作是很多题中必不可少的：需要理解去重的逻辑，在回溯/二叉树去重中，分清<strong>树层去重”和“树枝去重”</strong>，continue和break，去重和剪枝的区别，别搞混</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240425211918718.png\" /></p>\r\n<h1 id=\"开发\">开发</h1>\r\n<p>学习完了Spring\r\nMVC的基本内容，请求的最后部分——不同类型的参数，响应的相关注解，进一步学习了三层架构M\r\nV C</p>\r\n<p>控制层Controller、业务逻辑层Service、数据访问层Dao，学习了分层解耦IOC和DI的基本用法</p>\r\n<p>具体内容见JavaWeb文档 ~</p>\r\n<h1 id=\"毕设\">毕设</h1>\r\n<p>今天毕设的进度很少，仅仅把研究现状参考文献全部搞完，搞完数了数，一共50多篇参考文献，属实是有点多了，突出一个又臭又长的参考文献~</p>\r\n<p>至少学会了bibtex的一些使用，上次搞武大的latex代码时，xelatex-&gt;\r\npdftex -&gt;\r\nxelatex的编译，然后编译运行的操作学到了很多，所以在看xduts.pdf时也不会觉得懵逼，现在可以bibtex的正常编译了，在用xduts模版是：xe\r\n-&gt; bibter -&gt; xe</p>\r\n","categories":["进厂学习记录"],"tags":["算法","毕业设计","SpringBoot","回溯"]},{"title":"Hello World","url":"/2024/02/01/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very\r\nfirst post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in <a\r\nhref=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or\r\nyou can ask me on <a\r\nhref=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\r\n<h2 id=\"quick-start\">Quick Start</h2>\r\n<h3 id=\"create-a-new-post\">Create a new post</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\r\n<p>More info: <a\r\nhref=\"https://hexo.io/docs/writing.html\">Writing</a></p>\r\n<h3 id=\"run-server\">Run server</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\r\n<h3 id=\"generate-static-files\">Generate static files</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a\r\nhref=\"https://hexo.io/docs/generating.html\">Generating</a></p>\r\n<h3 id=\"deploy-to-remote-sites\">Deploy to remote sites</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a\r\nhref=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\r\n"},{"title":"JavaWeb开发","url":"/2024/03/20/JavaWeb%E5%BC%80%E5%8F%91/","content":"<h1 id=\"maven\">Maven</h1>\r\n<h2 id=\"maven入门\">1.Maven入门</h2>\r\n<h3 id=\"概述\">概述</h3>\r\n<p>Maven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。</p>\r\n<span id=\"more\"></span>\r\n<p><strong>Maven作用：</strong></p>\r\n<ol type=\"1\">\r\n<li><strong>依赖管理</strong></li>\r\n</ol>\r\n<ul>\r\n<li>方便快捷的管理项目依赖的资源(jar包)，避免引入大量的jar包，不同jar包之间的版本冲突问题</li>\r\n<li>当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。\r\n我们只需要在maven项目的pom.xml文件中，添加一段<dependency>依赖实现</li>\r\n</ul>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>统一项目结构</strong></li>\r\n</ol>\r\n<ul>\r\n<li>提供标准、统一的项目结构，使用不同的开发工具Eclipse或者IDEA创建项目工程时发现项目结构不一致，若创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：</li>\r\n</ul>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221130220539444.png\"\r\nalt=\"image-20221130220539444\" />\r\n<figcaption aria-hidden=\"true\">image-20221130220539444</figcaption>\r\n</figure>\r\n<p>统一结构为：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- src/main/java: java源代码目录</span><br><span class=\"line\">- src/main/resources:  配置文件信息</span><br><span class=\"line\">- src/test/java: 测试代码</span><br><span class=\"line\">- src/test/resources: 测试配置文件信息</span><br></pre></td></tr></table></figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li><strong>项目构建</strong></li>\r\n</ol>\r\n<p>maven提供了标准的、跨平台(Linux、Windows、MacOS)\r\n的自动化项目构建方式<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221130222907628.png\"\r\nalt=\"image-20221130222907628\" /></p>\r\n<ul>\r\n<li>Maven中的坐标是==资源的唯一标识== ,\r\n通过该坐标可以唯一定位资源位置</li>\r\n<li>使用坐标来定义项目或引入项目中需要的依赖</li>\r\n</ul>\r\n<p>坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置，坐标由:<groupld>、<artifactld>、<version>三个标签组成；</p>\r\n<ul>\r\n<li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li>\r\n<li>artifactId：定义当前Maven项目名称（通常是模块名称，例如\r\norder-service、goods-service）</li>\r\n<li>version：定义当前项目版本号</li>\r\n</ul>\r\n<p>依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包</p>\r\n<p>pom.xml文件中的坐标能找到所要的jar包，利用Maven<strong>仓库</strong></p>\r\n<h3 id=\"maven仓库\">Maven仓库</h3>\r\n<p>Maven仓库分为：</p>\r\n<ul>\r\n<li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li>\r\n<li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/</li>\r\n<li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li>\r\n</ul>\r\n<p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包</p>\r\n<ul>\r\n<li><p>如果有，则在项目直接引用</p></li>\r\n<li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库</p></li>\r\n</ul>\r\n<p>如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库\r\n--&gt; 远程仓库--&gt; 中央仓库</p>\r\n<p>由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p>\r\n<p>进入到conf目录下修改settings.xml配置文件即可（<strong>阿里云私服</strong>）==注:\r\n只可配置一个<mirror>(另一个要注释!)\r\n，不然两个可能发生冲突，导致jar包无法下载!!!!!!!==</p>\r\n<h2 id=\"maven项目\">2.Maven项目</h2>\r\n<blockquote>\r\n<ul>\r\n<li><p>Maven项目的目录结构:</p>\r\n<p>maven-project01 |--- src (源代码目录和测试代码目录) |--- main\r\n(源代码目录) |--- java (源代码java文件目录) |--- resources\r\n(源代码配置文件目录) |--- test (测试代码目录) |--- java\r\n(测试代码java目录) |--- resources (测试代码配置文件目录) |--- target\r\n(编译、打包生成文件存放目录)</p></li>\r\n</ul>\r\n</blockquote>\r\n<p>POM (Project Object Model)\r\n：指的是项目对象模型，用来描述当前的maven项目。</p>\r\n<ul>\r\n<li>使用pom.xml文件来实现</li>\r\n</ul>\r\n<p>pom.xml文件：</p>\r\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- POM模型版本 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 当前项目坐标 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itheima<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven_project1<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 打包方式 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>pom文件详解：</p>\r\n<ul>\r\n<li><project> ：pom文件的根标签，表示当前maven项目</li>\r\n<li><modelVersion> ：声明项目描述遵循哪一个POM模型版本\r\n<ul>\r\n<li>虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0</li>\r\n</ul></li>\r\n<li>坐标 ：<groupId>、<artifactId>、<version>\r\n<ul>\r\n<li>定位项目在本地仓库中的位置，由以上三个标签组成一个坐标</li>\r\n</ul></li>\r\n<li><packaging>\r\n：maven项目的打包方式，通常设置为jar或war（默认值：jar）</li>\r\n</ul>\r\n<p>使用Maven面板，通过导入pox文件可以快速导入Maven文件</p>\r\n<h2 id=\"maven依赖管理\">3.Maven依赖管理</h2>\r\n<p>依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：</p>\r\n<p>例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>在pom.xml中编写<dependencies>标签</li>\r\n<li>在<dependencies>标签中使用<dependency>引入坐标</li>\r\n<li>定义坐标的 groupId、artifactId、version</li>\r\n<li>点击刷新按钮，引入最新加入的坐标\r\n<ul>\r\n<li>刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标</li>\r\n</ul></li>\r\n</ol>\r\n<p><strong>添加依赖的几种方式：</strong></p>\r\n<ol type=\"1\">\r\n<li>利用中央仓库搜索的依赖坐标</li>\r\n<li>利用IDEA工具搜索依赖 Alt+Insert快捷键 -&gt; Dependencies</li>\r\n</ol>\r\n<p><strong>依赖具有传递性</strong></p>\r\n<p>早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。若需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下。</p>\r\n<p><strong>However，</strong>我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可，在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。</p>\r\n<p>依赖传递可以分为：</p>\r\n<ol type=\"1\">\r\n<li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li>\r\n<li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li>\r\n</ol>\r\n<p><strong>排除依赖：</strong></p>\r\n<p>在maven项目中，我们可以通过排除依赖来实现：A依赖B，B依赖C，如果<strong>A不想将C</strong>依赖进来</p>\r\n<p>什么是排除依赖？<exclusions> <exclusion></p>\r\n<ul>\r\n<li>排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）</li>\r\n</ul>\r\n<p>依赖排除示例：</p>\r\n<ul>\r\n<li>maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit</li>\r\n</ul>\r\n<p>使用排除依赖后，maven-projectA不再依赖了Junit</p>\r\n<p><strong>依赖范围：</strong></p>\r\n<p>在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。</p>\r\n<p>如果希望限制依赖的使用范围，可以通过<scope>标签设置其作用范围。</p>\r\n<p>作用范围：</p>\r\n<ol type=\"1\">\r\n<li>主程序范围有效（main文件夹范围内）</li>\r\n<li>测试程序范围有效（test文件夹范围内）</li>\r\n<li>是否参与打包运行（package指令范围内）</li>\r\n</ol>\r\n<h2 id=\"maven生命周期\">4.Maven生命周期</h2>\r\n<p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。\r\n描述了一次项目构建，经历哪些阶段。在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行<strong>清理，编译，测试及部署</strong>。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。</p>\r\n<p>Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。</p>\r\n<p>Maven对项目构建的生命周期划分为3套（相互独立）：</p>\r\n<ul>\r\n<li>clean：清理工作。</li>\r\n<li>default：核心工作。如：编译、测试、打包、安装、部署等。</li>\r\n<li>site：生成报告、发布站点等。</li>\r\n</ul>\r\n<p>主要关注以下几个：</p>\r\n<p>• clean：移除上一次构建生成的文件</p>\r\n<p>• compile：编译项目源代码</p>\r\n<p>• test：使用合适的单元测试框架运行测试(junit)</p>\r\n<p>• package：将编译后的文件打包，如：jar、war等</p>\r\n<p>• install：安装项目到本地仓库</p>\r\n<p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong></p>\r\n<p><strong>生命周期的顺序</strong>是：clean --&gt; validate --&gt;\r\ncompile --&gt; test --&gt; package --&gt; verify --&gt; install --&gt;\r\nsite --&gt; deploy</p>\r\n<p>我们需要关注的就是：clean --&gt; compile --&gt; test --&gt; package\r\n--&gt; install</p>\r\n<p>在<strong>同一套</strong>生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。（执行package时，compile会执行，但clean不会，因为不是一套）</p>\r\n<p>在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：</p>\r\n<ol type=\"1\">\r\n<li>在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行</li>\r\n<li>在DOS命令行中，通过maven命令执行</li>\r\n</ol>\r\n<p>compile后：只对main文件夹（主函数）源代码编译，生成target目录</p>\r\n<p>test：对test文件夹（测试程序）进行编译</p>\r\n<p>package：对项目打包，生成jar包，打包后生成的jar包放在target目录下</p>\r\n<p>install：把jar文件安装在当前项目文件夹指定坐标路径下（target）</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221201170830837.png\"\r\nalt=\"image-20221201170830837\" />\r\n<figcaption aria-hidden=\"true\">image-20221201170830837</figcaption>\r\n</figure>\r\n<p>clean：删除target目录</p>\r\n<p>DOS操作：需要在Poweshell窗口操作 mvn clean....</p>\r\n<h2 id=\"其他maven知识点持续补充\">5.其他Maven知识点（持续补充）</h2>\r\n<p>有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：</p>\r\n<p>打开设置----搜索maven----Repositories----选中本地仓库-----点击Update</p>\r\n<p>清理Maven仓库：初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。</p>\r\n<p>如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">set REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_repo</span><br><span class=\"line\">rem 正在搜索...</span><br><span class=\"line\"></span><br><span class=\"line\">del /s /q %REPOSITORY_PATH%\\*.lastUpdated</span><br><span class=\"line\"></span><br><span class=\"line\">rem 搜索完毕</span><br><span class=\"line\">pause</span><br></pre></td></tr></table></figure>\r\n<p>操作步骤如下：</p>\r\n<p>1). 定义批处理文件del_lastUpdated.bat\r\n(直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可\r\n)</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221214154949482.png\"\r\nalt=\"image-20221214154949482\" />\r\n<figcaption aria-hidden=\"true\">image-20221214154949482</figcaption>\r\n</figure>\r\n<p>2). 在上面的bat文件上<strong>右键---》编辑</strong>\r\n。修改文件：REPOSITORY为自己的仓库 mvn-3.6.1/mvn_repo</p>\r\n<p>修改完毕后，双击运行即可删除maven仓库中的残留文件。</p>\r\n<h1 id=\"springboot\">SpringBoot</h1>\r\n<p>Spring的官网(https://spring.io)，去看一下Spring的简介：Spring makes\r\nJava simple。</p>\r\n<p>Spring的官方提供很多开源的项目，可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：</p>\r\n<p>SpringBoot SpringFrameWork SpringData SpringCloud SpringCloudDataFlow\r\nSpringSecurity</p>\r\n<p>Spring若干个子项目完成特点的功能，统称为：<strong>spring全家桶</strong></p>\r\n<p>最基础、最核心的是\r\nSpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p>\r\n<p><strong>However</strong>：直接基于SpringFramework进行开发，存在个问题：配置繁琐、入门难度大；基于此，spring官方推荐从另外一个项目开始学习，那就是目前最火爆的<strong>SpringBoot。</strong></p>\r\n<p>SB最大特点：简单配置 + 快速开发 <strong>Spring Boot\r\n可以帮助我们非常快速的构建应用程序、简化开发、提高效率 </strong></p>\r\n<h2 id=\"基础入门\">1.基础入门</h2>\r\n<h3 id=\"创建工程\">创建工程</h3>\r\n<p>需求：基于<strong>SpringBoot的方式</strong>开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串\r\n“Hello World”。</p>\r\n<p>第1步：创建SpringBoot工程项目</p>\r\n<p>第2步：定义HelloController类，添加方法hello，并添加注解</p>\r\n<p>第3步：测试运行</p>\r\n<p>基于Spring官方骨架，创建SpringBoot工程。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221201184702136.png\" alt=\"image-20221201184702136\" style=\"zoom:50%;\" /></p>\r\n<p>基本信息描述完毕之后，勾选web开发相关依赖。</p>\r\n<p>点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：</p>\r\n<p>src - main - java - com.ning -\r\nSpringBootQuickStarte1Appication.java</p>\r\n<p>在com.ning这个包下创建一个子包controller，再在controller包下新建一个类：HelloController</p>\r\n<p>编写：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itheima.controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span><span class=\"comment\">//注解，非常有用！！！</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World ~&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World ~&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\r\n<p>运行SpringBoot自动生成的引导类：SpringBootQuickStarte1Appication.java（有main函数）</p>\r\n<p>打开浏览器，输入 <code>http://localhost:8080/hello</code></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823195048415.png\" style=\"zoom:80%;\" /></p>\r\n<p>以上内容是基于Spring官方提供的骨架实现，Spring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。</p>\r\n<p>同时，案例中也引用了：web依赖和test依赖（dependencies，Maven学到的）</p>\r\n<p>spring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：<strong>起步依赖</strong></p>\r\n<p>而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为<strong>起步依赖</strong>。</p>\r\n<ul>\r\n<li>spring-boot-starter-web：包含了web应用开发所需要的常见依赖</li>\r\n<li>spring-boot-starter-test：包含了单元测试所需要的常见依赖</li>\r\n</ul>\r\n<p><strong>spring-boot-starter-web</strong>内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入\r\n<code>spring-boot-starter-web</code>\r\n依赖就可以实现Web开发的需要的功能（通过依赖传递，自动导入web开发所需依赖）</p>\r\n<p>Spring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。</p>\r\n<p>地址：https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters</p>\r\n<p>每一个起步依赖，都用于开发一个特定的功能。</p>\r\n<blockquote>\r\n<p>例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis\r\n，即可导入redis开发所需要的依赖。</p>\r\n</blockquote>\r\n<p>在之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。每一个SpringBoot工程，都有一个<strong>父工程</strong>。依赖的版本号，在<strong>父工程中统一管理</strong>。</p>\r\n<p><parent>parent标签指示父工程</p>\r\n<p>同时，在刚刚启动的SpringBoot项目中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器（下文要提到的Web服务器），我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。</p>\r\n<p>当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。</p>\r\n<h3 id=\"解析过程\">解析过程</h3>\r\n<p><strong>浏览器Browser：</strong></p>\r\n<ul>\r\n<li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p>\r\n<ul>\r\n<li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p>\r\n<blockquote>\r\n<p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p>\r\n</blockquote></li>\r\n<li><p>通过端口号8080找到计算机上运行的程序</p>\r\n<blockquote>\r\n<p><code>localhost:8080</code> ,\r\n意思是在本地计算机中找到正在运行的8080端口的程序</p>\r\n</blockquote></li>\r\n<li><p>/hello是<strong>请求资源位置</strong></p>\r\n<ul>\r\n<li>资源：对计算机而言资源就是数据\r\n<ul>\r\n<li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li>\r\n</ul></li>\r\n</ul>\r\n<blockquote>\r\n<p><code>localhost:8080/hello</code>\r\n，意思是向本地计算机中的8080端口程序，获取资源位置是/hello的数据</p>\r\n<ul>\r\n<li>8080端口程序，在服务器找/hello位置的资源数据，发给浏览器</li>\r\n</ul>\r\n</blockquote></li>\r\n</ul></li>\r\n</ul>\r\n<p><strong>服务器：（可以理解为ServerSocket）</strong></p>\r\n<ul>\r\n<li>接收到浏览器发送的信息（如：/hello）</li>\r\n<li>在服务器上找到/hello的资源</li>\r\n<li>把资源发送给浏览器</li>\r\n</ul>\r\n<blockquote>\r\n<p>网络三要素：</p>\r\n<ul>\r\n<li>IP ：网络中计算机的唯一标识</li>\r\n<li>端口 ：计算机中运行程序的唯一标识</li>\r\n<li>协议 ：网络中计算机之间交互的规则</li>\r\n</ul>\r\n<p><strong>浏览器和服务器两端进行数据交互，使用http协议</strong>**</p>\r\n</blockquote>\r\n<h2 id=\"http协议\">2.HTTP协议</h2>\r\n<h3 id=\"概述-1\">概述</h3>\r\n<p>HTTP：Hyper Text Transfer\r\nProtocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p>\r\n<ul>\r\n<li>http是互联网上应用最为广泛的一种网络协议</li>\r\n<li>http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照<strong>固定的格式</strong>进行数据传输</li>\r\n</ul>\r\n<p>格式：</p>\r\n<p>浏览器向服务器进行请求时：</p>\r\n<ul>\r\n<li>服务器按照固定的格式进行解析</li>\r\n</ul>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221202111044434.png\"\r\nalt=\"image-20221202111044434\" />\r\n<figcaption aria-hidden=\"true\">image-20221202111044434</figcaption>\r\n</figure>\r\n<p>服务器向浏览器进行响应时：</p>\r\n<ul>\r\n<li>浏览器按照固定的格式进行解析</li>\r\n</ul>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221202111307819.png\"\r\nalt=\"image-20221202111307819\" />\r\n<figcaption aria-hidden=\"true\">image-20221202111307819</figcaption>\r\n</figure>\r\n<p><strong>HTTP协议有哪些特点？</strong></p>\r\n<ul>\r\n<li><p><strong>基于TCP协议: </strong> 面向连接，安全</p>\r\n<blockquote>\r\n<p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p>\r\n</blockquote></li>\r\n<li><p><strong>基于请求-响应模型:</strong>\r\n一次请求对应一次响应（先请求后响应）</p>\r\n<blockquote>\r\n<p>请求和响应是一一对应关系，没有请求，就没有响应</p>\r\n</blockquote></li>\r\n<li><p><strong>HTTP协议是无状态协议:</strong>\r\n对于数据没有记忆能力。每次请求-响应都是独立的</p>\r\n<blockquote>\r\n<p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p>\r\n<ul>\r\n<li>缺点: 多次请求间不能共享数据</li>\r\n<li>优点: 速度快（只要速度快就够了，因为用户需要及时反馈）</li>\r\n</ul>\r\n<p>解决数据共享：Java中使用会话技术(Cookie、Session)来解决这个问题。</p>\r\n</blockquote></li>\r\n</ul>\r\n<p>浏览器和服务器是按照HTTP协议进行数据通信的。</p>\r\n<p>HTTP协议又分为：请求协议和响应协议</p>\r\n<ul>\r\n<li>请求协议：浏览器将数据以请求格式发送到服务器\r\n<ul>\r\n<li>包括：<strong>请求行</strong>、<strong>请求头</strong>\r\n、<strong>请求体</strong></li>\r\n</ul></li>\r\n<li>响应协议：服务器将数据以响应格式返回给浏览器\r\n<ul>\r\n<li>包括：<strong>响应行</strong> 、<strong>响应头</strong>\r\n、<strong>响应体</strong></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"请求协议\">请求协议</h3>\r\n<p>最常见：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 11%\" />\r\n<col style=\"width: 88%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">请求方式</th>\r\n<th style=\"text-align: left;\">请求说明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\"><strong>GET</strong></td>\r\n<td\r\nstyle=\"text-align: left;\">获取资源。<br/>向特定的资源发出请求。例：http://www.baidu.com/s?wd=hehe2ning</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\"><strong>POST</strong></td>\r\n<td\r\nstyle=\"text-align: left;\">传输实体主体。<br/>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>GET方式的请求协议：</strong></p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823200708026.png\" /></p>\r\n<ul>\r\n<li><p>请求行\r\n：HTTP请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）</p>\r\n<ul>\r\n<li>请求方式：GET<br />\r\n</li>\r\n<li>资源路径：/brand/findAll?name=OPPO&amp;status=1\r\n<ul>\r\n<li>请求路径：/brand/findAll</li>\r\n<li>请求参数：name=OPPO&amp;status=1\r\n<ul>\r\n<li>请求参数是以key=value形式出现</li>\r\n<li>多个请求参数之间使用<code>&amp;</code>连接</li>\r\n</ul></li>\r\n<li>请求路径和请求参数之间使用<code>?</code>连接<br />\r\n</li>\r\n</ul></li>\r\n<li>协议/版本：HTTP/1.1</li>\r\n</ul></li>\r\n<li><p>请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key:\r\nvalue形式</p>\r\n<ul>\r\n<li>http是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了</li>\r\n</ul>\r\n<p>常见请求头：</p>\r\n<p><strong>Host:</strong> 表示请求的主机名</p>\r\n<p><strong>User-Agent:</strong> 浏览器版本。\r\n例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79\r\n，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko</p>\r\n<p><strong>Accept：</strong>表示浏览器能接收的资源类型，如text/<em>，image/</em>或者<em>/</em>表示所有；</p>\r\n<p><strong>Accept-Language：</strong>表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</p>\r\n<p><strong>Accept-Encoding：</strong>表示浏览器可以支持的压缩类型，例如gzip,\r\ndeflate等。</p>\r\n<p><strong>Content-Type：</strong>请求主体的数据类型</p>\r\n<p><strong>Content-Length：</strong>数据主体的大小（单位：字节）</p></li>\r\n</ul>\r\n<p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p>\r\n<p><strong>POST方式的请求协议：</strong></p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823201303601.png\" /></p>\r\n<ul>\r\n<li>请求行(以上图中红色部分)：包含请求方式、资源路径、协议/版本\r\n<ul>\r\n<li>请求方式：POST</li>\r\n<li>资源路径：/brand</li>\r\n<li>协议/版本：HTTP/1.1</li>\r\n</ul></li>\r\n<li>请求头(以上图中黄色部分)<br />\r\n</li>\r\n<li>请求体(以上图中绿色部分) ：存储<strong>请求参数</strong>\r\n<ul>\r\n<li>请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束）</li>\r\n</ul></li>\r\n</ul>\r\n<p>GET请求和POST请求的区别：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 13%\" />\r\n<col style=\"width: 65%\" />\r\n<col style=\"width: 21%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>区别方式</th>\r\n<th>GET请求</th>\r\n<th>POST请求</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>请求参数</td>\r\n<td>请求参数在请求行中。<br/>例：/brand/findAll?name=OPPO&amp;status=1</td>\r\n<td>请求参数在请求体中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>请求参数长度</td>\r\n<td>请求参数长度有限制(浏览器不同限制也不同)</td>\r\n<td>请求参数长度没有限制</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>安全性</td>\r\n<td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td>\r\n<td>安全性相对高</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"响应协议\">响应协议</h3>\r\n<p>与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong>\r\n、<strong>响应体</strong></p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823202344149.png\" /></p>\r\n<ul>\r\n<li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p>\r\n<ul>\r\n<li>协议/版本：HTTP/1.1</li>\r\n<li>响应状态码：200</li>\r\n<li>状态码描述：OK</li>\r\n</ul></li>\r\n<li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p>\r\n<ul>\r\n<li>http是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li>\r\n</ul>\r\n<p>常见的HTTP响应头有:</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Encoding：表示该响应压缩算法，例如gzip ；</span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ;</span><br><span class=\"line\"></span><br><span class=\"line\">Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span><br></pre></td></tr></table></figure></li>\r\n<li><p>响应体(以上图中绿色部分)：\r\n响应数据的最后一部分。存储响应的数据</p>\r\n<ul>\r\n<li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li>\r\n</ul></li>\r\n</ul>\r\n<p><strong>响应状态码：</strong></p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 85%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>状态码分类</th>\r\n<th>说明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>1xx</td>\r\n<td><strong>响应中</strong> ---\r\n临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>2xx</td>\r\n<td><strong>成功</strong> --- 表示请求已经被成功接收，处理已完成</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>3xx</td>\r\n<td><strong>重定向</strong> ---\r\n重定向到其它地方，让客户端再发起一个请求以完成整个处理</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>4xx</td>\r\n<td><strong>客户端错误</strong> ---\r\n处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>5xx</td>\r\n<td><strong>服务器端错误</strong> ---\r\n处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>关于响应状态码，主要认识如下三个状态码：</p>\r\n<ul>\r\n<li>200 ok 客户端请求成功</li>\r\n<li>404 Not Found 请求资源不存在</li>\r\n<li>500 Internal Server Error 服务端发生不可预期的错误</li>\r\n</ul>\r\n<p>简单解析HTTP协议：首先服务器端启动ServerSocket程序 -&gt;\r\n浏览器输入：<code>http://localhost:8080</code>\r\n就会访问到ServerSocket程序</p>\r\n<ul>\r\n<li>ServerSocket程序，会读取服务器上<code>html/a.html</code>文件，并把文件数据发送给浏览器</li>\r\n<li>浏览器接收到a.html文件中的数据后进行解析，显示以下内容</li>\r\n</ul>\r\n<p>在开发中真正用到的Web服务器都是使用目前比较流行的web服务器。如：<strong>Tomcat</strong></p>\r\n<h2 id=\"web服务器\">3.Web服务器</h2>\r\n<h3 id=\"概述-2\">概述</h3>\r\n<p>服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。</p>\r\n<p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p>\r\n<p>服务器软件：基于ServerSocket编写的程序</p>\r\n<ul>\r\n<li>服务器软件本质是一个运行在服务器设备上的应用程序</li>\r\n<li>能够接收客户端请求，并根据请求给客户端响应数据</li>\r\n</ul>\r\n<p>如：MySQL服务器上会存在MySQL软件，作用提供数据库操作服务；Nginx服务器上存在Nginx软件，作用发布静态Web资源（html，css,js）;Tomcat服务器上存在Tomcat软件，作用发布Web资源（静态+动态）；</p>\r\n<p>Web服务器是一个应用程序(软件)，对<strong>HTTP协议的操作</strong>进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是\"提供网上信息浏览服务\"。</p>\r\n<p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的<strong>Web项目部署到Tomcat服务器软件</strong>中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p>\r\n<p><strong>Web服务器软件使用步骤</strong></p>\r\n<ul>\r\n<li>准备静态资源</li>\r\n<li>下载安装Web服务器软件</li>\r\n<li>将静态资源部署到Web服务器上（将静态资源resources文件夹复制到tomcat文件夹下的webapps中）</li>\r\n<li>启动Web服务器使用浏览器访问对应的资源（tomcat的bin目录下双击startup.bat脚本即可启动）</li>\r\n</ul>\r\n<p>此时：浏览器输入：<code>http://localhost:8080/demo/index.html</code>便会出现资源内容</p>\r\n<p>Tomcat运行前需要配置好环境变量中的JAVA_HOME路径，要想修改Tomcat启动的端口号，需要修改\r\nconf/server.xml文件</p>\r\n<h2 id=\"springboot请求响应\">4.SpringBoot请求响应</h2>\r\n<p>在实际开发web程序时，不会像刚才一样，直接请求我们的后端web服务器(也就是内置的Tomcat)，而是：</p>\r\n<p>请求会被部署在Tomcat中的<strong>Controller</strong>接收，然后Controller再给浏览器一个响应，响应一个字符串\r\n“Hello World”。\r\n而在请求响应的过程中是遵循HTTP协议的。在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别\r\n<strong>Servlet程序</strong>的。 那我们所编写的XxxController\r\n是如何处理请求的，又与Servlet之间有什么联系呢？</p>\r\n<p>在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序\r\n<strong>DispatcherServlet</strong>，称之为 <strong>核心控制器</strong>。\r\nDispatcherServlet\r\n负责接收页面发送的请求，然后根据执行的规则，将请求再<strong>转发</strong>给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由<strong>DispatcherServlet</strong>给浏览器响应数据。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220826165340157.png\"\r\nalt=\"image-20220826165340157\" />\r\n<figcaption aria-hidden=\"true\">image-20220826165340157</figcaption>\r\n</figure>\r\n<p>那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后将解析后的请求数据会传递给Servlet程序的<strong>HttpServletRequest对象</strong>，那也就意味着\r\nHttpServletRequest 对象就可以获取到请求数据。\r\n而Tomcat，还给Servlet程序传递了一个参数\r\nHttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。</p>\r\n<p>那上述所描述的这种浏览器/服务器的架构模式呢，我们称之为<strong>：BS架构。</strong></p>\r\n<p>BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。浏览器和服务器之间请求与响应，在服务器对请求进行分层解耦。</p>\r\n<h3 id=\"请求\">请求</h3>\r\n<p>当前最为主流的开发模式：前后端分离</p>\r\n<p>在这种模式下，前端技术人员基于<strong>\"接口文档\"</strong>，开发前端程序；后端技术人员也基于\"接口文档\"，开发后端程序。</p>\r\n<p>由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？</p>\r\n<p>方式：使用专业的接口测试工具（如Postman工具），<em>其他方式参考外卖项目开发中的两种方式</em></p>\r\n<p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求，还可以在发起请求时，携带一些请求参数、请求头等信息，常用于进行<strong>接口测试</strong></p>\r\n<h4 id=\"简单参数\">简单参数</h4>\r\n<p>简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。</p>\r\n<p><strong>后端程序接收简单参数的方式：</strong></p>\r\n<p><strong>原始接收（仅了解）：</strong></p>\r\n<p>在原始的Web程序当中，需要通过Servlet中提供的API：HttpServletRequest（请求对象），获取请求的相关信息。比如获取请求参数：</p>\r\n<blockquote>\r\n<p>Tomcat接收到http请求时：把请求的相关信息封装到HttpServletRequest对象中</p>\r\n</blockquote>\r\n<p>在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明\r\nHttpServletRequest 对象。然后就可以通过该对象来获取请求信息：</p>\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据指定的参数名获取请求参数的数据值</span></span><br><span class=\"line\">String  request.getParameter(<span class=\"string\">&quot;参数名&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><strong>SpringBoot接收：</strong></p>\r\n<p>在SpringBoot的环境中，对原始的API进行了封装，接收参数的形式更加简单。\r\n如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// http://localhost:8080/simpleParam?name=Tom&amp;age=10</span></span><br><span class=\"line\">    <span class=\"comment\">// 第1个请求参数： name=Tom   参数名:name，参数值:Tom</span></span><br><span class=\"line\">    <span class=\"comment\">// 第2个请求参数： age=10     参数名:age , 参数值:10</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//springboot方式</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">simpleParam</span><span class=\"params\">(String name , Integer age )</span>&#123;<span class=\"comment\">//形参名和请求参数名保持一致</span></span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">&quot;  :  &quot;</span>+age);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>postman测试( GET 请求)：</strong></p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203122405075.png\" /></p>\r\n<p><strong>postman测试( POST请求 )：</strong></p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220826181117898.png\" /></p>\r\n<blockquote>\r\n<p>结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证==<strong>请求参数名和Controller</strong>方法中的形参名保持一致==，就可以获取到请求参数中的数据值。</p>\r\n</blockquote>\r\n<p>如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class=\"line\">    <span class=\"comment\">// 请求参数名：name</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//springboot方式</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">simpleParam</span><span class=\"params\">(String username , Integer age )</span>&#123;<span class=\"comment\">//请求参数名和形参名不相同</span></span><br><span class=\"line\">        System.out.println(username+<span class=\"string\">&quot;  :  &quot;</span>+age);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>答案：运行没有报错。\r\ncontroller方法中的username值为：null，age值为20</p>\r\n<ul>\r\n<li>结论：对于简单参数来讲，<strong>请求参数名和controller方法中的形参名不一致时，无法接收到请求数据</strong></li>\r\n</ul>\r\n<p>那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？</p>\r\n<p>解决方案：可以使用Spring提供的==<span class=\"citation\"\r\ndata-cites=\"RequestParam注解\">@RequestParam注解</span>==完成映射</p>\r\n<p>在方法形参前面加上 <span class=\"citation\"\r\ndata-cites=\"RequestParam\">@RequestParam</span>\r\n然后通过value属性执行请求参数名，从而完成映射。代码如下：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class=\"line\">    <span class=\"comment\">// 请求参数名：name</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//springboot方式</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">simpleParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;</span><br><span class=\"line\">        System.out.println(username+<span class=\"string\">&quot;  :  &quot;</span>+age);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><strong>注意事项：</strong></p>\r\n<p><span class=\"citation\"\r\ndata-cites=\"RequestParam中的required属性默认为true\">@RequestParam中的required属性默认为true</span>（默认值也是true），代表该请求参数<strong>必须传递</strong>，如果不传递将报错</p>\r\n</blockquote>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203130726310.png\" /></p>\r\n<blockquote>\r\n<p>如果该参数是可选的，可以将required属性设置为false</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">simpleParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam(name = &quot;name&quot;, required = false)</span> String username, Integer age)</span>&#123;</span><br><span class=\"line\">System.out.println(username+ <span class=\"string\">&quot;:&quot;</span> + age);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。</p>\r\n<p>此时，我们可以考虑将请求参数封装到一个实体类对象中。\r\n要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong></p>\r\n<h4 id=\"实体参数\">实体参数</h4>\r\n<p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。</p>\r\n<p>此时，我们可以考虑将请求参数封装到一个<strong>实体类对</strong>象中。\r\n要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong></p>\r\n<p>定义POJO实体类：<strong>POJO :(Plain Old Java\r\nObjects)，简单的Java对象</strong>，其中有一些属性及其getter、setter方法的类,有时可以作为value\r\nobject或dto(Data Transform\r\nObject)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(Integer age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;User&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, age=&quot;</span> + age +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//实体参数：简单实体对象</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/simplePojo&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">simplePojo</span><span class=\"params\">(User user)</span>&#123;</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//user实体类中的属性必须与请求参数一致，为age和name</span></span><br></pre></td></tr></table></figure>\r\n<p>Postman测试：</p>\r\n<ul>\r\n<li>参数名和实体类属性名一致时，均为name：一切正常</li>\r\n<li>不一致时，请求变成了username：则 User{name='null', age = 10}</li>\r\n</ul>\r\n<p>上面我们讲的呢是简单的实体对象，下面我们在来学习下复<strong>杂的实体对象</strong>。</p>\r\n<p>复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的。如下：</p>\r\n<ul>\r\n<li><p>User类中有一个Address类型的属性（Address是一个实体类），即实体类中包含实体类</p></li>\r\n<li><p>复杂实体对象的封装，需要遵守如下规则：</p>\r\n<ul>\r\n<li><strong>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数</strong></li>\r\n</ul></li>\r\n</ul>\r\n<p>定义POJO实体类：</p>\r\n<ul>\r\n<li>Address实体类</li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Address</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String province;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getProvince</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> province;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setProvince</span><span class=\"params\">(String province)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.province = province;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getCity</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setCity</span><span class=\"params\">(String city)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.city = city;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Address&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;province=&#x27;&quot;</span> + province + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, city=&#x27;&quot;</span> + city + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>User实体类</li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Address address; <span class=\"comment\">//地址对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(Integer age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Address <span class=\"title function_\">getAddress</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAddress</span><span class=\"params\">(Address address)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;User&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, age=&quot;</span> + age +</span><br><span class=\"line\">                <span class=\"string\">&quot;, address=&quot;</span> + address +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//实体参数：复杂实体对象</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/complexPojo&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">complexPojo</span><span class=\"params\">(User user)</span>&#123;</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>Postman测试：新加的内容为address.province和address.city</p>\r\n<h4 id=\"数组集合参数\">数组集合参数</h4>\r\n<p>数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。其实多个值也是一个一个的提交。后端程序接收上述多个值的方式有两种：<strong>数组和集合</strong></p>\r\n<p>数组参数：<strong>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203190218468.png\" /></p>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//数组集合参数</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">arrayParam</span><span class=\"params\">(String[] hobby)</span>&#123;</span><br><span class=\"line\">        System.out.println(Arrays.toString(hobby));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>Postman测试</p>\r\n<p>在前端请求时，有两种传递形式：</p>\r\n<p>方式一： xxxxxxxxxx?hobby=game&amp;hobby=java\r\n方式二：xxxxxxxxxxxxx?hobby=game,java</p>\r\n<p><strong>集合参数</strong>：请求参数名与形参集合对象名相同且请求参数为多个，<span\r\nclass=\"citation\" data-cites=\"RequestParam\">@RequestParam</span>\r\n绑定参数关系</p>\r\n<blockquote>\r\n<p>默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系</p>\r\n</blockquote>\r\n<blockquote>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203211640646.png\"\r\nalt=\"image-20221203211640646\" />\r\n<figcaption aria-hidden=\"true\">image-20221203211640646</figcaption>\r\n</figure>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//数组集合参数</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">listParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> List&lt;String&gt; hobby)</span>&#123;</span><br><span class=\"line\">        System.out.println(hobby);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>Postman测试：</p>\r\n<p>方式一： xxxxxxxxxx?hobby=game&amp;hobby=java  \r\n方式二：xxxxxxxxxxxxx?hobby=game,java</p>\r\n<h4 id=\"日期参数\">日期参数</h4>\r\n<p>上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求：</p>\r\n<p>要选择一个活动/项目的起始时间和结束时间时</p>\r\n<p>因为日期的格式多种多样（如：2022-12-12 10:05:45 、2022/12/12\r\n10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过==<strong><span\r\nclass=\"citation\"\r\ndata-cites=\"DateTimeFormat\">@DateTimeFormat</span></strong>==注解，以及其pattern属性来设置日期的格式。</p>\r\n<ul>\r\n<li><span class=\"citation\"\r\ndata-cites=\"DateTimeFormat注解的pattern属性中指定了哪种日期格式\">@DateTimeFormat注解的pattern属性中指定了哪种日期格式</span>，前端的日期参数就必须按照指定的格式传递。</li>\r\n<li>后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。</li>\r\n</ul>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//日期时间参数</span></span><br><span class=\"line\">   <span class=\"meta\">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">dateParam</span><span class=\"params\">(<span class=\"meta\">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span>&#123;</span><br><span class=\"line\">        System.out.println(updateTime);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>Postman测试：</p>\r\n<p>xxxxxxxxxx?updatetime=2024-4-25 10:05:45</p>\r\n<h4 id=\"json参数\">JSON参数</h4>\r\n<p>JSON: JavaScript Object Notation(JavaScript 对象表示法)</p>\r\n<p>JSON 是存储和交换文本信息的语法，类似XML；JSON 比XML\r\n更小、更快，更易解析；JSON 易于人阅读和编写</p>\r\n<p>如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。\r\n（JSON是开发中最常用的前后端数据交互方式）</p>\r\n<p>我们学习JSON格式参数，主要从以下两个方面着手：</p>\r\n<ol type=\"1\">\r\n<li>Postman在发送请求时，如何传递json格式的请求参数</li>\r\n<li>在服务端的controller方法中，如何接收json格式的请求参数</li>\r\n</ol>\r\n<p>Postman发送JSON格式数据：</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203225623337.png\" /></p>\r\n<p>服务端Controller方法接收JSON格式数据：</p>\r\n<ul>\r\n<li>传递json格式的参数，在Controller中会使用实体类进行封装。</li>\r\n<li>封装规则：<strong>JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用\r\n==<span class=\"citation\"\r\ndata-cites=\"RequestBody\">@RequestBody</span>==标识。</strong></li>\r\n</ul>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203230457901.png\" /></p>\r\n<ul>\r\n<li><span class=\"citation\"\r\ndata-cites=\"RequestBody注解\">@RequestBody注解</span>：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致）</li>\r\n</ul>\r\n<p>实体类：Address</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Address</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String province;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String city;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//省略GET , SET 方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实体类：User</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Address address;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略GET , SET 方法</span></span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//JSON参数</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/jsonParam&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">jsonParam</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span>&#123;</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>Postman测试：</p>\r\n<p>xxxx/jsonParam：发送JSON数据，在后端成功接收</p>\r\n<h4 id=\"路径参数\">路径参数</h4>\r\n<p>传统的开发中请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key=value的形式传递(GET请求)。</p>\r\n<p>在现在的开发中，经常还会直接在<strong>请求的URL</strong>中传递参数。例如：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/user/1\t\t</span><br><span class=\"line\">http://localhost:880/user/1/0</span><br></pre></td></tr></table></figure>\r\n<p>上述的这种传递请求参数的形式呢，我们称之为：路径参数。</p>\r\n<p>学习主要掌握在后端的controller方法中，如何接收路径参数。</p>\r\n<p>路径参数：</p>\r\n<ul>\r\n<li>前端：通过请求URL直接传递参数</li>\r\n<li>后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数</li>\r\n</ul>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204001520756.png\" /></p>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//路径参数</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">pathParam</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span>&#123;</span><br><span class=\"line\">        System.out.println(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>Postman测试：xxxx/path/1</p>\r\n<p><strong>传递多个路径参数：</strong></p>\r\n<p>Postman：xxxx/path/1/SJN</p>\r\n<p>Controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RequestController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//路径参数</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">pathParam2</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id, <span class=\"meta\">@PathVariable</span> String name)</span>&#123;</span><br><span class=\"line\">        System.out.println(id+ <span class=\"string\">&quot; : &quot;</span> +name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"响应\">响应</h3>\r\n<p>Controller 是 Spring\r\n中最基本的组件，主要处理用户交互，一般每个业务逻辑都会有一个\r\nController，供用户请求接口进行数据访问。</p>\r\n<p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet\r\n分发的请求，它把用户请求的数据经过业务层处理之后封装成一个Model\r\n，然后再把该Model 返回给对应的View 进行展示。</p>\r\n<p>Spring MVC 只需使用@Controller\r\n标记一个类即可，然后使用@RequestMapping 和@RequestParam\r\n等一些注解以定义URL 请求和Controller 方法之间的映射，这样Controller\r\n就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest\r\n和HttpServletResponse 等HttpServlet 对象。</p>\r\n<p>(SpringMVC：Spring MVC是一个基于Java的Web应用程序开发框架，它是Spring\r\nFramework的一部分。MVC代表模型-视图-控制器（Model-View-Controller）)</p>\r\n<p><code>@RequestMapping</code> 注解，为我们的应用提供了 “routing”\r\n信息。在这里的 routing 可以理解为路径，在我们访问 Web\r\n资源的时候都会要求提供一个路径的信息。 具体有关这个注解的解释为任何 HTTP\r\n的请求，如果使用了 <code>/</code> 路径的话，所有的请求将会映像到\r\n<code>home</code> 方法，或者可以理解为 <code>home</code> 方法\r\n将会被执行。</p>\r\n<p><code>@RestController</code> 注解将会告诉 Spring 将返回的结果使用\r\nString 字符串来进行渲染，然后将渲染的结果返回给调用者。</p>\r\n<p>Controller程序呢，除了接收请求外，还可以进行响应，前面代码中的return的结果内容即是响应的结果，如何响应给浏览器呢？</p>\r\n<p>答案：使用==<span class=\"citation\"\r\ndata-cites=\"ResponseBody\">@ResponseBody</span>==注解</p>\r\n<p><strong><span class=\"citation\"\r\ndata-cites=\"ResponseBody注解\">@ResponseBody注解</span>：</strong></p>\r\n<ul>\r\n<li>类型：方法注解、类注解</li>\r\n<li>位置：书写在Controller方法上或类上</li>\r\n<li>作用：将方法返回值直接响应给浏览器\r\n<ul>\r\n<li>如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器</li>\r\n</ul></li>\r\n</ul>\r\n<p>但是在我们所书写的Controller中，只在类上添加了<strong><span\r\nclass=\"citation\"\r\ndata-cites=\"RestController\">@RestController</span></strong>注解、方法添加了<strong><span\r\nclass=\"citation\"\r\ndata-cites=\"RequestMapping\">@RequestMapping</span></strong>注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？</p>\r\n<p>原因：在类上添加的@RestController注解，是一个组合注解。</p>\r\n<ul>\r\n<li><strong><span class=\"citation\"\r\ndata-cites=\"RestController\">@RestController</span> = <span\r\nclass=\"citation\" data-cites=\"Controller\">@Controller</span> + <span\r\nclass=\"citation\"\r\ndata-cites=\"ResponseBody\">@ResponseBody</span></strong></li>\r\n</ul>\r\n<p><span class=\"citation\"\r\ndata-cites=\"RestController源码中含有注解\">@RestController源码中含有注解</span><span\r\nclass=\"citation\" data-cites=\"ResponseBody\">@ResponseBody</span></p>\r\n<p>类上有@RestController注解或<span class=\"citation\"\r\ndata-cites=\"ResponseBody注解时\">@ResponseBody注解时</span>：表示当前类下所有的<strong>方法返回值</strong>做为<strong>响应数据</strong>，返回值如果是一个POJO对象或集合时，会先转换为<strong>JSON格式</strong>，再响应给浏览器</p>\r\n<h4 id=\"统一响应结果\">统一响应结果</h4>\r\n<p>我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下：</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204174537686.png\" /></p>\r\n<p>前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。</p>\r\n<p>统一的返回结果使用类来描述，在这个结果中包含：</p>\r\n<ul>\r\n<li>响应状态码：当前请求是1成功，还是0失败</li>\r\n<li>状态码信息：给页面的提示信息</li>\r\n<li>返回的数据：给前端响应的数据（字符串、对象、集合）</li>\r\n</ul>\r\n<p>定义在一个实体类Result来包含以上信息。代码如下：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Result</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer code;<span class=\"comment\">//响应码，1 代表成功; 0 代表失败</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String msg;  <span class=\"comment\">//响应码 描述字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data; <span class=\"comment\">//返回的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Result</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Result</span><span class=\"params\">(Integer code, String msg, Object data)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.code = code;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.msg = msg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">getCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setCode</span><span class=\"params\">(Integer code)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMsg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMsg</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setData</span><span class=\"params\">(Object data)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//增删改 成功响应(不需要给前端返回数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title function_\">success</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Result</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;success&quot;</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//查询 成功响应(把查询结果做为返回数据响应给前端)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title function_\">success</span><span class=\"params\">(Object data)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Result</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;success&quot;</span>,data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//失败响应</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title function_\">error</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Result</span>(<span class=\"number\">0</span>,msg,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>改造Controller：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ResponseController</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">//响应统一格式的结果</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">hello</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World ~&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//return new Result(1,&quot;success&quot;,&quot;Hello World ~&quot;);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(<span class=\"string\">&quot;Hello World ~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<p>原本是return的字符串，现在return 统一响应数据 Result.success了</p>\r\n<p>Springboot项目的静态资源(html，css，js等前端资源)默认存放目录为：classpath:/static\r\n、 classpath:/public、 classpath:/resources</p>\r\n<blockquote>\r\n<p>在SpringBoot项目中，静态资源默认可以存放的目录：</p>\r\n<ul>\r\n<li>classpath:/static/</li>\r\n<li>classpath:/public/</li>\r\n<li>classpath:/resources/</li>\r\n<li>classpath:/META-INF/resources/</li>\r\n</ul>\r\n<p>classpath：</p>\r\n<ul>\r\n<li>代表的是类路径，在maven的项目中，其实指的就是 src/main/resources\r\n或者\r\nsrc/main/java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在\r\nsrc/main/resources下。</li>\r\n</ul>\r\n</blockquote>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204191650390.png\" /></p>\r\n<p>当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。</p>\r\n<ul>\r\n<li>当我们要修改<strong>操作数据</strong>部分的代码，需要改动Controller</li>\r\n<li>当我们要完善<strong>逻辑处理</strong>部分的代码，需要改动Controller</li>\r\n<li>当我们需要修改<strong>数据响应</strong>的代码，还是需要改动Controller</li>\r\n</ul>\r\n<p>===&gt; 整个工程代码的复用性比较差，而且代码难以维护</p>\r\n<p>解决办法：分层开发</p>\r\n<h2 id=\"分层解耦\">5.分层解耦</h2>\r\n<h3 id=\"概述-3\">概述</h3>\r\n<p>在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p>\r\n<blockquote>\r\n<p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p>\r\n<p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p>\r\n</blockquote>\r\n<p>代码基本处理逻辑，从组成上看可以分为三个部分：</p>\r\n<ul>\r\n<li>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。</li>\r\n<li>逻辑处理：负责业务逻辑处理的代码。</li>\r\n<li>请求处理、响应数据：负责，接收页面的请求，给页面响应数据。</li>\r\n</ul>\r\n<p>按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：</p>\r\n<ul>\r\n<li><strong>Controller：</strong>控制层。接收前端发送的请求，对请求进行处理，并响应数据。=》解决请求响应</li>\r\n<li><strong>Service：</strong>业务逻辑层。处理具体的业务逻辑。=》解决核心业务逻辑</li>\r\n<li><strong>Dao：</strong>数据访问层(Data Access\r\nObject)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。=》解决数据访问问题</li>\r\n</ul>\r\n<p>基于三层架构的程序执行流程：</p>\r\n<ol type=\"1\">\r\n<li><p>前端发起的请求，由Controller层接收（Controller响应数据给前端）</p></li>\r\n<li><p>Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）</p></li>\r\n<li><p>Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）</p></li>\r\n<li><p>Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）</p></li>\r\n</ol>\r\n<p>对任一层进行变更维护，都不会影响到其他层的处理</p>\r\n<p>为了实现三层架构的思想，可以在工程代码中建立以下三个包：</p>\r\n<ul>\r\n<li>控制层包名：com.ning.controller<br />\r\n</li>\r\n<li>业务逻辑层包名：xxxx.service</li>\r\n<li>数据访问层包名：xxxx.dao</li>\r\n</ul>\r\n<p><strong>分别实现：</strong></p>\r\n<p><strong>控制层：</strong>接收前端发送的请求，对请求进行处理，并响应数据</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmpController</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务层对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">EmpService</span> <span class=\"variable\">empService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EmpServiceA</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">list</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. 调用service层, 获取数据</span></span><br><span class=\"line\">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3. 响应数据</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(empList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>业务逻辑层：</strong>处理具体的业务逻辑</p>\r\n<ul>\r\n<li>业务接口</li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//业务逻辑接口（制定业务标准）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EmpService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取员工列表</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Emp&gt; <span class=\"title function_\">listEmp</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>业务实现类</li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//业务逻辑实现类（按照业务标准实现）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmpServiceA</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">EmpService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用数据访问层dao层的：new dao层对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">EmpDao</span> <span class=\"variable\">empDao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EmpDaoA</span>();</span><br><span class=\"line\">    <span class=\"comment\">//重写接口方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Emp&gt; <span class=\"title function_\">listEmp</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. 调用dao, 获取数据</span></span><br><span class=\"line\">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2. 对数据进行转换处理 - gender, job</span></span><br><span class=\"line\">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理 gender 1: 男, 2: 女</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">gender</span> <span class=\"operator\">=</span> emp.getGender();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class=\"line\">                emp.setGender(<span class=\"string\">&quot;男&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class=\"line\">                emp.setGender(<span class=\"string\">&quot;女&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">job</span> <span class=\"operator\">=</span> emp.getJob();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class=\"line\">                emp.setJob(<span class=\"string\">&quot;讲师&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class=\"line\">                emp.setJob(<span class=\"string\">&quot;班主任&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class=\"line\">                emp.setJob(<span class=\"string\">&quot;就业指导&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>数据访问实现类</li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//数据访问实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmpDaoA</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">EmpDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Emp&gt; <span class=\"title function_\">listEmp</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. 加载并解析emp.xml</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getClass().getClassLoader().getResource(<span class=\"string\">&quot;emp.xml&quot;</span>).getFile();</span><br><span class=\"line\">        System.out.println(file);</span><br><span class=\"line\">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204201342490.png\" /></p>\r\n<p>三层架构的好处：</p>\r\n<ol type=\"1\">\r\n<li>复用性强</li>\r\n<li>便于维护</li>\r\n<li>利用扩展</li>\r\n</ol>\r\n<h3 id=\"解耦\">解耦</h3>\r\n<p>解耦：解除耦合，什么是耦合呢？</p>\r\n<p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p>\r\n<ul>\r\n<li><p>内聚：软件中各个功能模块内部的功能联系。</p></li>\r\n<li><p>耦合：衡量软件中各个层/模块之间的依赖、关联的程度。</p></li>\r\n</ul>\r\n<p><strong>软件设计原则：高内聚低耦合。</strong></p>\r\n<blockquote>\r\n<p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即\r\n\"高内聚\"。</p>\r\n<p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p>\r\n</blockquote>\r\n<p>程序中高内聚的体现：</p>\r\n<ul>\r\n<li>EmpServiceA类中只编写了和员工相关的逻辑处理代码</li>\r\n</ul>\r\n<p>程序中<em>耦合代码</em>的体现：</p>\r\n<ul>\r\n<li>把业务类变为EmpServiceB时，需要修改controller层中的代码，即变成new\r\nEmpServiceB</li>\r\n</ul>\r\n<p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p>\r\n<p>之前我们在编写代码时，需要什么对象，就直接new一个就可以了。\r\n这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后，\r\n我们还需要修改controller层的代码。</p>\r\n<p><strong>解耦思路：不 new 对象</strong></p>\r\n<p>不能new，就意味着没有业务层对象，解决：</p>\r\n<ul>\r\n<li>提供一个<strong>容器</strong>，容器中存储一些对象(例：EmpService对象)</li>\r\n<li>controller程序<strong>从容器中获取</strong>EmpService类型的对象</li>\r\n</ul>\r\n<p>我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：</p>\r\n<ul>\r\n<li><p><strong>控制反转：</strong> Inversion Of\r\nControl，简称IOC。<strong>对象的创建控制权由程序自身转移到外部</strong>（容器），这种思想称为控制反转。</p>\r\n<blockquote>\r\n<p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器</p>\r\n</blockquote></li>\r\n<li><p><strong>依赖注入：</strong> Dependency\r\nInjection，简称DI。<strong>容器为应用程序提供运行时，所依赖的资源</strong>，称之为依赖注入。</p>\r\n<blockquote>\r\n<p>程序运行时需要某个资源，此时容器就为其提供这个资源。</p>\r\n<p>例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象</p>\r\n</blockquote></li>\r\n</ul>\r\n<p>IOC容器中创建、管理的对象，称之为：bean对象</p>\r\n<h3 id=\"ioc-di\">IOC &amp; DI</h3>\r\n<p>任务：完成Controller层、Service层、Dao层的代码解耦</p>\r\n<ul>\r\n<li>思路：\r\n<ol type=\"1\">\r\n<li>删除Controller层、Service层中new对象的代码（不new了）</li>\r\n<li>Service层及Dao层的实现类，交给IOC容器管理\r\n（使用Spring提供的注解：==<span class=\"citation\"\r\ndata-cites=\"Component\">@Component</span>==，就可以实现类交给IOC容器管理）</li>\r\n<li>为Controller及Service注入运行时依赖的对象（使用Spring提供的注解：==<span\r\nclass=\"citation\" data-cites=\"Autowired\">@Autowired</span>==\r\n，就可以实现程序运行时IOC容器自动注入需要的依赖对象）\r\n<ul>\r\n<li>Controller程序中注入依赖的Service层对象</li>\r\n<li>Service程序中注入依赖的Dao层对象</li>\r\n</ul></li>\r\n</ol></li>\r\n</ul>\r\n<p>完整的三层代码：</p>\r\n<ul>\r\n<li><strong>Controller层：</strong></li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmpController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class=\"line\">    <span class=\"comment\">//不new了</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EmpService empService ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">list</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. 调用service, 获取数据</span></span><br><span class=\"line\">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3. 响应数据</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(empList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><strong>Service层：</strong></li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">//实现2. 将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmpServiceA</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">EmpService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">//实现3.  运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EmpDao empDao ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Emp&gt; <span class=\"title function_\">listEmp</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. 调用dao, 获取数据</span></span><br><span class=\"line\">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2. 对数据进行转换处理 - gender, job</span></span><br><span class=\"line\">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理 gender 1: 男, 2: 女</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">gender</span> <span class=\"operator\">=</span> emp.getGender();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class=\"line\">                emp.setGender(<span class=\"string\">&quot;男&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class=\"line\">                emp.setGender(<span class=\"string\">&quot;女&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">job</span> <span class=\"operator\">=</span> emp.getJob();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class=\"line\">                emp.setJob(<span class=\"string\">&quot;讲师&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class=\"line\">                emp.setJob(<span class=\"string\">&quot;班主任&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class=\"line\">                emp.setJob(<span class=\"string\">&quot;就业指导&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>Dao层：</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">//将当前对象交给IOC容器管理,成为IOC容器的bean 实现2.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmpDaoA</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">EmpDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Emp&gt; <span class=\"title function_\">listEmp</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1. 加载并解析emp.xml</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getClass().getClassLoader().getResource(<span class=\"string\">&quot;emp.xml&quot;</span>).getFile();</span><br><span class=\"line\">        System.out.println(file);</span><br><span class=\"line\">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。</p>\r\n<p>前面我们提到IOC控制反转，就是将<strong>对象的控制权</strong>交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p>\r\n<p>在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：<span\r\nclass=\"citation\" data-cites=\"Component\">@Component</span></p>\r\n<p>而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p>\r\n<ul>\r\n<li><span class=\"citation\" data-cites=\"Controller\">@Controller</span>\r\n（标注在控制层类上）（由于代码中有标注@RestController = <span\r\nclass=\"citation\" data-cites=\"Controller\">@Controller</span> + <span\r\nclass=\"citation\"\r\ndata-cites=\"ResponseBody\">@ResponseBody</span>），故不用标注它</li>\r\n<li><span class=\"citation\" data-cites=\"Service\">@Service</span>\r\n（标注在业务层类上）</li>\r\n<li><span class=\"citation\" data-cites=\"Repository\">@Repository</span>\r\n（标注在数据访问层类上）</li>\r\n</ul>\r\n<p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 25%\" />\r\n<col style=\"width: 60%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\">注解</th>\r\n<th>说明</th>\r\n<th>位置</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\"><span class=\"citation\"\r\ndata-cites=\"Controller\">@Controller</span></td>\r\n<td><span class=\"citation\"\r\ndata-cites=\"Component的衍生注解\">@Component的衍生注解</span></td>\r\n<td>标注在控制器类上</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\"><span class=\"citation\"\r\ndata-cites=\"Service\">@Service</span></td>\r\n<td><span class=\"citation\"\r\ndata-cites=\"Component的衍生注解\">@Component的衍生注解</span></td>\r\n<td>标注在业务类上</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\"><span class=\"citation\"\r\ndata-cites=\"Repository\">@Repository</span></td>\r\n<td><span class=\"citation\"\r\ndata-cites=\"Component的衍生注解\">@Component的衍生注解</span></td>\r\n<td>标注在数据访问类上（由于与mybatis整合，用的少）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\"><span class=\"citation\"\r\ndata-cites=\"Component\">@Component</span></td>\r\n<td>声明bean的基础注解</td>\r\n<td>不属于以上三类时，用此注解</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。</p>\r\n<p>注意事项:</p>\r\n<ul>\r\n<li>声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为首字母小写后的类名（类名EmpServiceA\r\n-&gt;bean名empServiceA）。</li>\r\n<li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</li>\r\n</ul>\r\n<p>使用四大注解声明的bean，要想生效，还需要被组件扫描注解==<span\r\nclass=\"citation\"\r\ndata-cites=\"ComponentScan\">@ComponentScan</span>==扫描</p>\r\n<p><span class=\"citation\"\r\ndata-cites=\"ComponentScan注解虽然没有显式配置\">@ComponentScan注解虽然没有显式配置</span>，但是实际上已经包含在了引导类声明注解\r\n<span class=\"citation\"\r\ndata-cites=\"SpringBootApplication\">@SpringBootApplication</span>\r\n中，==<strong>默认扫描的范围是SpringBoot启动类所在包及其子包</strong>==。</p>\r\n<p>在本项目中在：SpringbootWebReqRespApplication（启动类）</p>\r\n<p>推荐做法（如下图）：</p>\r\n<ul>\r\n<li>将我们定义的controller，service，dao这些包呢，都放在引导类所在包com.ning的子包下，这样我们定义的bean就会被自动的扫描到，即让启动类.java代码和dao包等平级</li>\r\n</ul>\r\n<p>依赖注入DI，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p>\r\n<p>在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：<strong>自动装配</strong>。</p>\r\n<p><span class=\"citation\"\r\ndata-cites=\"Autowired注解\">@Autowired注解</span>，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p>\r\n<blockquote>\r\n<p>入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。</p>\r\n</blockquote>\r\n<p>那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204232154445.png\" /></p>\r\n<p><strong><em>程序运行会报错</em></strong></p>\r\n<p>如何解决上述问题呢？Spring提供了以下几种解决方案：</p>\r\n<ul>\r\n<li><span class=\"citation\" data-cites=\"Primary\">@Primary</span>\r\n默认的实现</li>\r\n<li><span class=\"citation\" data-cites=\"Qualifier\">@Qualifier</span>\r\n value指定名称</li>\r\n<li><span class=\"citation\" data-cites=\"Resource\">@Resource</span>\r\nname属性指定要注入的bean的名称</li>\r\n</ul>\r\n<p>使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204232501679.png\" /></p>\r\n<p>使用@Qualifier注解：指定当前要注入的bean对象。\r\n在@Qualifier的value属性中，指定注入的bean的名称。</p>\r\n<ul>\r\n<li><span class=\"citation\"\r\ndata-cites=\"Qualifier注解不能单独使用\">@Qualifier注解不能单独使用</span>，必须配合@Autowired使用</li>\r\n</ul>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204233333606.png\" /></p>\r\n<p>使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204233637735.png\" /></p>\r\n<blockquote>\r\n<p>面试题 ： <span class=\"citation\"\r\ndata-cites=\"Autowird\">@Autowird</span> 与 <span class=\"citation\"\r\ndata-cites=\"Resource的区别\">@Resource的区别</span></p>\r\n<ul>\r\n<li><span class=\"citation\" data-cites=\"Autowired\">@Autowired</span>\r\n是spring框架提供的注解，而@Resource是JDK提供的注解</li>\r\n<li><span class=\"citation\" data-cites=\"Autowired\">@Autowired</span>\r\n默认是按照类型注入，而@Resource是按照名称注入</li>\r\n</ul>\r\n</blockquote>\r\n","categories":["进厂学习记录"],"tags":["Maven","SpringBoot","MySQL","HTTP","Mybatis"]},{"title":"Day8","url":"/2024/04/25/Day8/","content":"<h1 id=\"算法\">算法</h1>\r\n<p>今天正式开始刷回溯专题的内容：</p>\r\n<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>\r\n<span id=\"more\"></span>\r\n<p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a\r\nhref=\"https://programmercarl.com/二叉树中递归带着回溯.html\">二叉树：以为使用了递归，其实还隐藏着回溯\r\n(opens new window)</a>。</p>\r\n<p>回溯是递归的副产品，只要有递归就会有回溯。</p>\r\n<p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong></p>\r\n<h3 id=\"回溯法的效率\">回溯法的效率</h3>\r\n<p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>\r\n<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>\r\n<p>那么既然回溯法并不高效为什么还要用它呢？因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>\r\n<h3 id=\"回溯法解决的问题\">回溯法解决的问题</h3>\r\n<p>回溯法，一般可以解决如下几种问题：</p>\r\n<ul>\r\n<li>组合问题：N个数里面按一定规则找出k个数的集合</li>\r\n<li>切割问题：一个字符串按一定规则有几种切割方式</li>\r\n<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>\r\n<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>\r\n<li>棋盘问题：N皇后，解数独等等</li>\r\n</ul>\r\n<p><strong>相信大家看着这些之后会发现，每个问题，都不简单！</strong></p>\r\n<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>\r\n<p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>\r\n<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p>\r\n<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>\r\n<p>能够抽象成树的问题，都可以回溯解决，回溯的本质也是穷举</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png\"\r\nalt=\"回溯算法理论基础\" />\r\n<figcaption aria-hidden=\"true\">回溯算法理论基础</figcaption>\r\n</figure>\r\n<p>回溯法模版：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(参数)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (终止条件) &#123;</span><br><span class=\"line\">        存放结果;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class=\"line\">        处理节点;</span><br><span class=\"line\">        backtracking(路径，选择列表); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">        回溯，撤销处理结果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t\t</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><p><strong>回溯法的魅力，用递归控制for循环嵌套的数量！</strong>回溯问题抽象为树形结构，可以直观的看出其搜索的过程：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p></li>\r\n<li><p>在<a\r\nhref=\"https://programmercarl.com/0077.组合优化.html\">回溯算法：组合问题再剪剪枝\r\n(opens new\r\nwindow)</a>中把回溯法代码做了剪枝优化，在文中依然把问题抽象为一个树形结构，大家可以一目了然剪的究竟是哪里。</p></li>\r\n</ul>\r\n<p><strong>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够\r\n题目要求的k个元素了，就没有必要搜索了</strong>。</p>\r\n<ul>\r\n<li><p>一定注意题目范围！！！在<a\r\nhref=\"https://programmercarl.com/0216.组合总和III.html\">回溯算法：求组合总和！\r\n(opens new\r\nwindow)</a>中，题目给出了是1-9的数字，而不是n的，理清题目中对应到回溯法的n和k分别是什么含义，什么内容</p></li>\r\n<li><p>在<a\r\nhref=\"https://programmercarl.com/0017.电话号码的字母组合.html\">回溯算法：电话号码的字母组合\r\n(opens new\r\nwindow)</a>中，开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。</p>\r\n<p>例如这里for循环，可不像是在 <a\r\nhref=\"https://programmercarl.com/0077.组合.html\">回溯算法：求组合问题！\r\n(opens new window)</a>和<a\r\nhref=\"https://programmercarl.com/0216.组合总和III.html\">回溯算法：求组合总和！\r\n(opens new window)</a>中从startIndex开始遍历的。</p>\r\n<p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而之前的问题都是是求同一个集合中的组合！</strong></p>\r\n<p>此题很绕，debug了很久o(╥﹏╥)o（而且最后也没实现出来自己最初的方法，当初的设计就不合理，不好实现，可见初始设计的重要性）</p></li>\r\n</ul>\r\n<h1 id=\"开发\">开发</h1>\r\n<p>今天学了SpringWeb开发的基础内容，大多是一些入门部分，如SpringBoot入门，概述，Postman测试使用，注解是什么，针对不同的数据类的请求响应，重点应该在HTTP协议，面试中经常会问到，需要加精一下，具体内容在JavaWeb开发博客中~</p>\r\n<h1 id=\"毕设\">毕设</h1>\r\n<p>毕设现在已经基本成稿，这几天绘制了一下相关图片，图片用的基本都是矢量图，对应表格也写了一下（<strong>latex</strong>写表真难啊，好在有latextable这种网站，救大命了属于是），就差最后的仿真部分了，准备全部内容完成后就开启仿真部分的工作；</p>\r\n<p>现在的工作是每天都一半时间分给毕设，剩下一半时间是算法和学习开发的时间，毕业设计是作为学生的本分，虽然自己很急，但是先别急，不能本末倒置！以下是图片的部分展示：</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240424214422453.png\" /></p>\r\n","categories":["进厂学习记录"],"tags":["算法","毕业设计","回溯"]},{"title":"基本业务——cq外卖","url":"/2024/12/17/%E5%9F%BA%E6%9C%AC%E4%B8%9A%E5%8A%A1%E2%80%94%E2%80%94cq%E5%A4%96%E5%8D%96/","content":"<h1 id=\"软件开发介绍\">软件开发介绍</h1>\r\n<p>作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程，\r\n以及软件开发过程中涉及到的岗位角色，角色的分工、职责，\r\n并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从\r\n软件开发流程、角色分工、软件环境 三个方面整体介绍一下软件开发。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"软件开发流程\">1.1 软件开发流程</h3>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106162815172.png\" alt=\"image-20221106162815172\"  style=\"zoom:80%;\" /></p>\r\n<p><strong>1). 第1阶段: 需求分析</strong></p>\r\n<p>完成需求规格说明书、产品原型编写。</p>\r\n<p>需求规格说明书， 一般来说就是使用 Word\r\n文档来描述当前项目的各个组成部分，如：系统定义、应用环境、功能规格、性能需求等，都会在文档中描述。<strong>例如：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106163758703.png\" alt=\"image-20221106163758703\" style=\"zoom: 50%;\" /></p>\r\n<p>产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据,\r\n页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。\r\n<strong>例如：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106163925031.png\" alt=\"image-20221106163925031\" style=\"zoom:50%;\" /></p>\r\n<p><strong>2). 第2阶段: 设计</strong></p>\r\n<p>设计的内容包含 UI设计、数据库设计、接口设计。</p>\r\n<p>UI设计：用户界面的设计，主要设计项目的页面效果，小到一个按钮，大到一个页面布局，还有人机交互逻辑的体现。<strong>例如：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106165303946.png\" alt=\"image-20221106165303946\" style=\"zoom:50%;\" /></p>\r\n<p>数据库设计：需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段。<strong>例如：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106165554917.png\" alt=\"image-20221106165554917\" style=\"zoom:50%;\" /></p>\r\n<p>接口设计：通过分析原型图，首先，粗粒度地分析每个页面有多少接口，然后，再细粒度地分析每个接口的传入参数，返回值参数，同时明确接口路径及请求方式。<strong>例如：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106171538880.png\" alt=\"image-20221106171538880\" style=\"zoom:50%;\" /></p>\r\n<p><strong>3). 第3阶段: 编码</strong></p>\r\n<p>编写项目代码、并完成单元测试。</p>\r\n<p>项目代码编写：作为软件开发工程师，我们需要对项目的模块功能分析后，进行编码实现。</p>\r\n<p>单元测试：编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。<strong>例如：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106175351594.png\" alt=\"image-20221106175351594\" style=\"zoom:50%;\" /></p>\r\n<p><strong>4). 第4阶段: 测试</strong></p>\r\n<p>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试,\r\n并出具测试报告。</p>\r\n<p><strong>5). 第5阶段: 上线运维</strong></p>\r\n<p>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置，\r\n配置完毕后， 再将我们开发好的项目，部署在服务器上运行。</p>\r\n<h3 id=\"角色分工\">1.2 角色分工</h3>\r\n<p>在对整个软件开发流程熟悉后，\r\n我们还有必要了解一下在整个软件开发流程中涉及到的岗位角色，以及各个角色的职责分工。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20210725234015404.png\"\r\nalt=\"image-20210725234015404\" />\r\n<figcaption aria-hidden=\"true\">image-20210725234015404</figcaption>\r\n</figure>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 33%\" />\r\n<col style=\"width: 27%\" />\r\n<col style=\"width: 39%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\">岗位/角色</th>\r\n<th>对应阶段</th>\r\n<th style=\"text-align: left;\">职责/分工</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">项目经理</td>\r\n<td>全阶段</td>\r\n<td style=\"text-align: left;\">对整个项目负责，任务分配、把控进度</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">产品经理</td>\r\n<td>需求分析</td>\r\n<td\r\nstyle=\"text-align: left;\">进行需求调研，输出需求调研文档、产品原型等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">UI设计师</td>\r\n<td>设计</td>\r\n<td style=\"text-align: left;\">根据产品原型输出界面效果图</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">架构师</td>\r\n<td>设计</td>\r\n<td style=\"text-align: left;\">项目整体架构设计、技术选型等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\"><font color='red'>开发工程师</font></td>\r\n<td><font color='red'>编码</font></td>\r\n<td style=\"text-align: left;\"><font color='red'>功能代码实现</font></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">测试工程师</td>\r\n<td>测试</td>\r\n<td style=\"text-align: left;\">编写测试用例，输出测试报告</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">运维工程师</td>\r\n<td>上线运维</td>\r\n<td style=\"text-align: left;\">软件环境搭建、项目上线</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工,\r\n但是在实际的项目中, 有一些项目组由于人员配置紧张,\r\n可能并没有专门的架构师或测试人员,\r\n这个时候可能需要有项目经理或者程序员兼任。</p>\r\n<h3 id=\"软件环境\">1.3 软件环境</h3>\r\n<p>作为软件开发工程师，在编码的过程中就不可避免地会接触多种软件环境，我们主要来分析在工作中经常遇到的三套环境，\r\n分别是: 开发环境、测试环境、生产环境。\r\n接下来，我们分别介绍一下这三套环境的作用和特点。</p>\r\n<p><strong>1). 开发环境(development)</strong></p>\r\n<p>我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。</p>\r\n<p>比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地，\r\n也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用，\r\n项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。</p>\r\n<p><strong>2). 测试环境(testing)</strong></p>\r\n<p>当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境，\r\n也就是测试环境，用于项目测试，一般外部用户无法访问。</p>\r\n<p><strong>3). 生产环境(production)</strong></p>\r\n<p>当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对外提供服务，这个线上环境也称之为生产环境。</p>\r\n<p>首先，会在开发环境中进行项目开发，往往开发环境大多数都是本地的电脑环境和局域网内的环境，当开发完毕后，然后会把项目部署到测试环境，测试环境一般是一台独立测试服务器的环境，项目测试通过后，最终把项目部署到生产环境，生产环境可以是机房或者云服务器等线上环境。</p>\r\n<h1 id=\"项目技术介绍\">项目技术介绍</h1>\r\n<p>本项目（苍穹外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括\r\n系统管理后台 和 小程序端应用\r\n两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜品、套餐、订单、员工等进行管理维护，对餐厅的各类数据进行统计，同时也可进行来单语音播报功能。小程序端主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单、支付、催单等。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106185252326.png\"\r\nalt=\"image-20221106185252326\" />\r\n<figcaption aria-hidden=\"true\">image-20221106185252326</figcaption>\r\n</figure>\r\n<p>接下来，通过功能架构图来展示<strong>管理端</strong>和<strong>用户端</strong>的具体业务功能模块。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106194424735.png\" alt=\"image-20221106194424735\" style=\"zoom: 67%;\" /></p>\r\n<p><strong>1). 管理端功能</strong></p>\r\n<p>员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 ,\r\n菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p>\r\n<p><strong>2). 用户端功能</strong></p>\r\n<p>微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 ,\r\n购物车功能 , 下单 , 支付、分类及菜品浏览。</p>\r\n<p><strong>用户端原型图：</strong></p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106195354556.png\" alt=\"image-20221106195354556\" style=\"zoom:50%;\" /></p>\r\n<p><strong>1). 管理端</strong></p>\r\n<p>餐饮企业内部员工使用。 主要功能有:</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 13%\" />\r\n<col style=\"width: 86%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>模块</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>登录/退出</td>\r\n<td>内部员工必须登录后,才可以访问系统管理后台</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>员工管理</td>\r\n<td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>分类管理</td>\r\n<td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护，\r\n包含查询、新增、修改、删除等功能</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>菜品管理</td>\r\n<td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>套餐管理</td>\r\n<td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>订单管理</td>\r\n<td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>数据统计</td>\r\n<td>主要完成对餐厅的各类数据统计，如营业额、用户数量、订单等</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>2). 用户端</strong></p>\r\n<p>移动端应用主要提供给消费者使用。主要功能有:</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 15%\" />\r\n<col style=\"width: 84%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>模块</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>登录/退出</td>\r\n<td>用户需要通过微信授权后登录使用小程序进行点餐</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>点餐-菜单</td>\r\n<td>在点餐界面需要展示出菜品分类/套餐分类,\r\n并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>点餐-购物车</td>\r\n<td>用户选中的菜品就会加入用户的购物车, 主要包含\r\n查询购物车、加入购物车、删除购物车、清空购物车等功能</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>订单支付</td>\r\n<td>用户选完菜品/套餐后, 可以对购物车菜品进行结算支付,\r\n这时就需要进行订单的支付</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>个人信息</td>\r\n<td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址,\r\n也可以查询历史订单数据</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"技术选型\">2.3 技术选型</h3>\r\n<p>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层\r\n这几个方面进行介绍，主要用于展示项目中使用到的技术框架和中间件等。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106185646994.png\"\r\nalt=\"image-20221106185646994\" />\r\n<figcaption aria-hidden=\"true\">image-20221106185646994</figcaption>\r\n</figure>\r\n","categories":["进厂学习记录"],"tags":["mybatis","spring"]},{"title":"test","url":"/2024/02/02/test/","content":"<h1 id=\"图片测试\">图片测试</h1>\r\n<p>此mark笔记文档专门来测试图片的样式</p>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/WEB.png\"\r\nalt=\"WEB\" />\r\n<figcaption aria-hidden=\"true\">WEB</figcaption>\r\n</figure>\r\n"},{"title":"Markdown入门语法","url":"/2024/02/02/Markdown%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/","content":"<h1 id=\"markdown笔记\">Markdown笔记</h1>\r\n<h2 id=\"标题\">标题</h2>\r\n<p>标题用两个“##”加“空格\r\n标题内容”回车确认，几个#表示几级标题，勿忘空格！</p>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 一级标题</span></span><br><span class=\"line\"><span class=\"section\">## 二级标题</span></span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"字体\">字体</h2>\r\n<p><strong>加粗</strong> ：两个<em> </em>倾斜* ：一个<em>\r\n三个</em>就是加粗加倾斜啦 <del>删除线</del>：两个~</p>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"strong\">**加粗**</span></span><br><span class=\"line\"><span class=\"emphasis\">*倾斜*</span></span><br><span class=\"line\"><span class=\"strong\">**<span class=\"emphasis\">*加粗+倾斜*</span>**</span></span><br><span class=\"line\">~删除~</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"引用\">引用</h2>\r\n<blockquote>\r\n<p>搭建自己的博客，记录自己的笔记，走自己的路</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>用一个英文的&gt;来表示引用</p>\r\n</blockquote>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"quote\">&gt; 引用内容</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分割线\">分割线</h2>\r\n<h3 id=\"法1手动分割bushi\">法1：<del>手动分割</del>(bushi</h3>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">前后各两个~~ 分割 ~~</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"法2三个减号\">法2：三个减号</h3>\r\n<hr>\r\n<p>分割内容</p>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\"><span class=\"section\">分割内容 </span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\">分割内容</span><br><span class=\"line\"><span class=\"strong\">*** </span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"图片\">图片</h2>\r\n<figure>\r\n<img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/2021020418415889.jpg\" alt=\"科技未来\">\r\n<figcaption aria-hidden=\"true\">科技未来</figcaption>\r\n</figure>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">图片名称，可自命名</span>](<span class=\"link\">图片地址，可以是本地or网页/外部地址</span>)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"超链接\">超链接</h2>\r\n<p><a href=\"https://editor.csdn.net/md?not_checkout=1&amp;articleId=113662396\">XDUNing的第一篇博客</a>\r\n一个[超链接名称]（）小括号里面是地址</p>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">超链接名称</span>](<span class=\"link\">超链接地址</span>)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"列表\">列表</h2>\r\n<p><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> 减号空格（无序）</span><br><span class=\"line\"><span class=\"bullet\">1.</span> 数字空格有序</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"表格\">表格</h2>\r\n<p>直接插入把，这个a little difficult</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>ctrl + T (Typora)</th>\r\n<th></th>\r\n<th></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>四行三列的表格</td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>段落 -&gt; 表格 -&gt; 插入表格</td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"公式\">公式</h2>\r\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">latex的公式形式：</span><br><span class=\"line\">$行内公式内容$</span><br><span class=\"line\">$$</span><br><span class=\"line\">行间公式</span><br><span class=\"line\">\\\\</span><br><span class=\"line\">行间公式</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure>\r\n<p><span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"8.93ex\" height=\"1.756ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 3947 776\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(806.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1862.6,0)\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2513.8,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3514,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g></g></g></svg></mjx-container></span></p>\r\n<p><span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.777ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"23.747ex\" height=\"4.075ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1457.6 10496.2 1800.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D43F\" d=\"M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(714,-150) scale(0.707)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1397.5,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2453.2,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"munderover\" transform=\"translate(2842.2,0)\"><g data-mml-node=\"mo\"><path data-c=\"2211\" d=\"M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1089,477.1) scale(0.707)\"><path data-c=\"1D45A\" d=\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(1089,-285.4) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(345,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1123,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></g></g><g data-mml-node=\"mo\" transform=\"translate(5295.5,0) translate(0 -0.5)\"><path data-c=\"7C\" d=\"M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z\"></path></g><g data-mml-node=\"msub\" transform=\"translate(5573.5,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(605,-150) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(6694.7,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"></path></g><g data-mml-node=\"msub\" transform=\"translate(7694.9,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D466\" d=\"M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(523,-150) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"msup\" transform=\"translate(8511.9,0)\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7C\" d=\"M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(311,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g></g></g><g data-mml-node=\"msup\" transform=\"translate(9228.6,0)\"><g data-mml-node=\"mo\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(422,592.7) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mstyle\" transform=\"scale(1.414)\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mn\" transform=\"translate(221.1,394) scale(0.707)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(220,-345) scale(0.707)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><rect width=\"555.7\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g></g></g></g></g></g></svg></mjx-container></span></p>\r\n<p>## 代码</p>\r\n<p><code>#include&lt;stdio.h&gt;</code></p>\r\n<p><code>int main()</code></p>\r\n<p><code>#includ&lt;stdio.h&gt;</code></p>\r\n<ul>\r\n<li>一个点表示一个代码语句</li>\r\n<li>三个`表示一个代码块</li>\r\n</ul>\r\n<p><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">​```三个点点代码块，`一个点代码语句</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br></pre></td></tr></table></figure></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> calss <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Hello,World\"</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n","categories":["入门使用"]},{"title":"新生活，新开始","url":"/2024/09/18/%E6%96%B0%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%96%B0%E5%BC%80%E5%A7%8B/","content":"<p>虽然很久很久没有写博客了，但是会经常打开博客，会经常通过写日记的方式来记录一下零散的生活。5月份以后专注于毕设的实验分析和论文撰写，到6月份的答辩，顺利通过，最后成功从XDU毕业，为我的大学四年画上了一个不大不小的句号，也为新的生活另起了一段。</p>\r\n<span id=\"more\"></span>\r\n<p>问自己大学有什么成长和难忘遗憾，固然是有很多，可能是受制于性格，缺乏在做选择时的勇气，特别是大三大四，做什么选择总是想从网上找到一个最优解，总想看一下别人的看法，好似那不是我的选择，而是别人的，推卸责任。我逐渐意识到那份勇气的重要性，心中换导师的想法愈加强烈，我想要什么，我能得到什么。大学伊始，从小镇走出的\"乡下人\"没有充足广阔的视野，我想要啥啊？不知道，先好好学习，然后考研保研，漫无目的；学了一段时间，成绩没有很突出，我想要啥啊，那就是保研了，随波逐流地开始卷，卷成绩，卷竞赛，卷项目；真正出保研成绩排名的时候，感觉天都塌下来了，这个rank不支持我去到华五及以上的学校，彷佛我就定格在了武大及以下，那一下午的我思想空洞，不知道三年的努力是为了什么，我仔细搜索了科大、浙大、复旦上交、北大清华的考研大纲，想要放弃保研通过考研走出自己想要的路，这个时候如果问我想要的路是什么？可能是不停地向上爬，爬到一个很好的学校，很棒的title才能证明自己的努力。和父母家人同学商议以后，大家都是在说不要放弃，先试试，武大也很不错等等话语，因为那个时候我怂，我懦弱，我不敢去做选择，我没有这个勇气，我还是妥协了，听取大家的意见，继续奋斗备战保研的夏令营和预推免。父母家人和朋友总是想让我们平平安安地活着，可是我是个喜欢赌的人，但是那个时候的我不是个固执的人。在三个月以后，我拿到了武大、北理、北航、信工所等学校的offer，也联系了一些导师，最后好似命运的安排般，我选了北航，来到了首都北京。还是那个注重title的我，他最后用好的title来决定硕士生涯。随着大学到了尾声，也逐渐发现自己越来越难地专注，就是那种心流状态，十分专注地做一件事情，感觉很难达到，希望自己能找回那种感觉，而不是被动功利性目的式去思考去学习。</p>\r\n<p>研究生最重要的是导师，当时联系导师的时候也很懦，不敢再去多一些尝试，总是把很多事情想的很顺利，实际并不是这样，顺利的事情是靠不顺利的人造就的。在整个大四生涯，我感受到来自我的导师的各种压力，组会科研，项目本子，学术分享，毕设进度，那个时候我已然对就业有些了解，但还是没能勇敢地说出来换导师，不过已经产生了这个念头。我知道了我想要什么，现在要做的就是去努力得到它。到了即将进入研究生的那个暑假，过了一个很难忘的生日，非常颓废，在家里的床上，吃了睡睡了吃，吃了焦虑，焦虑组会，焦虑和老师交流，然后不知道哪里来的勇气，我决定换导师了，我联系了新的导师，我写了一封很长很长的信，我的原导师人是很nice的，很快便同意了我的请求，我现在的导师就是一个很放养的导师，基本上没有什么事情，我的目标已经明确了，途径也很顺滑了，没有什么障碍了，我现在要做的任务就是实习、实习还是实习，学开发进厂，去做喜欢的，去做想要的吧。</p>\r\n<p>悟已往之不谏，知来者之可追。</p>\r\n<h1 id=\"我希望的研一\">我希望的研一</h1>\r\n<p>踏入硕士生活半月有余，上课才一整周，大概摸清了各个课程的结构内容，对整体的生活只感觉是<strong>形单影只衣单薄，心旷神飞无所指</strong>。研究生是一个人的生活，一定要明确目标，最终目标就是就业，我读研就是为了毕业有个985头衔，所以我希望的研一是这样的。</p>\r\n<p><strong>目标：</strong>期末不挂科为前提，学完Java实习的框架知识，力扣刷完基本结构＋Hot100</p>\r\n<p><strong>DDL：</strong>期末考试2025.01.13</p>\r\n<h2 id=\"上学期规划\">上学期规划</h2>\r\n\n<div class=\"markmap-container\" style=\"height:800\">\n  <svg data=\"{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,30]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;学习&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;学分课程&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;数学类：矩阵/最优化跟上课，省时间、为复习做铺垫&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;其他：做好汇报不挂科，不急不卷不浪费&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;实习准备&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Java八股:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Java基础，Java集合，Java并发，JVM以及其他&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;计算机基础:计算机网络，操作系统，计算机组成&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;数据库:MySQL，Redis基本操作&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;框架学习:Spring，SpringBoot，设计模式，常用工具(Git,Maven,Docker)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;实战项目&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;JavaWeb课程→外卖项目→AI若依（黑马路线）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;改编一个项目(黑马头条，学成在线，尚硅谷尚庭公寓等)-&amp;gt;完整手撕（待定项目）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;算法力扣&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;按框架刷代码随想录&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;hot100+剑指offer&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;多次刷多轮刷&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;兴趣&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;阅读练字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;读书：希望大量阅读各类感兴趣的书籍，纸质版/电子书，静下心去读； 针对书中好的句子进行摘抄，顺便练习钢笔字&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;学习摄影：摄影课程的学习+相机购买+实战运用&quot;}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,38]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;锻炼&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;跑步：中长跑，每日坚持，循序渐进，&lt;strong&gt;目标&lt;/strong&gt;超过3km/15分钟&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;游泳：1.考深水证  2.蛙泳可以连续500  3.学会自由泳&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;无氧增肌：1.腹肌训练（按照NEXTworkout每天一组 + 其他教程的5*4组）  2.胸肌/肱二头肌（引体向上，每次跑步后）&quot;}]}]}],&quot;p&quot;:{}}\"></svg>\n</div>\n\r\n","categories":["杂记"],"tags":["规划","研究生生活","思维导图"]},{"title":"星食链——Java学习总结","url":"/2024/12/17/%E6%98%9F%E9%A3%9F%E9%93%BE%E2%80%94%E2%80%94Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<h1\r\nid=\"点餐系统搭建java项目总结报告\">点餐系统搭建——Java项目总结报告</h1>\r\n<p>开学以来到10月底先是以课内课程和准备英语免修为主，在考完英语免修以后开始系统学习<strong>黑马程序员</strong>的2024JavaWeb课程，其中并没有更新完毕的部分参考2023课程和飞书云文档自己学完了；此后便开始学习《苍穹外卖》项目，全程跟敲了所有内容，在外卖项目结束，为了提高自己对于Redis以及其他中间件的学习使用，在原基础上增加了秒杀优惠券业务，学习了RabbitMQ队列，下面的项目涉及的技术选型</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"星食链项目技术报告\">《星食链》项目技术报告</h2>\r\n<p>“星食链”是一款为餐饮行业量身定制的全新智能餐饮服务平台，旨在通过科技驱动餐饮业的数字化转型，提升餐饮企业的运营效率和用户体验。作为一个面向商家与消费者的双向平台，<strong>星食链</strong>不仅能帮助餐饮企业优化日常管理流程、提升数据分析能力，还为消费者提供便捷的智能订餐体验。以下是技术层面的总结内容：</p>\r\n<h3 id=\"前端技术栈\">1. 前端技术栈</h3>\r\n<p><strong>系统管理后台</strong>： 前端采用了 H5 技术结合\r\n<strong>Vue.js</strong> 和 <strong>ElementUI</strong> 构建，利用 Vue.js\r\n的组件化思想和 ElementUI\r\n提供的丰富组件来实现管理后台的页面交互。同时，我们还使用 <strong>Apache\r\nECharts</strong>\r\n进行数据可视化展示，帮助餐饮企业更好地分析运营数据。</p>\r\n<p><strong>小程序端</strong>： 为了适应移动端用户的需求，我们使用\r\n<strong>微信小程序</strong>\r\n开发了消费者端应用，实现了菜品浏览、购物车管理、在线下单、支付、催单等功能。</p>\r\n<h3 id=\"网关层\">2. 网关层</h3>\r\n<p><strong>Nginx</strong>： Nginx 作为 Web\r\n服务器，承担了静态资源的托管以及反向代理和负载均衡的职责。在项目部署时，我们通过\r\nNginx 实现了 Tomcat\r\n的负载均衡，提高了系统的可扩展性和高并发处理能力。</p>\r\n<h3 id=\"应用层\">3. 应用层</h3>\r\n<p><strong>Spring Boot</strong>： 项目使用 <strong>Spring Boot</strong>\r\n框架快速构建，采用了 \"约定优于配置\"\r\n的开发模式，简化了配置过程，并加速了开发进程。</p>\r\n<p><strong>Spring MVC</strong>： 我们使用 <strong>Spring MVC</strong>\r\n来处理 Web 请求，Spring MVC\r\n的高度模块化让我们能够方便地进行控制器管理。</p>\r\n<p><strong>Spring Task</strong>：\r\n为了定时执行一些任务，如发送通知等，项目集成了 <strong>Spring\r\nTask</strong> 定时任务框架，支持定时任务调度。</p>\r\n<p><strong>HttpClient</strong>： 用于向其他系统发送 HTTP 请求，集成了\r\n<strong>HttpClient</strong> 库来简化网络请求的操作。</p>\r\n<p><strong>Spring Cache</strong>： 为提高系统性能，项目使用了\r\n<strong>Spring Cache</strong> 框架进行数据缓存，减少了数据库的负载。</p>\r\n<p><strong>JWT</strong>： 通过 <strong>JWT (JSON Web Token)</strong>\r\n进行用户身份验证，确保每次请求的安全性和一致性。</p>\r\n<p><strong>阿里云 OSS</strong>： 为了方便管理用户上传的图片和文件使用了\r\n<strong>阿里云 OSS</strong> 进行文件存储，利用 Spring Boot 自动配置集成\r\nOSS 服务。</p>\r\n<p><strong>Swagger</strong>： 为了提升开发和测试效率，我们使用了\r\n<strong>Swagger</strong> 自动生成 API 文档，并且可以通过 Swagger\r\n进行接口测试。</p>\r\n<p><strong>POI</strong>： 项目中有涉及到 Excel\r\n文件的导入和导出功能，使用了 <strong>POI</strong> 库来封装对 Excel\r\n文件的常用操作。</p>\r\n<p><strong>WebSocket</strong>： 为了实现实时消息推送，我们通过\r\n<strong>WebSocket</strong>\r\n实现了订单推送、催单等功能，使得用户能够即时获取订单进度。</p>\r\n<p><strong>AOP</strong>： 项目中使用了 <strong>AOP\r\n(面向切面编程)</strong>\r\n技术，通过切面来处理跨越多个模块的逻辑，如日志记录、权限检查等，提升了系统的模块化和可维护性。</p>\r\n<h3 id=\"数据层\">4. 数据层</h3>\r\n<p><strong>MySQL</strong>： 核心业务数据都使用 <strong>MySQL</strong>\r\n存储，利用其关系型数据库特性来处理各种复杂的查询和数据管理需求。</p>\r\n<p><strong>Redis</strong>： 为了解决高并发下的数据访问问题，使用\r\n<strong>Redis</strong>\r\n来缓存热点数据，提高了数据访问的效率。项目实现了缓存的多种策略，包括缓存穿透、缓存击穿和缓存雪崩等问题的解决方案。</p>\r\n<p><strong>Mybatis</strong>： 项目使用 <strong>Mybatis</strong>\r\n作为数据持久层框架，简化了 SQL\r\n操作和对象映射，增强了代码的可读性和可维护性。</p>\r\n<p><strong>Mybatis-Plus</strong>： 在 <strong>Mybatis</strong>\r\n基础上，我们还引入了 <strong>Mybatis-Plus</strong> 来简化 CRUD\r\n操作，减少了开发者的工作量。</p>\r\n<h3 id=\"消息队列与异步处理\">5. 消息队列与异步处理</h3>\r\n<p><strong>RabbitMQ</strong>： 项目中有复杂的秒杀业务，我们将\r\n<strong>RabbitMQ</strong>\r\n作为异步消息队列，处理秒杀过程中的高并发请求，提高了系统的响应速度和吞吐量。</p>\r\n<p><strong>Lua脚本</strong>：\r\n为了实现秒杀的高性能操作，同时确保Redis操作的原子性，利用 Redis\r\n的计数器功能配合 Lua 脚本实现了秒杀的快速库存扣减。</p>\r\n<h3 id=\"并发控制与优化\">6. 并发控制与优化</h3>\r\n<p><strong>Redisson 互斥锁</strong>：\r\n为了解决高并发下的资源竞争问题，项目使用了 <strong>Redisson</strong>\r\n实现互斥锁，确保在并发场景下对共享资源（如库存）的操作是安全的，避免了出现超卖等问题。Redisson\r\n提供的分布式锁机制极大地提升了分布式环境下的并发控制能力，确保在秒杀等高并发操作中数据的准确性和一致性。</p>\r\n<p><strong>缓存优化</strong>：\r\n为了解决缓存击穿、缓存穿透和缓存雪崩等问题，我们在 Redis\r\n中采用了互斥锁来控制并发访问，确保缓存的稳定性。</p>\r\n<h3 id=\"测试与工具\">7. 测试与工具</h3>\r\n<p><strong>Git</strong>： 在团队开发中，我们使用 <strong>Git</strong>\r\n进行版本控制，确保代码的版本管理和团队协作顺畅。</p>\r\n<p><strong>Maven</strong>： 项目采用 <strong>Maven</strong>\r\n作为构建工具，自动化管理依赖和构建过程。</p>\r\n<p><strong>JUnit</strong>： 通过 <strong>JUnit</strong>\r\n进行单元测试，确保每个模块的功能正确性，提升了代码的稳定性。</p>\r\n<p><strong>ApiFox</strong>： 在接口开发过程中，我们使用\r\n<strong>ApiFox</strong> 进行接口调试和测试，模拟各种 HTTP 请求，确保 API\r\n的高效与准确。</p>\r\n<h1 id=\"总结\">总结</h1>\r\n<p>整体来说：<strong>后端基于 Spring Boot 构建，采用了 SpringMVC 和\r\nMybatis 技术栈，结合 Mybatis-Plus\r\n提供了简洁且灵活的开发方式；此外，增加了优惠券业务，使用 Redis\r\n分布式锁和消息队列实现分布式架构，支持高并发秒杀活动，利用RabbitMQ中间件实现消息队列。</strong></p>\r\n","categories":["进厂学习记录"],"tags":["SpringBoot","点餐系统","JavaWeb","Redis"]},{"title":"博客搭建与发布教程","url":"/2024/03/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/","content":"<p><strong>记录一下博客搭建的整个历程，包括日后新增一些实现的功能</strong></p>\r\n<h1 id=\"博客搭建\">博客搭建</h1>\r\n<p>主要参考：<a\r\nhref=\"https://blog.csdn.net/qq_62928039/article/details/130248518\">Hexo+GitHub搭建个人博客教程（2023最新版）_hexo\r\ngithub个人网站教程-CSDN博客</a></p>\r\n<p><em>这篇CSDN的搭建教程，感谢博主，以下教程纯属自用，一些图片也是摘自此博主的</em></p>\r\n<span id=\"more\"></span>\r\n<p><strong>搭建思路：</strong></p>\r\n<p>1.利用<a href=\"https://hexo.io/zh-cn/index.html\">Hexo</a>\r\n一款快速、简洁且高效的博客框架，允许用户使用Markdown语言编写内容，并渲染成静态网页，其相当于一个网站的主题模块；</p>\r\n<p>2.利用GithubPages：Github Pages 是 Github\r\n官方提供的一个静态站点托管服务，它允许用户将 GitHub\r\n仓库中的代码转换为可访问的网站。借助 Github\r\nPages，我们不需要购买服务器也能部署我们的网站。</p>\r\n<p>这两款工具进行博客的整体搭建</p>\r\n<h2 id=\"安装本地环境\">1.1 安装本地环境</h2>\r\n<h3 id=\"node.js环境\"><strong>1.node.js环境：</strong></h3>\r\n<p>安装 nodejs， 因为Hexo是基于 Node.js 驱动的一款博客框架：<a\r\nhref=\"http://nodejs.cn/\">下载地址</a></p>\r\n<h3 id=\"git环境\"><strong>2.git环境：</strong></h3>\r\n<p>Git\r\n是一种<strong>分布式版本控制系统</strong>，即，代码的本地克隆就是一个完整的版本控制存储库，利用git可以进行版本控制，<strong>内容管理</strong></p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/git-process.png\"\r\nalt=\"git工作流程\" />\r\n<figcaption aria-hidden=\"true\">git工作流程</figcaption>\r\n</figure>\r\n<p>Git\r\n各平台安装包下载地址为：http://git-scm.com/downloads，一路next；</p>\r\n<p><strong>安装完毕后的检查</strong>——打开cmd命令</p>\r\n<p><strong>查看node.js版本：</strong>node -v</p>\r\n<p><strong>查看git版本：</strong>git --version</p>\r\n<p>在开始菜单里找到\"Git\"-&gt;\"Git Bash\"，会弹出 Git\r\n命令窗口，你可以在该窗口进行 Git\r\n操作；或在桌面或文件夹任意位置右键，列表中会出现：<strong>Open Git GUI\r\nhere 和 Open Git Bash here</strong></p>\r\n<p>接下来创建一个文件夹，是存放你的博客的目录，如D-&gt;blog文件夹（后续我们称为博客根目录），在当前文件夹中，右键，点击Open\r\nGit Bash here，在弹出的Git命令窗口进行如下操作</p>\r\n<h3 id=\"安装hexo\"><strong>3.安装hexo</strong>：</h3>\r\n<p>首先为了防止网络问题（国外服务器），先安装配置镜像：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\r\n<p>然后安装hexo和初始化</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm install -g hexo-cli</span><br><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\r\n<p>初始化成功后文件夹会出现许多文件：</p>\r\n<ol type=\"1\">\r\n<li>**__config.yml**：这是 Hexo\r\n的配置文件，你可以在这里设置博客的各种配置选项，比如标题、描述、主题等。</li>\r\n<li><strong>node_modules</strong>：这个文件夹包含了博客依赖的所有\r\nNode.js 模块，例如 Hexo 自身和其他插件。</li>\r\n<li><strong>scaffolds</strong>：在这个文件夹中，你可以放置一些模板文件，用于创建新文章或页面时的默认结构。</li>\r\n<li><strong>source</strong>：这个文件夹包含了你的博客的源文件，比如文章、页面、静态资源等。</li>\r\n<li><strong>themes</strong>：在这里存放着博客的主题文件，你可以根据需要选择或自定义主题。</li>\r\n<li><strong>db.json</strong>：这是 Hexo\r\n的数据库文件，用于存储一些数据，比如文章列表、标签等。</li>\r\n<li><strong>package.json</strong> 和\r\n<strong>package-lock.json</strong>：这两个文件是 Node.js\r\n项目的配置文件，包含了项目的依赖信息和版本信息。</li>\r\n<li><strong>public</strong>：这个文件夹包含了生成的静态网页文件，当你执行\r\n<code>hexo generate</code> 命令后，生成的 HTML 文件就会保存在这里</li>\r\n</ol>\r\n<p>hexo\r\ninit以后，现在已经有一个默认的本地博客了，可以先预览看看，还会默认克隆一个\r\nLandscape 主题，这个默认的博客样式主题就是Landscape</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo server(hexo s)</span><br></pre></td></tr></table></figure>\r\n<p>命令行在运行，别关闭，然后打开浏览器，地址栏输入：localhost:4000</p>\r\n<p>即可看到第一篇默认的博客Hello World</p>\r\n<h2 id=\"github环境\">1.2 Github环境</h2>\r\n<p>注册Github账号并创建仓库，<a\r\nhref=\"https://github.com/\">GitHub官网</a></p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/eb7ebaec9e44a81ceb10449723eb93de.png\"\r\nalt=\"Github创建博客仓库\" />\r\n<figcaption aria-hidden=\"true\">Github创建博客仓库</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/541e294e44c08b6688a68385859c60a6.png\"\r\nalt=\"Github创建博客仓库\" />\r\n<figcaption aria-hidden=\"true\">Github创建博客仓库</figcaption>\r\n</figure>\r\n<p><strong>注意选择public</strong>\r\n<strong>注意仓库的取名格式：用户名.github.io(这将是以后的访问域名)</strong></p>\r\n<p>next以后会出现可选https和ssh，选择ssh</p>\r\n<h2 id=\"本地gitpage绑定\">1.3 本地GitPage绑定</h2>\r\n<p>我们首先设置ssh连接，SSH key 和 GitHub 绑定有以下几个好处：</p>\r\n<p>使用\r\nSSH，即安全外壳协议，可以加密通信内容，提高了数据传输的安全性。通过 SSH\r\nkey\r\n鉴权，可以避免传统密码登录方式可能存在的风险，增强账户的安全性，一旦将\r\nSSH key 添加到 GitHub 上，就无需每次使用 Git\r\n操作时都输入用户名和密码，减少了输入密码的繁琐过程，提高了工作效率，而且可以设置github上的SSH\r\nkey的有效时间，不用频繁更改加密连接；</p>\r\n<p><strong>首先在git Bash下</strong> 输入命令：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh           //进入.ssh文件</span><br><span class=\"line\">ssh-keygen -t rsa -C ‘注册时的邮箱地址(你的github邮箱地址)’</span><br></pre></td></tr></table></figure>\r\n<p>接着去查看C盘目录(此文件夹所在C:)，然后在记事本中打开id_rsa.put文件并复制生成的key（或者使用everything时间搜索id_rsa.put），这个时候生成了一个密钥</p>\r\n<p>将密钥配置到Github中：</p>\r\n<p><strong>在GitHub主页的头像下找到seething</strong> -&gt;\r\n<strong>然后点击SSH and GPG keys，点击New SSH key</strong></p>\r\n<p><strong>将刚刚在.ssh目录下所复制的id_rsa.put文件中的信息复制进key(注意空格)（名字随意）</strong></p>\r\n<p>接下来进行验证：</p>\r\n<p>在git中输入命令进行ssh验证：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com 并且输入yes之后，行末尾会显示你的用户名</span><br></pre></td></tr></table></figure>\r\n<p>会受到邮件提醒，成功绑定~</p>\r\n<p>然后输入命令进行本地绑定与Github的用户名和邮箱（git）：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name “注册时用户名”</span><br><span class=\"line\">git config --global user.email “注册时邮箱”</span><br></pre></td></tr></table></figure>\r\n<p>这样便连接完毕本地和Github了</p>\r\n<h2 id=\"博客访问域名\">1.4 博客访问域名</h2>\r\n<p>找到直接创建博客文件夹中的 _config.yml</p>\r\n<p>把文章末尾改成：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">        type: git</span><br><span class=\"line\">        repo: https://github.com/用户名/用户名.github.io.git</span><br><span class=\"line\"></span><br><span class=\"line\">                    （或者git@github.com:用户名/用户名.github.io.git）【推荐，我是用这个成功了，第一个未成功】</span><br><span class=\"line\">        branch: main(一定是main不能是master!!!)</span><br></pre></td></tr></table></figure>\r\n<p>注意，上面的type\r\nrepo和branch后面都有一个英文空格，输入以后保存文件，退出，博客便绑定成功</p>\r\n<h1 id=\"博客日常运行\">博客日常运行</h1>\r\n<p>我们刚才安装hexo时的的npm(Node Package Manager)和cnpm(淘宝镜像)都是\r\nNode.js 的包管理工具，用于在 Node.js\r\n项目中安装、升级、删除和管理依赖包，可以理解成<strong>应用商店</strong>，直接从此下载，类似conda\r\npip等命令</p>\r\n<h2 id=\"博客基本发布\">2.1 博客基本发布</h2>\r\n<p>hexo中带有很多的模块工具包以供我们使用，注意，此时你的hexo只是安装在了你的博客地址目录下，而不是全局目录，所以你想要查看现在有哪些包，即打开博客文件夹下的：<strong>node_modules</strong>：这个文件夹包含了博客依赖的所有\r\nNode.js 模块，例如 Hexo 自身和其他插件。</p>\r\n<p>我们为了上传本地博客到网页端，需要安装一个工具</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"上传流程\">上传流程</h3>\r\n<p>在博客的文件夹的git bash中依次输入：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean           //清除 Hexo 生成的缓存文件和静态文件</span><br><span class=\"line\">hexo new &quot;文章名称&quot;   //新建文章</span><br><span class=\"line\">// 新建文章后，在 source-&gt;_posts文件夹中可以看到.md文件，进行编辑文件</span><br><span class=\"line\">hexo s              //文章预览，s是source的意思</span><br><span class=\"line\">hexo g              //generate的意思，生成文件</span><br><span class=\"line\">hexo d              //部署到github上</span><br></pre></td></tr></table></figure>\r\n<p><strong>之后每次上传博客都是此顺序，部署之后可发现GitHub中多了文件，此时浏览器输入，用户名.github.io(Github仓库名)就可以访问博客啦</strong></p>\r\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">这是全角空格：Em Space:<span class=\"symbol\">&amp;emsp;</span>(别忘了分号)  <span class=\"symbol\">&amp;ensp;</span>半角空格</span><br><span class=\"line\"></span><br><span class=\"line\">这是空行 ASCII码：<span class=\"symbol\">&amp;#160;</span></span><br><span class=\"line\"></span><br><span class=\"line\">这是换行 HTML：<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>A空格了吗？  B</p>\r\n<p>C 空行了吗？</p>\r\n<p> </p>\r\n<p>D换行了吗？<br></p>\r\n<h2 id=\"博客的进阶操作\">2.2 博客的进阶操作</h2>\r\n<p><em>说是进阶操作，其实就是为了让文章部署在网页时，可以满足一些在markdown中可以实现的基本需求，我的需求仅仅有四项</em>：</p>\r\n<p><strong>换个自己喜欢的主题，图片的上传管理、数学公式的编辑和每篇文章有个目录\r\nor 标签，便于文件夹管理访问</strong></p>\r\n<h3 id=\"主题更换\">1.主题更换</h3>\r\n<p>当前博客的主题是next哦~：<strong><a\r\nhref=\"https://link.zhihu.com/?target=https%3A//github.com/next-theme/hexo-theme-next\">hexo-theme-next</a></strong>应该是目前最广泛使用的hexo主题了，优点是简洁，定制度高，因为代码是开源的，所以有很多开发者维护。由于前任管理员不提供权限，故开发了一个新的分支，<strong><a\r\nhref=\"https://link.zhihu.com/?target=https%3A//github.com/next-theme/hexo-theme-next/issues/4%23issuecomment-626205848\">详情</a></strong>。</p>\r\n<p>打开你的博客文件夹的themes子文件夹，可以看到有哪些主题，默认应该就有一个landscape，是我们当时初始化hexo\r\ninit下载的</p>\r\n<p>在网站：https://hexo.io/themes/中可以找到很多主题</p>\r\n<p>这里以 hexo-theme-next\r\n这个主题为例做一下说明，打开你的博客根目录文件夹，在git bash中输入：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone --branch v7.8.0 https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class=\"line\"></span><br><span class=\"line\">git clone --branch v7.8.0 git@github.com:theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\r\n<p>版本是自己选择的，下载以后会发展博客根目录文件下的\r\nthemes文件夹多了一个next文件夹，即我们下载的主题</p>\r\n<p>然后在博客根目录文件夹的站点配置文件_config.yml（之前1.4节配置绑定github时用过），\r\n找到 theme 字段，并将其后面的值更改为 next即可</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo s //进入localhost:4000看看主题效果</span><br></pre></td></tr></table></figure>\r\n<p>需要修改此主题的一些内容细节：如增加评论，添加搜索，修改样式，增加广告等等等，可以参考修改next主题博客，如：</p>\r\n<p><a href=\"https://www.pengtech.net/hexo/\">hexo | 鹏叔的技术博客\r\n(pengtech.net)</a></p>\r\n<h3 id=\"图片的上传管理\">2.图片的上传管理</h3>\r\n<p>我尝试了很多方法，最后选择了图床的方式，即把图片上传到github上管理，而不是本地管理图片，网页在需要图片时从github页面获取即可</p>\r\n<p>参考：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/319679704\">搭建一个免费图床！彻底解决博客文章中图片存储问题！\r\n- 知乎 (zhihu.com)</a></p>\r\n<p><strong>图床：</strong>图床（Image Hosting\r\nService）是指提供在线图片存储和管理服务的网络平台。用户可以将图片上传到图床服务器，然后通过生成的图片链接来分享图片或在网页上显示这些图片。</p>\r\n<h4 id=\"a.安装配置picgo\">A.<strong>安装配置PicGo</strong>：</h4>\r\n<p>PicGo\r\n是一个用于快速上传图片并获取图片URL链接的工具，选择合适的版本并下载，可访问PicGo的官方文档进一步了解其功能和用法。我使用的是\r\nwin10系统，下载的是最新的版本。下载可能会很慢，可借助迅雷进行下载。下载后双击进行安装，注意不要安装在C盘。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/80/v2-e1e7d47b39f0ee903719d460f26d9750_720w.webp\"\r\nalt=\"Github创建图床仓库\" />\r\n<figcaption aria-hidden=\"true\">Github创建图床仓库</figcaption>\r\n</figure>\r\n<p>下载地址：<a\r\nhref=\"https://link.zhihu.com/?target=https%3A//github.com/Molunerfinn/PicGo/releases\">https://github.com/Molunerfinn/PicGo/releases</a></p>\r\n<p>使用指南：<a\r\nhref=\"https://link.zhihu.com/?target=https%3A//picgo.github.io/PicGo-Doc/zh/guide/\">https://picgo.github.io/PicGo-D</a></p>\r\n<p>可以在PicGo设置中先设置一下自己的喜好，现在看不懂没关系，下面配完以后实际上传了一个图片就明白了（注：图床的功能很强大，这里我们只是用了很小的一部分，用来上传到自己的个人博客中）</p>\r\n<p>PicGo 支持的图床很多，如七牛图床、腾讯云 COS、阿里云 OSS、Github\r\n图床、Gitee 图床等等，我们当然用免费的Github或者Gitee啦</p>\r\n<h4\r\nid=\"b.github新建一个仓库专门存放图片文件即图床仓库\">B.Github新建一个仓库专门存放图片文件，即图床仓库：</h4>\r\n<p><strong>新建Github仓库并生成Token：</strong></p>\r\n<ul>\r\n<li><p>注册 Github 用户</p></li>\r\n<li><p>在 Github 上新建一个用于存储的仓库，点击 New repository\r\n创建一个新仓库。</p></li>\r\n<li><p>生成一个 Personal access tokens</p></li>\r\n</ul>\r\n<p>在 Github 中依次点击<strong>Settings-&gt;Developer\r\nsettings-&gt;Personal access tokens-&gt;Generate new\r\ntoken</strong>，勾选 repo 权限，填写描述，然后点击 Generate token\r\n按钮，生成 token。由于生成的 token\r\n只会在第一次显示，建议<strong>保存下来备用</strong>，否则后续只能重新生成\r\ntoken。（一定要保存下来备用！！！）</p>\r\n<h4 id=\"c.打开picgo配置github图床\">C.打开PicGO配置Github图床</h4>\r\n<p>点击图床设置-&gt;Github图床：</p>\r\n<ul>\r\n<li>设定仓库名：按照照“用户名/仓库名”的格式填写，比如我的ning565/picblog（终究首反应还是没能驼峰命名）</li>\r\n<li>设定分支名：默认主分支 main 即可。</li>\r\n<li>设定 Token：将之前生成的 token 复制粘贴到这里。</li>\r\n<li>指定存储路径：github的那个图床仓库目录下的子目录，默认是根目录。</li>\r\n<li>设定自定义域名：自定义域名的作用是在上传图片后成功后，PicGo\r\n将以“自定义域名+子目录名+图片名”生成访问连接。这里我们的自定义域名为：<a\r\nhref=\"https://link.zhihu.com/?target=https%3A//cdn.jsdelivr.net/gh/\">https://cdn.jsdelivr.net/gh/</a>用户名/仓库名，用的是<a\r\nhref=\"https://link.zhihu.com/?target=http%3A//cdn.jsdelivr.net\">http://cdn.jsdelivr.net</a>提升图片的加载速度。</li>\r\n</ul>\r\n<h4 id=\"d.typora配置picgo\">D.Typora配置PicGo</h4>\r\n<p>我们每次写博客都是利用Typora软件，然后在其中插入图片等等，我们需要实现在Typora中插入的任一图片都直接通过PicGo软件上传到Github的图床仓库中，这样在hexo\r\nd上传博客时才能从图床仓库取图片</p>\r\n<p>依次点击Typora的文件 -&gt; 偏好设置 -&gt; 图像</p>\r\n<p>插入图片时选择上传图片</p>\r\n<p>上传服务设定中，上传服务选择PicGo，路径选择PicGo.exe所在路径，然后进行验证上传，等待一段时间，windows系统电脑右下角出现弹窗上传成功，即代表着成功上传，此时图片便成功部署了，每次直接在typora中放的图片都能直接显示在网页中</p>\r\n<h2 id=\"数学公式编辑\">3.数学公式编辑</h2>\r\n<p>参考：<a\r\nhref=\"https://blog.csdn.net/qq_44846324/article/details/114582328\">这次彻底解决在Hexo中渲染MathJax数学公式出现的问题！！！_uninstall\r\nhexo-renderer-marked失败-CSDN博客</a></p>\r\n<p><a\r\nhref=\"https://pku-zyf.github.io/formula/\">Hexo渲染数学公式：配置方法与原理浅释\r\n| 明 (pku-zyf.github.io)</a></p>\r\n<p><a\r\nhref=\"https://xxxpt.blog.csdn.net/article/details/109052860\">用Github\r\nPages+Hexo搭建博客之(十)Hexo博客next主题MathJax数学公式渲染问题_github\r\n个人博客数学公式-CSDN博客</a></p>\r\n<p>在Markdown文档编写中，我们可以使用LATEX的语法输入数学公式。常见的Markdown编辑器如Typora都可以方便地渲染数学公式。然而，Hexo在默认设置下部署博客时，并不能渲染数学公式。</p>\r\n<p>原因在于，<strong>渲染数学公式需要使用MathJax</strong>（一种模块化的JavaScript框架）；而Hexo的默认渲染器是hexo-renderer-marked（在目录根目录下的modules看到）引擎，它并不支持MathJax。</p>\r\n<p>更换一个渲染引擎即可：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>\r\n<p>然后在主题next目录配置文件中_config.yml：</p>\r\n<p>修改perpage为true mathjax后面的enable为true</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Math Formulas Render Support</span><br><span class=\"line\">math:</span><br><span class=\"line\">  # Default (true) will load mathjax / katex script on demand.</span><br><span class=\"line\">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class=\"line\">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class=\"line\">  per_page: true</span><br><span class=\"line\"></span><br><span class=\"line\">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class=\"line\">  mathjax:</span><br><span class=\"line\">    enable: true</span><br></pre></td></tr></table></figure>\r\n<p>切记：我最初在操作的时候，各种急着下载模块，不仅用了mathjax还用了很多modules，下载的很乱，一定先认准一个方法配置，如果配不好，先卸载了刚才下载的module，再重新找方法找module下载，某些module不能在一起共存的，欲速则不达</p>\r\n<h2 id=\"为文章设置目录标签\">4.为文章设置目录/标签</h2>\r\n<p>在博客文件夹根目录下打开Git bash，然后执行</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page categories</span><br></pre></td></tr></table></figure>\r\n<p>此时，在source 目录中会生成一个 categories 文件夹，文件夹内有一个\r\nindex.md 文件，打开此文件，将其中的 type 字段的值修改为 categories</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\r\n<p>创建标签的方式一样：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br><span class=\"line\">//在tag文件夹中的index.md中</span><br><span class=\"line\">...</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\r\n<p>为每篇文章设置：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new &quot;文章名称&quot;</span><br></pre></td></tr></table></figure>\r\n<p>以后，在文章开头部分会自动添加如下内容：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 博客搭建与发布教程</span><br><span class=\"line\">date: 2024-03-15 12:10:21</span><br><span class=\"line\">tags:</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- 入门使用</span><br></pre></td></tr></table></figure>\r\n<p>像我这样，在categories或者tages的下一行 输入：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- &quot;目录/标签名称&quot;   //注意减号后面的空格哦~</span><br></pre></td></tr></table></figure>\r\n<p>Contining~~~</p>\r\n<p>如果以后有用到其他的博客内容再更新嗷~</p>\r\n","categories":["入门使用"]},{"title":"基本框架增加优惠券业务","url":"/2024/12/17/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%A2%9E%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%9A%E5%8A%A1/","content":"<h1 id=\"一秒杀业务note重点\">一、秒杀业务note重点</h1>\r\n<h2 id=\"i-短信登录\">I 短信登录</h2>\r\n<h3 id=\"redis替换session的具体细节和操作流程\">1.1\r\nRedis替换Session的具体细节和操作流程</h3>\r\n<p>1.存储短信验证码时，key-value分别是phone和code，均为String类型（唯一性、方便携带），存储User对象时，采用hash类型（json格式数据）</p>\r\n<p>2.存储用户数据/需要返回给前端时，用phone作key不合适，暴露隐私，在后台生成一个随机串token（利用令牌技术）设置过期时间，完成识别认证</p>\r\n<p>3.利用UUID随机生成token，将User对象转为Map（定制 beanToMap\r\n转换行为），将<strong>每个字段的值</strong>转换为 String\r\n类型，存储后返回token</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"状态登录刷新解决方案\">1.2 状态登录刷新解决方案</h3>\r\n<p>设置两个拦截器，第一个拦截器拦截所有路径（拦截而不处理return\r\ntrue），仅用于刷新token时间，同时将前来认证/访问的User放入ThreadLocal（利用UserHolder，自定义的工具类，存放读取线程池的信息）；</p>\r\n<p>第二个拦截器做真正的拦截功能，拦截所有需要登录才能访问的路径，随后注册配置两个拦截器，注意先执行第一个拦截器，配置order</p>\r\n<h2 id=\"ii-商户查询缓存\">II 商户查询缓存</h2>\r\n<h3 id=\"缓存更新策略双写一致\">2.1 缓存更新策略、双写一致</h3>\r\n<p>原本的添加缓存的机制为，提交商铺id、查询缓存、命中返回商铺信息，未命中去数据库查（数据库不存在该商铺返回404）、存在该商铺写入Redis，返回商铺信息</p>\r\n<p>内存数据有限宝贵，不可以redis插入太多数据，适当更新机制：</p>\r\n<p><strong>内存淘汰：</strong>自动进行，redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>\r\n<p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除</p>\r\n<p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和<strong>数据库不一致</strong>问题</p>\r\n<p>低一致性需求：内存淘汰</p>\r\n<p>高一致性需求：主动更新为主、超时为辅</p>\r\n<h4 id=\"解决一致性问题\">解决一致性问题</h4>\r\n<p>数据库数据域发生变化后，缓存数据没有同步，产生一致性问题</p>\r\n<p><strong>解决方式：主动更新</strong>，实现方案：</p>\r\n<p>Cache Aside Pattern\r\n缓存调用者在更新完数据库后去更新缓存，称之为<strong>双写方案</strong>（主要采用）</p>\r\n<p><em>利用缓存服务：</em></p>\r\n<p><em>Read/Write Through Pattern :\r\n由<strong>系统本身</strong>完成，数据库与缓存的问题交由系统本身去处理，调用者无需关心一致性</em></p>\r\n<p><em>Write Behind Caching Pattern\r\n：调用者只操作缓存，<strong>其他线程去异步</strong>处理数据库，实现最终一致</em></p>\r\n<h4 id=\"双写一致方案\">双写一致方案</h4>\r\n<p>采用双写一致方案，明确操作内容：</p>\r\n<p>1.每次更新动作是直接删除缓存，而非更新</p>\r\n<p>2.缓存与数据库的操作的同时成功或失败，采用一个<strong>事务</strong></p>\r\n<p>3.先操作数据库，再删除缓存，why：</p>\r\n<ul>\r\n<li>方案一：两个线程并发来访问时，线程1先来，删除缓存还没来得及更新数据库；此时线程2查询缓存数据并不存在，故查询旧数据库获取旧数据写入缓存；线程1再执行更新数据库动作时，造成数据库和缓存不一致</li>\r\n<li>方案二：当缓存失效时（时间等各原因），线程1查发现没有，查数据库旧数据，此时线程2先更新数据库改为新数据，然后删除缓存（本来就是空）相当于没删，此时线程1来写缓存，写的是旧数据（但发生的概率较小，先更新数据库）</li>\r\n</ul>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653323595206.png\" alt=\"1653323595206\" style=\"zoom:50%;\" /></p>\r\n<p>住：写缓存是ums级别的，但数据库操作比写缓存时间多很多</p>\r\n<p><strong>实现：</strong></p>\r\n<p>查询操作：在ShopServiceImpl的queryById方法中：<strong>设置redis缓存时添加过期时间</strong></p>\r\n<p>修改确保双写一致操作：在update方法中，<strong>先更新数据库再删除缓存</strong></p>\r\n<h3 id=\"缓存穿透问题\">2.2 缓存穿透问题</h3>\r\n<p>缓存穿透是指客户端恶意请求数据在缓存中和数据库中都不存在，这些请求都会打到数据库。</p>\r\n<p><strong>解决方案：</strong></p>\r\n<ul>\r\n<li>缓存空对象：访问数据库也不存在的数据时，把这个数据存入到redis中，给null，下次来访问直接返回个null\r\n<ul>\r\n<li>实现简单，额外内存消耗，缓存中需要存储\r\n带TTL的null，短期不一致（后来此字段出现了）</li>\r\n</ul></li>\r\n<li>布隆过滤：在客户端访问到达redis前，设置布隆过滤器，哈希思想，通过一个庞大的二进制数组，判断当前这个要查询的这个数据是否存在（存在放行，不存在拒绝）\r\n<ul>\r\n<li>内存占用较少，没有多余key，实现复杂，误判可能</li>\r\n</ul></li>\r\n</ul>\r\n<p>主动解决方案：</p>\r\n<ul>\r\n<li>增强id的复杂度</li>\r\n<li>避免被猜测id规律</li>\r\n<li>做好数据的基础格式校验</li>\r\n<li>加强用户权限校验</li>\r\n<li>做好热点参数的限流</li>\r\n</ul>\r\n<h4 id=\"缓存空对象解决\">缓存空对象解决</h4>\r\n<p>原本：发现这个数据在mysql中不存在，直接就返回404</p>\r\n<p>现在：会把这个数据写入到Redis中，并且将value设置为\"\"，再次查询时，判断value为null，则为之前写的空数据，直接返回；</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">     <span class=\"comment\">// 1、从redis中查询商铺缓存</span></span><br><span class=\"line\">     <span class=\"type\">String</span> <span class=\"variable\">shopJson</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">     <span class=\"comment\">// 2、判断是否存在</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 存在,直接返回</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//判断命中的值是否是空值，说明此时shopJson有值，但是为blank（上一步没判断出来的），是奇怪的</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (shopJson != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//返回一个错误信息</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"><span class=\"comment\">// 5.不存在，采用缓存空对象解决</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(shop == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">          <span class=\"comment\">//将空值写入redis</span></span><br><span class=\"line\">         stringRedisTemplate.opsForValue().set(key,<span class=\"string\">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class=\"line\">         <span class=\"comment\">//返回错误信息</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">     &#125;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"缓存击穿问题\">2.3 缓存击穿问题</h3>\r\n<p>缓存击穿问题也叫<strong>热点Key问题</strong>，某个被高并发访问并且缓存重建业务较复杂的key突然<strong>失效</strong>了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>\r\n<p>线程1查询缓存，未命中，去查询数据库然后重建缓存数据（耗费时间较长），在此过程中，若干线程执行同线程1的操作，同时在访问数据库执行重建操作；</p>\r\n<p><strong>解决方案：</strong></p>\r\n<h4 id=\"互斥锁\">互斥锁</h4>\r\n<p>锁能实现互斥性，第一个查询未命中的线程在重建的时候获得锁的资源，其他之后的线程来没有锁的资源，无法访问到数据库，只能休眠等待（定期回到查询缓存步骤），直到线程1释放锁。</p>\r\n<ul>\r\n<li>让查询的性能从并行变成了串行，只能一个线程在操作，其他在休眠，效率低；死锁风险</li>\r\n<li>实现简单，无额外内存消耗</li>\r\n<li>牺牲可用性，保证一致性</li>\r\n</ul>\r\n<p>实现思路：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653357860001-1734362376722.png\"\r\nalt=\"1653357860001\" />\r\n<figcaption aria-hidden=\"true\">1653357860001</figcaption>\r\n</figure>\r\n<p>核心思路：</p>\r\n<ul>\r\n<li>获取锁的方式：利用redis的<strong>setnx方法</strong>（redis中如果没有这个key，则插入成功，返回1/true，如果存在这个key，则插入失败）</li>\r\n<li>利用key-\"1\"，setIfAbsent方法，如果存在这个资源则不会操作，成功插入key的线程认为获得了锁；删除这个key-value即代表释放锁</li>\r\n</ul>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock:shop:&quot;</span> + id;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> tryLock(lockKey);</span><br><span class=\"line\"> <span class=\"comment\">// 4.2 判断否获取成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!isLock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//4.3 失败，则休眠重试</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queryWithMutex(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//4.4 成功，根据id查询数据库</span></span><br><span class=\"line\">    shop = getById(id);</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">// 释放互斥锁</span></span><br><span class=\"line\">    unlock(lockKey);</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"逻辑过期\">逻辑过期</h4>\r\n<p>逻辑过期：为key-value不设置实际的TTL，存储他们的时候采用一个expireTime字段，每次都需要判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则当前线程直接返回过期数据，同时开启一个独立线程，独立线程去获取锁重构数据，重构完成后释放互斥锁。</p>\r\n<ul>\r\n<li>线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据</li>\r\n<li>不保证一致性，有额外的内存消耗，且实现复杂</li>\r\n<li>牺牲一致性，提高性能</li>\r\n</ul>\r\n<p>实现思路：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653360308731-1734362376722.png\"\r\nalt=\"1653360308731\" />\r\n<figcaption aria-hidden=\"true\">1653360308731</figcaption>\r\n</figure>\r\n<p><strong>核心思路：</strong></p>\r\n<p>现在redis中存储的数据的value需要带上过期时间，采用<strong>组合方式</strong>，<strong>对原来代码没有侵入性</strong>：</p>\r\n<p>新定义一个实体类：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisData</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LocalDateTime expireTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\r\n<p>修改<strong>ShopServiceImpl</strong>代码：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.命中，需要先把json反序列化为对象</span></span><br><span class=\"line\">    <span class=\"type\">RedisData</span> <span class=\"variable\">redisData</span> <span class=\"operator\">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class=\"line\">    <span class=\"type\">Shop</span> <span class=\"variable\">shop</span> <span class=\"operator\">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class=\"line\">    <span class=\"type\">LocalDateTime</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> redisData.getExpireTime();</span><br><span class=\"line\">    <span class=\"comment\">// 5.判断是否过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5.1.未过期，直接返回店铺信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> shop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 5.2.已过期，需要缓存重建,开启新线程获取互斥锁重建</span></span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_SHOP_KEY + id;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> tryLock(lockKey);</span><br><span class=\"line\">    <span class=\"comment\">// 6.2.判断是否获取锁成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock)&#123;</span><br><span class=\"line\">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//重建缓存</span></span><br><span class=\"line\">                <span class=\"built_in\">this</span>.saveShop2Redis(id,<span class=\"number\">20L</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                unlock(lockKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 6.4.返回过期的商铺信息</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> shop;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"缓存雪崩问题\">2.4 缓存雪崩问题</h3>\r\n<p>缓存雪崩是指在同一时段<strong>大量的缓存key</strong>同时失效或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。(服务器本身的问题)</p>\r\n<p>解决方案：</p>\r\n<ul>\r\n<li>给不同的Key的TTL添加随机值（避免TTL一起到期）</li>\r\n<li>利用Redis集群提高服务的可用性（Redis哨兵机制）</li>\r\n<li>给缓存业务添加降级限流策略</li>\r\n<li>给业务添加多级缓存（不仅在service缓存，nginx也可以缓存，数据库等）</li>\r\n</ul>\r\n<h3 id=\"封装redis工具类\">2.5 封装Redis工具类</h3>\r\n<p>泛型是 Java 中引入的一种\r\n<strong>参数化类型</strong>，让类、接口和方法可以使用\r\n<strong>不确定的数据类型</strong>，泛型可以实现：代码重用、类型安全、增强可读性</p>\r\n<p>泛型通常通过 <code>&lt;T&gt;</code>、<code>&lt;R&gt;</code>\r\n等尖括号包裹的字母表示，其中：</p>\r\n<ul>\r\n<li><code>T</code>：表示类型（Type）。</li>\r\n<li><code>R</code>：表示返回类型（Return）。</li>\r\n<li><code>ID</code>：可以表示输入的参数类型（例如 ID）</li>\r\n</ul>\r\n<p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>\r\n<ul>\r\n<li><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</p></li>\r\n<li><p>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题</p></li>\r\n<li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用<strong>缓存空值的方式解决缓存穿透</strong>问题</p></li>\r\n<li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要<strong>利用逻辑过期解决缓存击穿</strong>问题</p></li>\r\n<li><p>方法5：根据指定的key查询缓存，并反序列化为指定类型，需要<strong>利用互斥锁解决缓存击穿</strong>问题</p></li>\r\n</ul>\r\n<p>将逻辑进行封装</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheClient</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置十个线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">CACHE_REBUILD_EXECUTOR</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CacheClient</span><span class=\"params\">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法1：设置过期时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法2：设置逻辑过期时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setWithLogicalExpire</span><span class=\"params\">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置逻辑过期</span></span><br><span class=\"line\">        <span class=\"type\">RedisData</span> <span class=\"variable\">redisData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RedisData</span>();</span><br><span class=\"line\">        redisData.setData(value);</span><br><span class=\"line\">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class=\"line\">        <span class=\"comment\">// 写入Redis</span></span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法3，利用泛型手段，不局限于Shop类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;R,ID&gt; R <span class=\"title function_\">queryWithPassThrough</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyPrefix + id;</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis查询商铺缓存</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"comment\">// type 用来帮助框架或工具进行对象的反序列化，即将字符串或JSON 转换为具体的对象类型R（type告诉方法：把 JSON 转换成 R 类型的对象）</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> JSONUtil.toBean(json, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中的是否是空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (json != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回一个错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        <span class=\"comment\">// 接受参数 ID 并返回 R 类型的函数</span></span><br><span class=\"line\">        <span class=\"type\">R</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> dbFallback.apply(id);</span><br><span class=\"line\">        <span class=\"comment\">// 5.不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将空值写入redis</span></span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(key, <span class=\"string\">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.set(key, r, time, unit);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法4：利用逻辑过期解决缓存击穿问题</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;R, ID&gt; R <span class=\"title function_\">queryWithLogicalExpire</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyPrefix + id;</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis查询商铺缓存</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.命中，需要先把json反序列化为对象</span></span><br><span class=\"line\">        <span class=\"type\">RedisData</span> <span class=\"variable\">redisData</span> <span class=\"operator\">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class=\"line\">        <span class=\"type\">R</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class=\"line\">        <span class=\"type\">LocalDateTime</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> redisData.getExpireTime();</span><br><span class=\"line\">        <span class=\"comment\">// 5.判断是否过期</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5.1.未过期，直接返回店铺信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 5.2.已过期，需要缓存重建</span></span><br><span class=\"line\">        <span class=\"comment\">// 6.缓存重建</span></span><br><span class=\"line\">        <span class=\"comment\">// 6.1.获取互斥锁</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_SHOP_KEY + id;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> tryLock(lockKey);</span><br><span class=\"line\">        <span class=\"comment\">// 6.2.判断是否获取锁成功</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLock)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class=\"line\">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 查询数据库</span></span><br><span class=\"line\">                    <span class=\"type\">R</span> <span class=\"variable\">newR</span> <span class=\"operator\">=</span> dbFallback.apply(id);</span><br><span class=\"line\">                    <span class=\"comment\">// 重建缓存</span></span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">                    unlock(lockKey);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.4.返回过期的商铺信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法5：利用互斥锁解决缓存击穿</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;R, ID&gt; R <span class=\"title function_\">queryWithMutex</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyPrefix + id;</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis查询商铺缓存</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">shopJson</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中的是否是空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shopJson != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回一个错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4.实现缓存重建</span></span><br><span class=\"line\">        <span class=\"comment\">// 4.1.获取互斥锁</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_SHOP_KEY + id;</span><br><span class=\"line\">        <span class=\"type\">R</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> tryLock(lockKey);</span><br><span class=\"line\">            <span class=\"comment\">// 4.2.判断是否获取成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4.3.获取锁失败，休眠并重试</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class=\"line\">            r = dbFallback.apply(id);</span><br><span class=\"line\">            <span class=\"comment\">// 5.不存在，返回错误</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将空值写入redis</span></span><br><span class=\"line\">                stringRedisTemplate.opsForValue().set(key, <span class=\"string\">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class=\"line\">                <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.set(key, r, time, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7.释放锁</span></span><br><span class=\"line\">            unlock(lockKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 8.返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 获得锁和释放锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class=\"string\">&quot;1&quot;</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BooleanUtil.isTrue(flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        stringRedisTemplate.delete(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在ShopServiceImpl\r\n中直接调方法<code>Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</code></p>\r\n<h2 id=\"iii-优惠券秒杀\">III 优惠券秒杀</h2>\r\n<h3 id=\"全局唯一id\">3.1 全局唯一ID</h3>\r\n<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>\r\n<ul>\r\n<li>id的规律性太明显</li>\r\n<li>受单表数据量的限制</li>\r\n</ul>\r\n<p><strong>全局ID生成器</strong>：为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653363172079-1734362376722.png\"\r\nalt=\"1653363172079\" />\r\n<figcaption aria-hidden=\"true\">1653363172079</figcaption>\r\n</figure>\r\n<p>永远为0</p>\r\n<p>时间戳：31bit，以秒为单位，可以使用69年</p>\r\n<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>\r\n<p><strong>实现</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.生成时间戳</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> LocalDateTime.now();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">nowSecond</span> <span class=\"operator\">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.生成序列号</span></span><br><span class=\"line\"><span class=\"comment\">// 2.1.获取当前日期，精确到天</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> now.format(DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2.2.自增长</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().increment(<span class=\"string\">&quot;icr:&quot;</span> + keyPrefix + <span class=\"string\">&quot;:&quot;</span> + date);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.拼接并返回，右移后 或 count，比加效率高</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"秒杀下单超卖问题\">3.2 秒杀下单超卖问题</h3>\r\n<p>数据库信息：</p>\r\n<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等\r\ntb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>\r\n<p>tb_order_voucher：订单表，在用户每次特价优惠券秒杀成功后，都会创建订单，在此表增加一项秒杀订单信息（订单id、用户id、代金券id）</p>\r\n<p>秒杀下单思考：下单时需要判断两点：</p>\r\n<ul>\r\n<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>\r\n<li>库存是否充足，不足则无法下单</li>\r\n</ul>\r\n<p><strong>超卖问题：</strong>线程1过来查询库存，判断库存大于1，正准备去扣减库存，还没扣；此时线程2也去查询库存，发现数量也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。（优惠券库存变为负数，订单表条目超过库存数量），超卖问题是典型的多线程安全问题</p>\r\n<p><strong>解决方案就是加锁：</strong></p>\r\n<ul>\r\n<li><p><strong>悲观锁：</strong>认为线程安全很重要，操作数据前必须先获得锁，确保数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p></li>\r\n<li><p><strong>乐观锁：</strong>认为线程安全问题不一定会发生，因此不直接加锁。会有一个版本号version，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1\r\n，如果大1\r\n，则进行操作成功（如果大了其他，或version不对应了，证明数据被修改过）。乐观锁还有一些变种的处理方式比如cas</p></li>\r\n</ul>\r\n<p>自旋操作（spin\r\nlock）：如果一个线程正在尝试获取某个资源，但该资源当前被其他线程占用，它就会不断重复检查该资源的状态，直到资源可用</p>\r\n<p>CAS（Compare-and-Swap）操作：一种常用的原子操作，主要用于解决多线程中的竞争条件，原子性保证了在多线程环境下的操作是线程安全</p>\r\n<h4 id=\"乐观锁解决超卖问题\">乐观锁解决超卖问题</h4>\r\n<p>实现时，是由seckillVouncher方法的最后，若库存充足则扣减库存，调用createVoucherOrder方法</p>\r\n<p>VoucherOrderServiceImpl\r\n在扣减库存时，createVoucherOrder函数中扣减部分改为：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> seckillVoucherService.update()</span><br><span class=\"line\">            .setSql(<span class=\"string\">&quot;stock= stock -1&quot;</span>) <span class=\"comment\">//set stock = stock -1</span></span><br><span class=\"line\">            .eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).eq(<span class=\"string\">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class=\"comment\">// where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>\r\n<p>以上逻辑的核心含义是：只要扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存;</p>\r\n<p>但是以上这种方式通过测试发现会有很多失败的情况，原因：使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中<strong>只有1个人能扣减成功</strong>，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败，导致商品虽然不会超卖，但也很多没卖出去，操作失败率高。</p>\r\n<p><strong>改成stock大于0 </strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> seckillVoucherService.update()</span><br><span class=\"line\">            .setSql(<span class=\"string\">&quot;stock= stock -1&quot;</span>)</span><br><span class=\"line\">            .eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class=\"string\">&quot;stock&quot;</span>,<span class=\"number\">0</span>); <span class=\"comment\">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"优惠券秒杀一人一单问题逐步加锁\">3.3\r\n优惠券秒杀——一人一单问题——逐步加锁</h3>\r\n<p>现在的情况是一个人可以无限制的抢这个优惠卷（黄牛），要求同一个优惠券，一个用户只能下一单</p>\r\n<p>实现思路：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653371854389-1734362376722.png\"\r\nalt=\"1653371854389\" />\r\n<figcaption aria-hidden=\"true\">1653371854389</figcaption>\r\n</figure>\r\n<p>在优惠券订单实现类的createVoucherOrder方法中，增加一人一单逻辑：函数上需要增加@Transactional事务注解（查询订单、扣减库存和创建订单一致性）</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 5.一人一单逻辑</span></span><br><span class=\"line\">   <span class=\"comment\">// 5.1.用户id</span></span><br><span class=\"line\">   <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> query().eq(<span class=\"string\">&quot;user_id&quot;</span>, userId).eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class=\"line\">   <span class=\"comment\">// 5.2.判断是否存在</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 用户已经购买过了</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 订单表中不存在的用户可以购买</span></span><br><span class=\"line\">   <span class=\"comment\">//6.扣减库存</span></span><br><span class=\"line\">   <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> seckillVoucherService.update()</span><br><span class=\"line\">           .setSql(<span class=\"string\">&quot;stock= stock -1&quot;</span>)</span><br><span class=\"line\">           .eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//扣减库存</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;库存不足！&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//7.创建订单</span></span><br><span class=\"line\">   <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrder</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 7.1.订单id</span></span><br><span class=\"line\">   <span class=\"type\">long</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> redisIdWorker.nextId(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">   voucherOrder.setId(orderId);</span><br><span class=\"line\"></span><br><span class=\"line\">   voucherOrder.setUserId(userId);</span><br><span class=\"line\">   <span class=\"comment\">// 7.3.代金券id</span></span><br><span class=\"line\">   voucherOrder.setVoucherId(voucherId);</span><br><span class=\"line\">   save(voucherOrder);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> Result.ok(orderId);</span><br></pre></td></tr></table></figure>\r\n<p><strong>存在问题：</strong>同一个用户id的多个线程并发过来，第一次购买，查询数据库，都不存在订单，都可以走到第六步购买；</p>\r\n<p>针对这个问题，我们还是需要加锁，但是乐观锁比较适合更新数据(不同线程带来不同版本，解决超卖)，而现在是插入数据(不同线程同时插入)，所以我们需要使用悲观锁操作</p>\r\n<ol type=\"1\">\r\n<li><p>封装了一个<code>createVoucherOrder</code>方法，在方法上增加<code>synchronized</code>锁，当前锁是this，当前对象，此方法实现查询订单，扣减库存，创建订单，返回结果</p>\r\n<ol type=\"1\">\r\n<li>问题：锁的范围过大，任何用户来了都得等锁，而非是同一用户，粒度太粗了</li>\r\n<li>在使用锁过程中，控制<strong>锁粒度</strong>\r\n是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住</li>\r\n</ol></li>\r\n<li><p>加锁的时候按照用户ID来加，同一用户加一把锁，不同用户不同锁，获取到代码，然后<code>synchronized(userId.toString().intern())&#123;剩下代码&#125;</code>，toString每次都是一个全新字符串，返回字符串的规范表示：从常量池中拿到数据，只按值判断；此时在方法内部加锁</p>\r\n<ol type=\"1\">\r\n<li>问题：在方法内部加锁，在执行完逻辑代码，理论上锁已经释放了，其他线程可以进来，但是又有@transactional事务逻辑，若未提交事务时，其他线程面对的数据库还是之前的，仍然可以进来，产生订单安全问题</li>\r\n<li>事务没提交而锁已经释放</li>\r\n</ol></li>\r\n<li><p>故应该加在整个函数的外面，锁住整个函数：在<code>seckillVoucher</code>方法中，添加以下逻辑，先获取ID，然后锁住要返回的函数（创建订单），函数执行完，事务一定已经提交，数据库已经更新，释放的锁才能被其他进程正确使用。保证事务特效同时也控制了锁的粒度；</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373434815-1734362376722.png\"\r\nalt=\"1653373434815\" />\r\n<figcaption aria-hidden=\"true\">1653373434815</figcaption>\r\n</figure>\r\n<p>问题：调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效</p></li>\r\n<li><p>Spring事务失效：事务是创建一个代理对象，对代理对象事务一致性操作；但是this.的方式调用的是非代理对象，目标对象；</p>\r\n<ol type=\"1\">\r\n<li><p>需要拿到代理对象：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653383810643-1734362376722.png\"\r\nalt=\"1653383810643\" />\r\n<figcaption aria-hidden=\"true\">1653383810643</figcaption>\r\n</figure></li>\r\n</ol></li>\r\n<li><p>需要引入asproxy依赖，加@Enable...注解设置为true才能生效</p>\r\n<p>​ <strong>还需要去掉sekillVouncher方法上面的注解</strong></p></li>\r\n</ol>\r\n<h3 id=\"分布式集群环境的并发问题\">3.4 分布式集群环境的并发问题</h3>\r\n<p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>\r\n<p>1、我们将服务启动两份，端口分别为8081和8082：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373887844-1734362376722.png\"\r\nalt=\"1653373887844\" />\r\n<figcaption aria-hidden=\"true\">1653373887844</figcaption>\r\n</figure>\r\n<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373908620-1734362376722.png\"\r\nalt=\"1653373908620\" />\r\n<figcaption aria-hidden=\"true\">1653373908620</figcaption>\r\n</figure>\r\n<p><strong>有关锁失效原因分析</strong></p>\r\n<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，同一JVM内部锁维护锁监视器对象(user_id)，利用同一常量池的id是可以实现互斥，但此时服务器JVM不一样时，又有两个线程但是却不是同一个锁监视器，故线程1和线程3就可以是同一个用户</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653374044740-1734362376722.png\"\r\nalt=\"1653374044740\" />\r\n<figcaption aria-hidden=\"true\">1653374044740</figcaption>\r\n</figure>\r\n<p>故要使用跨集群的锁——<strong>分布式锁</strong></p>\r\n<h3 id=\"分布式锁simplelock自己实现\">3.5\r\n分布式锁——simpleLock(自己实现)</h3>\r\n<p>分布式锁需要满足：<strong>多进程可见、互斥</strong>、高可用、高并发（高性能）、安全性</p>\r\n<p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且互斥的锁，原本一个JVM一个锁监视器，现在统一用一个锁监视器了</p>\r\n<p><strong>常见分布式锁：</strong></p>\r\n<p>Mysql：本身互斥锁机制，性能一般；Redis：常见方式，<strong>setnx</strong>方法，插入Key成功则成功获得锁，后续的人无法成功插入这个数据；Zookeeper：利用节点有序性和唯一性实现互斥</p>\r\n<p><strong>Redis实现：</strong></p>\r\n<p>获取锁：互斥（一次只能一个获取）、非阻塞（尝试一次、成功true，失败false，无法再重试）</p>\r\n<p>释放锁：手动释放、超时释放（超时时间）</p>\r\n<h4 id=\"核心思路与基本实现\">3.5.1 核心思路与基本实现</h4>\r\n<p><strong>setNx\r\n方法：</strong>有多个线程进入时，第一个线程进入时，setnx key\r\nvalue，其中key是携带用户id信息的，可以创建成功，即获取了锁，返回1，去执行业务，后删除锁delete\r\nkey实现退出锁逻辑；其他线程无法再设置这个key，执行返回0，需要等待一定时间后重试setnx。</p>\r\n<ul>\r\n<li><strong>加锁逻辑</strong></li>\r\n</ul>\r\n<p>utils下增加：<strong>接口：ILock</strong></p>\r\n<p>实现两个方法<code>boolean tryLock(传入锁持有时间，过期自动释放)</code>和<code>void unlock()</code></p>\r\n<p>utils下增加：<strong>SimpleRedisLock实现ILock</strong></p>\r\n<p>有参构造，传入name和redistemplate实例化对象，</p>\r\n<p>tryLock：获取线程标识，利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性（setnx\r\nexpire 一起执行）</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY_PREFIX=<span class=\"string\">&quot;lock:&quot;</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> timeoutSec)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程标示</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId()</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">    <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue()</span><br><span class=\"line\">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class=\"string\">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Boolean.TRUE.equals(success);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><strong>释放锁逻辑：</strong></li>\r\n</ul>\r\n<p>直接删除<code>stringRedisTemplate.delete(KEY_PREFIX + name);</code></p>\r\n<ul>\r\n<li>设计完工具方法后，修改vouncherOrderService实现类的<strong>seckillVoncher</strong>方法：</li>\r\n</ul>\r\n<p>在发现库存充足后，此时不需要在<code>proxy.createVoucherOrder</code>外部利用synchronized上锁了（用分布式锁了，更高级，不需要刚才实现的防止一人一单的方法了）<strong>但是：</strong>分布式锁确保了同一时间只有一个用户能执行\r\n<code>createVoucherOrder</code>\r\n方法，而事务管理确保了方法执行过程中的一致性和原子性，所以此时仍需要代理对象</p>\r\n<p>在判断库存后面上锁：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4.判断库存是否充足</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (voucher.getStock() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 库存不足</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;库存不足！&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\">      <span class=\"comment\">// 创建锁对象(新增代码)</span></span><br><span class=\"line\">      <span class=\"type\">SimpleRedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleRedisLock</span>(<span class=\"string\">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class=\"line\">      <span class=\"comment\">// 获取锁对象，加锁1200秒</span></span><br><span class=\"line\">      <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> lock.tryLock(<span class=\"number\">1200</span>);</span><br><span class=\"line\"><span class=\"comment\">// 加锁失败：证明同一用户正在下单了</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;不允许重复下单&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//获取代理对象(事务)：执行查询订单、扣减库存、创建订单</span></span><br><span class=\"line\">          <span class=\"type\">IVoucherOrderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class=\"line\">          <span class=\"keyword\">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">          lock.unlock();</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"误删问题\">3.5.2 误删问题</h4>\r\n<p><strong>问题</strong>：我们设置了锁的自动过期时间，若持有锁的线程1在锁的内部出现了阻塞，导致他的锁自动释放，被其他线程获取；但线程1本身并不知晓，阻塞结束后继续执行本身逻辑，完成逻辑后删除锁（释放锁），此时删除的是属于线程2刚才获取的锁，这就是误删别人锁的情况；</p>\r\n<p><strong>解决方案：</strong>每个线程释放锁的时候，去判断一下当前这把锁<strong>是否属于自己</strong>，属于自己则可以释放，是属于自己，证明已经被释放了，此时不删除锁。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653385920025-1734362376722.png\"\r\nalt=\"1653385920025\" />\r\n<figcaption aria-hidden=\"true\">1653385920025</figcaption>\r\n</figure>\r\n<p><strong>实现方案：</strong>集群的模式下，直接利用threadID，不同JVM可能相同，因此在获取锁时存入线程标示（可以用该线程UUID\r\n+ 线程ID），此时再拼接同一JVM的不同线程ID</p>\r\n<p>UUID：全局唯一的标识符，区分不同的 JVM 实例</p>\r\n<p>修改tryLock和unLock代码</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前JVM的唯一标识</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ID_PREFIX</span> <span class=\"operator\">=</span> UUID.randomUUID().toString(<span class=\"literal\">true</span>) + <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> timeoutSec)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 获取线程标示</span></span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class=\"line\">   <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">   <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue()</span><br><span class=\"line\">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> Boolean.TRUE.equals(success);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程标示</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁中的标示</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class=\"line\">    <span class=\"comment\">// 判断标示是否一致</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(threadId.equals(id)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"原子性问题lua脚本\">3.5.3 原子性问题——Lua脚本</h4>\r\n<p><strong>误删问题2：</strong>阻塞发生在线程判断标识一致和释放锁之间：线程1持有锁后执行业务逻辑，结束后他准备删除锁，此时发生阻塞，线程1锁在阻塞过程中到期已经自动释放。此时线程2进来，线程1阻塞完后会删除当前线程2获取的锁（因为他刚刚判断了锁是自己的，但是没来得及删），这就是删锁时的原子性问题。</p>\r\n<p><strong>本质</strong>：线程1的拿锁，比锁，删锁，并不是原子性</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653387764938-1734362376722.png\"\r\nalt=\"1653387764938\" />\r\n<figcaption aria-hidden=\"true\">1653387764938</figcaption>\r\n</figure>\r\n<p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的<strong>原子性</strong>。</p>\r\n<p>重点介绍Lua脚本中Redis提供的调用函数，语法如下：</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis.call(<span class=\"string\">&#x27;命令名称&#x27;</span>, <span class=\"string\">&#x27;key&#x27;</span>, <span class=\"string\">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>\r\n<p>例如，我们要执行set name jack，则脚本是这样：</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 执行 set name jack</span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;set&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 先执行 set name jack</span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;set&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;Rose&#x27;</span>)</span><br><span class=\"line\"># 再执行 get name</span><br><span class=\"line\"><span class=\"keyword\">local</span> name = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\"># 返回</span><br><span class=\"line\"><span class=\"keyword\">return</span> name</span><br></pre></td></tr></table></figure>\r\n<p>写好脚本以后，需要用Redis命令来调用脚本</p>\r\n<p>脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653392438917-1734362376722.png\"\r\nalt=\"1653392438917\" />\r\n<figcaption aria-hidden=\"true\">1653392438917</figcaption>\r\n</figure>\r\n<p>之前释放锁的业务流程是这样的：</p>\r\n<p>1.获取锁的唯一线程标识</p>\r\n<p>2.比较是否和当前线程标识一致</p>\r\n<p>3.一致则删除；不一致则直接over</p>\r\n<p><strong>Lua脚本实现：</strong></p>\r\n<p>线程标识是key-value中的value即UUID+线程标识，key是userID</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class=\"line\"><span class=\"comment\">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class=\"line\"><span class=\"comment\">-- 利用redis.call(&#x27;GET&#x27;, KEYS[1])先取Key（拼接lock:(order:userId传入)）对应的value（锁的线程标识），与当前线程标识比较</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;GET&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == ARGV[<span class=\"number\">1</span>]) <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"comment\">-- 一致，则删除锁</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> redis.call(<span class=\"string\">&#x27;DEL&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 不一致，则直接返回</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>在Java代码中调用Lua脚本</strong>：</p>\r\n<p>RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653393304844-1734362376722.png\"\r\nalt=\"1653393304844\" />\r\n<figcaption aria-hidden=\"true\">1653393304844</figcaption>\r\n</figure>\r\n<p><strong>Java代码</strong></p>\r\n<p><code>static</code> 的作用是确保指示 Lua 脚本\r\n的变量<code>UNLOCK_SCRIPT</code> 只被加载和初始化一次</p>\r\n<p><strong>静态代码块</strong>，它会在\r\n<strong>类加载时自动执行</strong>，且只执行一次。它用于初始化静态变量\r\n<code>UNLOCK_SCRIPT</code>，在静态代码块中被初始化为一个新的\r\n<code>DefaultRedisScript</code> 对象，并且设置了 Lua\r\n脚本的路径（<code>unlock.lua</code>）以及脚本的执行结果类型（<code>Long.class</code>）</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UNLOCK_SCRIPT是一个静态变量，它被声明为 static，它属于类本身，而不是类的实例，无论你创建多少个该类的实例，UNLOCK_SCRIPT 始终只有一个实例，UNLOCK_SCRIPT 只在类加载时初始化一次，且所有实例共享同一个对象，避免了重复的初始化操作（节省资源）</span></span><br><span class=\"line\"><span class=\"comment\">// final 关键字保证了 UNLOCK_SCRIPT 一旦被赋值就无法再改变它指向的对象。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        UNLOCK_SCRIPT = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;();</span><br><span class=\"line\">        UNLOCK_SCRIPT.setLocation(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;unlock.lua&quot;</span>));</span><br><span class=\"line\">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放锁的时候判断和删除一起做</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用lua脚本</span></span><br><span class=\"line\">    stringRedisTemplate.execute(</span><br><span class=\"line\">            UNLOCK_SCRIPT,</span><br><span class=\"line\">            Collections.singletonList(KEY_PREFIX + name), <span class=\"comment\">//（脚本中的参数KEYS[1]）</span></span><br><span class=\"line\">            ID_PREFIX + Thread.currentThread().getId()); <span class=\"comment\">// （脚本中的参数ARGV[1]）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>小结</strong>：添加过期时间，防止死锁问题的发生，但可能出现到期以后误删别人锁的问题，开始是利用删之前对比锁标识和自己标识，但可能出现原子性问题也会误删，通过lua表达式来解决这个问题。</p>\r\n<p><strong>基于setnx分布式锁实现存在问题：</strong></p>\r\n<p><strong>重入问题</strong>：获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，如A方法获得锁，调用B方法，而B方法也需要锁，则B在等待A释放，A调用的B未执行A没法释放，此时发生死锁；synchronized和Lock锁都是可重入的。</p>\r\n<p><strong>不可重试</strong>：目前的分布式中只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>\r\n<p><strong>超时释放：</strong>加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，自己锁已经释放，存在安全问题；利用redission也可以实现到期续约，不会误删别人的锁；</p>\r\n<p><strong>主从一致性：</strong>\r\n如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653546070602.png\" alt=\"1653546070602\" style=\"zoom: 38%;\" /></p>\r\n<h3 id=\"分布式锁redisson\">3.6 分布式锁——redisson</h3>\r\n<h4 id=\"redisson介绍与应用\">3.6.1 Redisson介绍与应用</h4>\r\n<p>Redisson在Redis的基础上实现的Java驻内存数据网格（In-Memory Data\r\nGrid），是一个 <strong>Java Redis 客户端</strong>，它封装了 Redis\r\n的基本操作，并且提供了许多高层次的抽象。Redisson 的目标是简化与 Redis\r\n的交互，同时提供一些高级功能，如分布式锁、分布式集合、分布式缓存。简言之：Redis的儿子（增强版），更高级，交互更方便</p>\r\n<p>引入依赖，注册配置客户端</p>\r\n<p><strong>使用案例：</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource</span> <span class=\"comment\">// 引入Redisson客户端实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissionClient redissonClient;</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testRedisson</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取锁(可重入)，指定锁的名称</span></span><br><span class=\"line\">    <span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;anyLock&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> lock.tryLock(<span class=\"number\">1</span>,<span class=\"number\">10</span>,TimeUnit.SECONDS);</span><br><span class=\"line\">    <span class=\"comment\">//判断获取锁成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isLock)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;执行业务&quot;</span>);          </span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在 VoucherOrderServiceImpl注入RedissonClient</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"><span class=\"comment\">// 在seckillVoucher函数块中部分核心代码：</span></span><br><span class=\"line\"> <span class=\"comment\">// 4.判断库存是否充足</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (voucher.getStock() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 库存不足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;库存不足！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\">        <span class=\"comment\">// 创建锁对象 下面代码不用了，因为我们现在要使用Redisson提供的锁，不用自己创建的simple锁了</span></span><br><span class=\"line\">        <span class=\"comment\">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;lock:order:&quot;</span> + userId); <span class=\"comment\">// 锁的名称即key</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取锁对象</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> lock.tryLock();</span><br><span class=\"line\">       </span><br><span class=\"line\">\t\t<span class=\"comment\">//加锁失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;不允许重复下单&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取代理对象(事务)</span></span><br><span class=\"line\">            <span class=\"type\">IVoucherOrderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\r\n<p>利用以上RedissonClient提供的锁我们即可实现Reddision锁，解决上述的四个问题，下面我们剖析一下Reddisson实现这些功能的原理</p>\r\n<h4 id=\"reddisson可重入可重试超时释放原理\">3.6.2\r\nReddisson可重入、可重试、超时释放原理</h4>\r\n<p>** 可重入**</p>\r\n<p>Lock锁中，借助于底层的一个voaltile（关键字，修饰变量确保该变量的值对所有线程可见的）的一个state变量来记录重入的状态的，无人拥有此锁state\r\n= 0，每有一个人拥有state +\r\n1；对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，直到减少成0\r\n时，表示当前这把锁没有被人持有；</p>\r\n<p>在redission中，支持可重入锁：采用hash结构用来存储锁，其中key表示这把锁是否存在，field表示当前这把锁被哪个线程持有（线程标识）,value代表重入次数。分析源码：trylock调用tryLockAsync，返回\r\ntryAcquireOnceAsync，函数中调用tryLockInnerAsync，其中存在lua表达式：</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;return nil; &quot;</span> +</span><br><span class=\"line\"> <span class=\"string\">&quot;end; &quot;</span> +</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;return nil; &quot;</span> +</span><br><span class=\"line\"><span class=\"string\">&quot;end; &quot;</span> +</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<p><strong>KEYS[1] ： 锁名称</strong></p>\r\n<p><strong>ARGV[1]： 锁失效时间</strong></p>\r\n<p><strong>ARGV[2]： id + \":\" + threadId;\r\n锁的小key，标识当前锁的被哪个线程持有</strong></p>\r\n<ul>\r\n<li><p>首先进行判断：exists 判断Redis数据库中是否存在\r\nname：如果==0，就表示当前这把锁不存在，可以获取锁：</p>\r\n<p><code>redis.call('hset', KEYS[1], ARGV[2], 1)</code>;此时他就开始往redis里边去写数据\r\n，hash结构，锁名称通常是用户ID(KEYS[1])-线程标识符或\r\nUUID（ARGV[2]），数字1代表当前线程已经获得锁；<code>pexpire</code>\r\n命令为锁设置一个过期时间，单位是毫秒最后返回nil；</p></li>\r\n<li><p>如果这把锁已经存在，<code>hexists</code>\r\n命令检查这把锁是否是属于自己，即对比当前线程标识符ID和锁的标识符（key对应的value），如果是自己的，<code>hincrby</code>将当前这个锁的value进行+1\r\n，然后再对其设置过期时间<code>redis.call('pexpire', KEYS[1], ARGV[1])</code>;返回nil</p></li>\r\n<li><p>如果以上两个条件都不满足，即当前锁已被其他线程或进程占用且无法重入，脚本返回当前锁的剩余有效时间（<code>pttl</code>\r\n命令返回的是锁的过期时间，单位毫秒；</p></li>\r\n</ul>\r\n<p>整体：<strong>加锁（无人获取）</strong>、<strong>重入锁（同一线程已经获取了锁，可以就行获取，重入增加次数，延长过期时间）</strong>、<strong>锁的过期（持锁线程在过期时间内没有释放锁，其他线程可以重新获取该锁。）</strong></p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653548087334-1734362376722.png\"\r\nalt=\"1653548087334\" />\r\n<figcaption aria-hidden=\"true\">1653548087334</figcaption>\r\n</figure>\r\n<p>** 可重试**</p>\r\n<p>** 实现思路：**</p>\r\n<ul>\r\n<li><strong>获取锁：</strong></li>\r\n</ul>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241210123703596-1734362376722.png\"\r\nalt=\"image-20241210123703596\" />\r\n<figcaption aria-hidden=\"true\">image-20241210123703596</figcaption>\r\n</figure>\r\n<p>ttl表示获取已有锁的过期时间，null表示当前没有已存在的锁，即可以成功获取锁；否则判断剩余等待时间，如果等待时间小于0了，则证明已经不需要等了，直接返回；如果大于0（证明还需要接着等），此时利用Lock的Pubsub订阅锁并等待释放，定期判断等待时间若超时则取消订阅并返回false，否则尝试获取；</p>\r\n<p>leaseTime是释放时间（有效期），如果过了有效期，则可以重新获取锁，返回true；</p>\r\n<p>如果在有效期内，则开启看门狗机制，watchDog不停更新锁的有效期</p>\r\n<ul>\r\n<li><strong>释放锁</strong>：</li>\r\n</ul>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241210123803989-1734362376723.png\"\r\nalt=\"image-20241210123803989\" />\r\n<figcaption aria-hidden=\"true\">image-20241210123803989</figcaption>\r\n</figure>\r\n<p>unlock相对简单很多，执行释放脚本，释放成功发送释放消息publish，取消watchDog任务</p>\r\n<p>** 超时释放**</p>\r\n<p>renewExpiration此逻辑就是续约逻辑</p>\r\n<p>分析lock()方法的源码解析</p>\r\n<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>\r\n<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>\r\n<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>\r\n<p>3、锁存在且不是这个线程，开始抢锁（尝试获取锁），即上面的执行流程图；</p>\r\n<p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕；但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，此时有个while(\r\ntrue) 再次进行tryAcquire进行抢锁</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId();</span><br><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">ttl</span> <span class=\"operator\">=</span> tryAcquire(-<span class=\"number\">1</span>, leaseTime, unit, threadId);</span><br><span class=\"line\"><span class=\"comment\">// lock acquired</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ttl == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数则leaseTime是他本身，一个是不带参数默认传入leaseTime\r\n= -1；leaseTime时间内都会去抢锁，抢锁过程的逻辑与之前相同。</p>\r\n<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间\r\ncommandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>\r\n<p><strong>ttlRemainingFuture.onComplete((ttlRemaining, e)</strong>\r\n这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程，续约逻辑代码：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class=\"line\">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class=\"line\">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class=\"line\">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lock acquired</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ttlRemaining == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        scheduleExpirationRenewal(threadId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>\r\n<p>commandExecutor.getConnectionManager().newTimeout（）方法：Method(\r\n<strong>new</strong> TimerTask() {},参数2 ，参数3 )</p>\r\n<p>通过参数2，参数3\r\n去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>\r\n<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask\r\n就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">renewExpiration</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ExpirationEntry</span> <span class=\"variable\">ee</span> <span class=\"operator\">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ee == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Timeout</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> commandExecutor.getConnectionManager().newTimeout(<span class=\"keyword\">new</span> <span class=\"title class_\">TimerTask</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(Timeout timeout)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"type\">ExpirationEntry</span> <span class=\"variable\">ent</span> <span class=\"operator\">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ent == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> ent.getFirstThreadId();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (threadId == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class=\"line\">            future.onComplete((res, e) -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class=\"string\">&quot; expiration&quot;</span>, e);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// reschedule itself</span></span><br><span class=\"line\">                    renewExpiration();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, internalLockLeaseTime / <span class=\"number\">3</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ee.setTimeout(task);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"mutilock应用\">3.6.3 MutiLock应用</h4>\r\n<p>利用redission锁可以实现上述的功能，但无法实现<strong>主从一致性</strong></p>\r\n<p>Redis集群中，主节点：存数据；从节点：读数据。主从同步时，数据会有一定延时，如主节点获取锁，写在主节点的数据还没来得及写从节点上，此时主机宕机，哨兵发现，选举一个slave变成<strong>新的master</strong>，而此时新的master中实际上<strong>并没有锁信息</strong>，此时锁信息就已经丢掉了，其他线程可以获得锁了。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553998403.png\" alt=\"1653553998403\" style=\"zoom:50%;\" /></p>\r\n<p><strong>解决方案：</strong>redission提出来了MutiLock锁，使用这把锁每个节点地位一致，<strong>加锁的逻辑需要写入到每一个主丛节点上</strong>，只有所有的服务器都写入成功，此时才是加锁成功；若一个节点挂了，其他乘虚而入的进程获得锁的时候，只要有一个节点的拿不到，就不算加锁成功。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653554055048-1734362376723.png\"\r\nalt=\"1653554055048\" />\r\n<figcaption aria-hidden=\"true\">1653554055048</figcaption>\r\n</figure>\r\n<p><strong>MultiLock加锁原理：</strong></p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553093967-1734362376723.png\"\r\nalt=\"1653553093967\" />\r\n<figcaption aria-hidden=\"true\">1653553093967</figcaption>\r\n</figure>\r\n<p>设置多个锁的时候，redisson将多个锁加入一个集合中，（在总的加锁时间内，这个时间是用需要加锁的个数\r\n* 1500ms）并且while循环不断尝试拿锁，假设这时间内，所有的锁都加锁成功，\r\n那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试。</p>\r\n<p><strong>测试：</strong>test类中配置RedisClient中若干个主从节点redisClient1/2/3，给他们获取对应的lock1/2/3，创建multiLock，<code>lock  = redissonClient1/2/3.getMultiLock(lock1,lock2,lock3)</code></p>\r\n<h4 id=\"小结redis解决四个问题\">小结：Redis解决四个问题</h4>\r\n<ol type=\"1\">\r\n<li><strong>可重入问题：</strong>同一线程(不同函数)可以调用自己的锁，获取锁：利用hash结构记录线程标识和重入次数；释放：每释放一次，重入-1，减为0，真正释放锁</li>\r\n<li><strong>锁失败重试问题</strong>：失败后可以重试获取，而不是直接false，利用信号量和pubsub订阅（发布-订阅模式）功能实现等待、唤醒、获取锁失败的重试机制，也非无限制重试，有等待时间；</li>\r\n<li><strong>锁超时释放（续约）问题：</strong>利用watchDog，开启定时任务，每隔一段时间重新配置expire，重置超时时间</li>\r\n<li><strong>主从一致性问题：</strong>利用multipleLock，分布式锁实现</li>\r\n</ol>\r\n<p>此时我们便利用Redis解决四个问题<strong>：可重入问题、可重试、超时释放、主从一致性</strong>；至此，项目秒杀优惠券业务完成一人一单的优化，但是性能还可以做一定的优化</p>\r\n<h2 id=\"iv-秒杀优化\">IV 秒杀优化</h2>\r\n<p>回顾一下购买优惠券下单流程：</p>\r\n<p>用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：</p>\r\n<p>1、查询优惠卷</p>\r\n<p>2、判断秒杀<strong>库存是否足够</strong></p>\r\n<p>3、查询订单</p>\r\n<p>4、校验是否是<strong>一人一单</strong></p>\r\n<p>5、扣减库存</p>\r\n<p>6、创建订单</p>\r\n<p>其中，查询优惠券、查询订单、扣减库存和创建订单都是对数据库的直接操作，且在一个线程内串行执行，效率较低；需要异步执行加速</p>\r\n<h3 id=\"异步秒杀\">4.1 异步秒杀</h3>\r\n<h4 id=\"思路\">4.1.1 思路</h4>\r\n<ol type=\"1\">\r\n<li>将耗时比较短的逻辑判断放入到redis中，判断是否库存足够及一人一单，快速的逻辑判断后，将下单信息存入消息队列，然后直接给用户返回成功；</li>\r\n<li>再在后台开一个线程，后台线程从队列取出下单信息，去执行和数据库相关逻辑；</li>\r\n</ol>\r\n<p><strong>两大问题：</strong></p>\r\n<ul>\r\n<li>redis中去快速库存判断和校验一人一单</li>\r\n<li>由于校验和tomct下单是两个线程，如何知道到底是哪个单，以及最后是否成功</li>\r\n</ul>\r\n<p><strong>解决方案</strong>：库存判断利用key-value中的value，一人一单通过set集合区分该用户是否下过单；在redis操作完之后，我们会将一些信息（订单id）返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653561657295-1734362376723.png\"\r\nalt=\"1653561657295\" />\r\n<figcaption aria-hidden=\"true\">1653561657295</figcaption>\r\n</figure>\r\n<p><strong>整体：</strong>用户下单-&gt;判断库存充足（不足结束）-&gt;\r\n校验一人一单（不是结束）-&gt;\r\n完成下单，扣除Redis库存，此后将用户id和优惠卷信息存入到redis（Lua\r\n脚本实现原子性库存充足和校验需要原子性操作，否则超卖和重复下单）-&gt;\r\n对Redis操作完毕返回值（0代表成功，1代表超卖，-1代表重复下单）-&gt;\r\n成功即将刚才存入的信息放入queue，利用新线程异步下单</p>\r\n<p>前端可以通过返回的订单id来判断是否下单成功，整体流程类似于饭店接单，服务员先接单给个小票（告诉顾客已经完成），同时告诉厨师可以炒了，厨师异步操作</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653562234886-1734362376723.png\"\r\nalt=\"1653562234886\" />\r\n<figcaption aria-hidden=\"true\">1653562234886</figcaption>\r\n</figure>\r\n<h4 id=\"redis实现资格判断\">4.1.2 Redis实现资格判断</h4>\r\n<p>实现资格判断时，核心在于：管理端保存优惠券到Redis，用户端下单的时候基于Lua脚本判断库存容量和一人一单、成功下单后将优惠券id和用户id封装后存入阻塞队列、开启线程任务不断从阻塞队列中获取信息实现异步下单，共四步任务，<strong>实现代码</strong>如下：</p>\r\n<p>用户购买进入Vounchercontroller：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;seckill&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Result <span class=\"title function_\">addSeckillVoucher</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class=\"line\">    voucherService.addSeckillVoucher(voucher);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Result.ok(voucher.getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>管理端增加优惠卷的时候，调用VoucherService接口，实现类VoucherServiceImpl中，<strong>实现保存优惠券到Redis</strong>：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addSeckillVoucher</span><span class=\"params\">(Voucher voucher)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存优惠券</span></span><br><span class=\"line\">    save(voucher);</span><br><span class=\"line\">    <span class=\"comment\">// 保存秒杀信息</span></span><br><span class=\"line\">    <span class=\"type\">SeckillVoucher</span> <span class=\"variable\">seckillVoucher</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillVoucher</span>();</span><br><span class=\"line\">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class=\"line\">    seckillVoucher.setStock(voucher.getStock());</span><br><span class=\"line\">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class=\"line\">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class=\"line\">    seckillVoucherService.save(seckillVoucher);</span><br><span class=\"line\">    <span class=\"comment\">// 保存秒杀库存到Redis中</span></span><br><span class=\"line\">    <span class=\"comment\">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class=\"line\">    <span class=\"comment\">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class=\"line\">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>用户端下单购买优惠券的时候，会进入VouncherOrdercontroller：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Result <span class=\"title function_\">seckillVoucher</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> voucherOrderService.seckillVoucher(voucherId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>传入优惠券ID，在VoucherOrderServiceImpl中，我们实现第二步：<strong>基于Lua脚本判断库存容量和一人一单</strong></p>\r\n<p>再次修改seckillVouncher代码：此时创建订单和判断是否下单成功是异步操作，Redis\r\n操作和库存更新、订单创建是分离的，<code>createVoucherOrder</code>\r\n方法已经独立，不依赖代理对象的事务支持或锁逻辑；故</p>\r\n<ol type=\"1\">\r\n<li><code>createVouncher</code>方法不需要再通过代理对象调用，去掉proxy</li>\r\n<li>此外，现在去掉了@Transactional，将分布式锁直接加在了<code>createVouncher</code>上，通过\r\nRedis 校验和分布式锁减少了对事务的依赖</li>\r\n</ol>\r\n<p>其实在Redis中我们已经判断一人一单和超卖问题了，因而无需在此时加锁再次判断，但为了以防万一，代码健壮性~，再次加锁再次判断一遍超卖和；</p>\r\n<p>修改代码后，seckillVouncher仅用来对接用户：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建1024*1024的阻塞队列，ArrayBlockingQueue 是 Java 中的一个阻塞队列实现，基于 数组 实现</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class=\"keyword\">new</span>  <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Result <span class=\"title function_\">seckillVoucher</span><span class=\"params\">(Long voucherId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取用户</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> redisIdWorker.nextId(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 1.执行lua脚本</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> stringRedisTemplate.execute(</span><br><span class=\"line\">            SECKILL_SCRIPT,</span><br><span class=\"line\">            Collections.emptyList(),</span><br><span class=\"line\">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> result.intValue();</span><br><span class=\"line\">    <span class=\"comment\">// 2.判断结果是否为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.fail(r == <span class=\"number\">1</span> ? <span class=\"string\">&quot;库存不足&quot;</span> : <span class=\"string\">&quot;不能重复下单&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.2.为0 ，有购买资格，把下单信息保存到阻塞队列</span></span><br><span class=\"line\">        <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrder</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 2.3.订单id</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> redisIdWorker.nextId(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">        voucherOrder.setId(orderId);</span><br><span class=\"line\">        <span class=\"comment\">// 2.4.用户id</span></span><br><span class=\"line\">        voucherOrder.setUserId(userId);</span><br><span class=\"line\">        <span class=\"comment\">// 2.5.代金券id</span></span><br><span class=\"line\">        voucherOrder.setVoucherId(voucherId);</span><br><span class=\"line\">        <span class=\"comment\">// 2.6.放入阻塞队列</span></span><br><span class=\"line\">        orderTasks.add(voucherOrder);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3.返回订单id</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Result.ok(orderId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>执行的Lua脚本实现判断库存容量和一人一单：</p>\r\n<p>完整lua表达式</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 1.参数列表</span></span><br><span class=\"line\"><span class=\"comment\">-- 1.1.优惠券id</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> voucherId = ARGV[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\">-- 1.2.用户id</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> userId = ARGV[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\">-- 1.3.订单id</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> orderId = ARGV[<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2.数据key</span></span><br><span class=\"line\"><span class=\"comment\">-- 2.1.库存key</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stockKey = <span class=\"string\">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class=\"line\"><span class=\"comment\">-- 2.2.订单key</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> orderKey = <span class=\"string\">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 3.脚本业务</span></span><br><span class=\"line\"><span class=\"comment\">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"comment\">-- 3.2.库存不足，返回1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(redis.call(<span class=\"string\">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"comment\">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;incrby&#x27;</span>, stockKey, <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class=\"line\"><span class=\"comment\">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;xadd&#x27;</span>, <span class=\"string\">&#x27;stream.orders&#x27;</span>, <span class=\"string\">&#x27;*&#x27;</span>, <span class=\"string\">&#x27;userId&#x27;</span>, userId, <span class=\"string\">&#x27;voucherId&#x27;</span>, voucherId, <span class=\"string\">&#x27;id&#x27;</span>, orderId)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\r\n<p>seckill执行完以后，若可以创建订单，则开启另一个线程调用createVouncherOrder用来实现真正创建订单：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createVoucherOrder</span><span class=\"params\">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> voucherOrder.getUserId();</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">voucherId</span> <span class=\"operator\">=</span> voucherOrder.getVoucherId();</span><br><span class=\"line\">    <span class=\"comment\">// 创建锁对象</span></span><br><span class=\"line\">    <span class=\"type\">RLock</span> <span class=\"variable\">redisLock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;lock:order:&quot;</span> + userId);</span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取锁</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> redisLock.tryLock();</span><br><span class=\"line\">    <span class=\"comment\">// 判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取锁失败，直接返回失败或者重试</span></span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;不允许重复下单！&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5.1.查询订单</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> query().eq(<span class=\"string\">&quot;user_id&quot;</span>, userId).eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class=\"line\">        <span class=\"comment\">// 5.2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用户已经购买过了</span></span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;不允许重复下单！&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 6.扣减库存</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> seckillVoucherService.update()</span><br><span class=\"line\">                .setSql(<span class=\"string\">&quot;stock = stock - 1&quot;</span>) <span class=\"comment\">// set stock = stock - 1</span></span><br><span class=\"line\">                .eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).gt(<span class=\"string\">&quot;stock&quot;</span>, <span class=\"number\">0</span>) <span class=\"comment\">// where id = ? and stock &gt; 0</span></span><br><span class=\"line\">                .update();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 扣减失败</span></span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;库存不足！&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 7.创建订单</span></span><br><span class=\"line\">        save(voucherOrder);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        redisLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>同步下单：判断有没有资格，执行业务加各种锁，业务执行完耗时较久</p>\r\n<p>异步下单：业务分成两部分，一部分是Redis进行抢购资格的判断（如果有资格，则立即下单成功）；耗时较久的下单部分（操作数据库）异步完成，放入阻塞队列</p>\r\n<p>故接下来利用阻塞队列实现异步下单：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//异步处理线程池</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">SECKILL_ORDER_EXECUTOR</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">   SECKILL_ORDER_EXECUTOR.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrderHandler</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用于线程池处理的任务</span></span><br><span class=\"line\"><span class=\"comment\">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoucherOrderHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 1.获取队列中的订单信息</span></span><br><span class=\"line\">                    <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> orderTasks.take();</span><br><span class=\"line\">                    <span class=\"comment\">// 2.创建订单</span></span><br><span class=\"line\">                    createVouncherOrder(voucherOrder);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;处理订单异常&quot;</span>, e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">          \t &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>线程池（<code>SECKILL_ORDER_EXECUTOR</code>）</strong>：</p>\r\n<ul>\r\n<li>创建了一个单线程的线程池（<code>Executors.newSingleThreadExecutor()</code>），用于异步处理订单。</li>\r\n<li><code>orderTasks</code> 是一个阻塞队列，用于存储待处理的订单</li>\r\n<li>利用 <code>@PostConstruct</code> 注解，在 Spring\r\n容器初始化该类后便会执行init方法， 调用submit方法将\r\n<code>VoucherOrderHandler</code> 任务提交到线程池</li>\r\n<li><strong><code>VoucherOrderHandler</code> 任务的核心逻辑：</strong>\r\n<ul>\r\n<li><code>while (true)</code>：保证线程池中的线程\r\n<strong>持续运行</strong>，不停从队列中获取订单进行处理。</li>\r\n<li><code>orderTasks.take()</code>：\r\n<ul>\r\n<li>这是从阻塞队列中获取订单的逻辑，如果队列为空，<code>take()</code>\r\n方法会阻塞线程，直到队列中有新的订单加入（实现高效的任务调度）。</li>\r\n</ul></li>\r\n<li><strong><code>createVoucherOrder(voucherOrder)</code>：</strong>取到订单后，调用\r\n<code>createVoucherOrder</code> 方法完成实际的订单创建操作。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"redis消息队列\">4.2 Redis消息队列</h3>\r\n<h4 id=\"消息队列三种类型介绍\">4.2.1 消息队列三种类型介绍</h4>\r\n<p>消息队列是JVM以外独立服务，解决内存问题；存入磁盘，且需要消费者确认，不然一直投递到消费者。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653574849336-1734362376723.png\"\r\nalt=\"1653574849336\" />\r\n<figcaption aria-hidden=\"true\">1653574849336</figcaption>\r\n</figure>\r\n<p><strong>基于List结构模拟消息队列</strong>：Redis的list数据结构是一个双向链表，很容易模拟出队列效果</p>\r\n<p>优点：</p>\r\n<ul>\r\n<li>利用Redis存储，不受限于JVM内存上限，基于Redis的持久化机制，数据安全性有保证</li>\r\n<li>可以满足消息有序性</li>\r\n</ul>\r\n<p>缺点：</p>\r\n<ul>\r\n<li>无法避免消息丢失（从队列中取走未消费，想去再取发现没了）</li>\r\n<li>只支持单消费者</li>\r\n</ul>\r\n<p><strong>基于PubSub的消息队列</strong>：PubSub（发布订阅）是Redis2.0版本引入的消息传递模型，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>\r\n<p>优点：</p>\r\n<ul>\r\n<li>采用发布订阅模型，支持多生产、多消费</li>\r\n</ul>\r\n<p>缺点：</p>\r\n<ul>\r\n<li>不支持数据持久化（更像是一个通道，未被订阅则消失）</li>\r\n<li>无法避免消息丢失</li>\r\n<li>消息堆积有上限，超出时数据丢失（不在内存保存，数据在消费者有个缓存区域，做处理，处理较慢时空间超过则丢失）</li>\r\n</ul>\r\n<p><strong>基于Stream的消息队列</strong>：Redis 5.0\r\n引入的一种新数据类型，可以实现一个功能非常完善的消息队列</p>\r\n<h4 id=\"基于stream的消息队列实现\">4.2.2 基于Stream的消息队列实现</h4>\r\n<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，STREAM类型消息队列的XREAD命令特点：</p>\r\n<ul>\r\n<li>消息可回溯</li>\r\n<li>一个消息可以被多个消费者读取</li>\r\n<li>可以阻塞读取</li>\r\n<li><strong>有消息漏读的风险</strong></li>\r\n</ul>\r\n<p><strong>漏读</strong>：如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>\r\n<p><strong>解决方案：</strong>利用消费者组</p>\r\n<p>消费者组（Consumer\r\nGroup）：将多个消费者划分到一个组中，监听同一个队列；可以进行<strong>消息分流</strong>，队列中的消息会分流给组内的不同消费者（组内消费者竞争）、<strong>消息标识</strong>，消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费、<strong>消息确认</strong>，消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。</p>\r\n<p>创建消费者组： <img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653577984924-1734362376723.png\"\r\nalt=\"1653577984924\" /> key：队列名称 groupName：消费者组名称\r\nID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息\r\nMKSTREAM：队列不存在时自动创建队列</p>\r\n<p><strong>小结：</strong></p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653578560691-1734362376723.png\"\r\nalt=\"1653578560691\" />\r\n<figcaption aria-hidden=\"true\">1653578560691</figcaption>\r\n</figure>\r\n<p>修改lua表达式,新增3.6\r\n，将消息发送到队列中，队列名称为stream.orders</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1656082824939-1734362376723.png\"\r\nalt=\"1656082824939\" />\r\n<figcaption aria-hidden=\"true\">1656082824939</figcaption>\r\n</figure>\r\n<p>修改VouncherOrderServiceImpl代码：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoucherOrderHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class=\"line\">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class=\"line\">                    Consumer.from(<span class=\"string\">&quot;g1&quot;</span>, <span class=\"string\">&quot;c1&quot;</span>),</span><br><span class=\"line\">                    StreamReadOptions.empty().count(<span class=\"number\">1</span>).block(Duration.ofSeconds(<span class=\"number\">2</span>)),</span><br><span class=\"line\">                    StreamOffset.create(<span class=\"string\">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class=\"line\">                );</span><br><span class=\"line\">                <span class=\"comment\">// 2.判断订单信息是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (list == <span class=\"literal\">null</span> || list.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析数据</span></span><br><span class=\"line\">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class=\"line\">                <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> BeanUtil.fillBeanWithMap(value, <span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrder</span>(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 3.创建订单</span></span><br><span class=\"line\">                createVoucherOrder(voucherOrder);</span><br><span class=\"line\">                <span class=\"comment\">// 4.确认消息 XACK</span></span><br><span class=\"line\">                stringRedisTemplate.opsForStream().acknowledge(<span class=\"string\">&quot;s1&quot;</span>, <span class=\"string\">&quot;g1&quot;</span>, record.getId());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;处理订单异常&quot;</span>, e);</span><br><span class=\"line\">                <span class=\"comment\">//处理异常消息</span></span><br><span class=\"line\">                handlePendingList();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<p>其中\r\nhandlePendingList即用来处理异常订单，即没有被ACK标记已经处理的订单：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handlePendingList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class=\"line\">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class=\"line\">                    Consumer.from(<span class=\"string\">&quot;g1&quot;</span>, <span class=\"string\">&quot;c1&quot;</span>),</span><br><span class=\"line\">                    StreamReadOptions.empty().count(<span class=\"number\">1</span>),</span><br><span class=\"line\">                    StreamOffset.create(<span class=\"string\">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class=\"string\">&quot;0&quot;</span>))</span><br><span class=\"line\">                );</span><br><span class=\"line\">                <span class=\"comment\">// 2.判断订单信息是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (list == <span class=\"literal\">null</span> || list.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析数据</span></span><br><span class=\"line\">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class=\"line\">                <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> BeanUtil.fillBeanWithMap(value, <span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrder</span>(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 3.创建订单</span></span><br><span class=\"line\">                createVoucherOrder(voucherOrder);</span><br><span class=\"line\">                <span class=\"comment\">// 4.确认消息 XACK</span></span><br><span class=\"line\">                stringRedisTemplate.opsForStream().acknowledge(<span class=\"string\">&quot;s1&quot;</span>, <span class=\"string\">&quot;g1&quot;</span>, record.getId());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>至此，我们对于优惠券秒杀业务已经全部完成！下面是利用一些现成的mq，比如（kafka，<strong>rabbitmq</strong>）来实现消息队列，见五、RabbitMQ篇</p>\r\n<h1 id=\"二新增业务数据库准备\">二、新增业务数据库准备</h1>\r\n<p>涉及到优惠券秒杀业务的数据库有：</p>\r\n<p>管理端表 employee ：已经存在，<strong>实现增删优惠券</strong></p>\r\n<p>用户表 user: 已经存在，<strong>实现抢购秒杀优惠券</strong></p>\r\n<p>优惠券表voucher包括：优惠券标题、副标题、使用规则、支付金额、抵扣金额、劵类型、优惠券状态、创建时间和更新时间，<strong>实现记录优惠券信息</strong></p>\r\n<p>优惠券订单表voucher_order包括：下单用户的ID、购买优惠券ID、支付方式、订单状态、下单时间、支付时间、核销时间、退款时间、更新时间，<strong>实现记录用户抢购的优惠券订单，普通券没库存</strong></p>\r\n<p>秒杀券表voucher_seckill包括：关联的优惠券ID（主键）、库存、创建时间、生效时间、失效时间、更新时间、外键关联秒杀优惠券表，与优惠券是一对一关系</p>\r\n<h2 id=\"接口设计和实体类设计\">接口设计和实体类设计</h2>\r\n<p>管理端操作优惠券：实现如下功能</p>\r\n<p>路径：<code>http://localhost:8080/admin/voucher</code></p>\r\n<ol type=\"1\">\r\n<li>添加普通券：路径不变、POST方式（传入VoucherDTO对象）、返回优惠券ID</li>\r\n<li>添加秒杀券：路径：<code>/seckill</code>、Post方式（传入VoucherDTO对象，其中额外包括秒杀属性）、返回优惠券ID</li>\r\n<li>分页查询优惠券列表：路径：<code>/list</code>、Get方式（传入VoucherPageQueryDTO），返回VoucherVO对象（包含voucher中部分属性：优惠券标题、副标题、使用规则、支付金额、抵扣金额、劵类型、优惠券状态）</li>\r\n<li>下架优惠券，路径：<code>/delete/&#123;id&#125;</code>、DELETE方式，返回无，直接按照id删除对应优惠券</li>\r\n</ol>\r\n<p>实体类：</p>\r\n<p>public class Voucher :包含属性同数据库属性</p>\r\n<p>public class VouncherSeckill：仅含秒杀券的属性</p>\r\n<p>public class VouncherDTO：普通券表 +\r\n秒杀券表的额外属性，去掉创建和更新时间</p>\r\n<p>客户端：</p>\r\n<p>查询优惠券，路径同前面</p>\r\n<p>购买优惠券：路径<code>http://localhost:8080/user/voucher/&#123;id&#125;</code>、POST请求路径参数传入购买的用户券ID、返回购买的优惠券ID或购买失败信息；</p>\r\n<p>public class VouncherOrder：与订单表对应</p>\r\n<h2 id=\"代码框架与实现思路\">代码框架与实现思路</h2>\r\n<p>管理端（小）：</p>\r\n<p>controller层做接受信息，调用voucherService实现业务逻辑，在service中调用mapper实现数据库操作</p>\r\n<ul>\r\n<li><p>添加普通券：利用MybatisPlus在Service中直接实现save（）</p></li>\r\n<li><p>添加秒杀券：调用service实现类，先利用mp添加优惠券，再保存秒杀信息，利用mp添加秒杀券</p></li>\r\n<li><p>查询优惠券订单：调用service的Query方法，利用mp自定义实体类实现</p></li>\r\n</ul>\r\n<p>分页查询，利用插件设置分页参数，自动加入Limit语句（创建一个\r\n<code>Page</code> 对象，这个 <code>Page</code> 对象用于 MyBatis Plus\r\n的分页查询，它会自动计算 SQL 查询的分页偏移量\r\n<code>LIMIT</code>），同时传入<code>wrapper</code>设置查询条件（注意if条件判断，如果没有就不加这个查询条件），返回<code>Page&lt;Voucher&gt;</code>\r\n对象，它包含了查询结果和分页信息，再转换为voucherVO传给前端</p>\r\n<p>传给前端时需要：new 一个PageResult对象</p>\r\n<p><code>page.getTotal()</code>：获取分页结果的总记录数。</p>\r\n<p><code>page.getRecords()</code>：获取分页后的数据记录（即\r\n<code>VoucherVO</code> 对象的列表）。</p>\r\n<ul>\r\n<li>删除优惠券：通过路径参数传入删除的券ID，判断券是否是秒杀券类型，如果是还要删除秒杀券表中的信息；</li>\r\n</ul>\r\n<p>客户端（大）：</p>\r\n<p>实现查询优惠券，分页查询，用redis实现，解决缓存击穿/穿透问题</p>\r\n<p>购买时按照note中的逻辑实现：</p>\r\n<p>建立User的Controller，Service，重点是serviceImpl</p>\r\n<p>主要流程：</p>\r\n<p>本质上是用户下单，减少库存，创建订单表</p>\r\n<p>1.乐观锁解决超卖问题</p>\r\n<p>2.redisson分布式锁解决集群模式下一人一单问题</p>\r\n<p>3.秒杀优化中实现异步秒杀（Redis解决前面两个问题，多线程消息队列对接数据库操作）</p>\r\n<p>实现思路（逻辑）：</p>\r\n<p>Controller传入下单ID，orderService调用下单方法</p>\r\n<p>下单方法实现：</p>\r\n<ol type=\"1\">\r\n<li>创建订单全局唯一ID</li>\r\n<li>执行lua脚本，全程在redis实现：判断库存是否充足（解决超卖）、判断用户是否下单（一人一单）、扣库存，下单（保存用户ID到redis），发送下单消息到消息队列</li>\r\n<li>返回Lua脚本执行结果（1库存不足，2不能重复下单，0成功），成功直接返回订单全局唯一ID（返回给用户认为已经下单）</li>\r\n</ol>\r\n<p>异步下单：</p>\r\n<ul>\r\n<li>在下单方法的所在类初始化完成即会创建一个单线程的线程池，提交任务；</li>\r\n<li>新定义任务类，不断地从消息队列取订单消息（利用GROUP），如果为null(没有消息时)，继续下一次循环；取到消息后解析数据，调用创建订单函数创建订单，发送ACK确认消息，代表取到消息了；一旦发送堵塞等某些异常消息，有未确认消息线程进入\r\nPending List，系统定期处理（与上面的一样的处理方式）</li>\r\n<li>在创建订单部分，再次加锁（双重保证一人一单问题）</li>\r\n</ul>\r\n<p>实现了一个基于 Redis 和 Spring 的高性能秒杀系统，采用 Redis 的\r\n<strong>Lua\r\n脚本</strong>进行秒杀资格的快速校验，包括库存扣减和防止重复下单，同时将秒杀成功的订单数据写入\r\nRedis <strong>Stream 队列</strong>。后台通过线程池异步监听队列，从\r\nStream 中消费订单数据并创建订单，保证主线程的响应速度。订单创建中使用\r\n<strong>分布式锁</strong>（Redisson\r\n实现）确保同一用户不会重复下单，并安全扣减库存。系统还实现了异常处理机制，通过\r\nPending List\r\n确保未确认的订单消息不会丢失，从而实现了高并发场景下的订单创建、一人一单、库存安全以及消息可靠性保障的完整流程。</p>\r\n<h3 id=\"秒杀总结流程图\">秒杀总结流程图</h3>\r\n<p>前置：1. 生成全局唯一ID 2.编写Lua脚本内容 3.创建常量，以及线程池</p>\r\n<ol type=\"1\">\r\n<li>用户发起秒杀请求 → 执行 Redis Lua 脚本：\r\n<ul>\r\n<li>库存扣减，创建订单到消息队列</li>\r\n<li>数据写入 Redis Stream 队列。</li>\r\n</ul></li>\r\n<li>后台线程不断监听 Redis Stream：\r\n<ul>\r\n<li>读取订单消息 → 解析数据 → 执行订单逻辑 → 确认消息。</li>\r\n</ul></li>\r\n<li>异常处理机制：\r\n<ul>\r\n<li>未确认消息进入 Pending List，系统定期处理。</li>\r\n</ul></li>\r\n</ol>\r\n<h1 id=\"三实现过程中遇到的qa\">三、实现过程中遇到的Q&amp;A</h1>\r\n<ol type=\"1\">\r\n<li>mapper中方法对应的xml映射文件报错</li>\r\n</ol>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241213182608385.png\"\r\nalt=\"image-20241213182608385\" />\r\n<figcaption aria-hidden=\"true\">image-20241213182608385</figcaption>\r\n</figure>\r\n<p>在升级为mp后，xml映射文件中的parameterType和resultType报错，传统的\r\nMyBatis 配置中，如果 <code>parameterType</code> 和\r\n<code>resultType</code> 中只写类名，MyBatis 会假定你的类在\r\n<code>typeAliasesPackage</code> 配置中定义的包路径下；在 MyBatis-Plus\r\n中，通常鼓励开发者使用注解而不是 XML 映射。MyBatis-Plus\r\n并不会自动假设类的路径，因为它简化了传统的 XML\r\n映射配置，所以现在需要加上全部路径的类名</p>\r\n<p>2.请求路径正确，代码正确，如果发送没有反应，就检查@Requestbody是否添加（json格式数据接收时），如果也没问题，检查实体类和发送的json数据是否有不一样的地方，大多是类型不一样的时候（如BigDecimal需要带小数），测试的数据必须一点点排查</p>\r\n<p>3.在批量删除时，也想利用save方法直接实现类似新增的一样，直接构建wrapper条件，不去调用其他的service/mapper，但是报错：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241214171044538.png\"\r\nalt=\"image-20241214171044538\" />\r\n<figcaption aria-hidden=\"true\">image-20241214171044538</figcaption>\r\n</figure>\r\n<p>只能调用相对应的mapper进行，如果用Db去实现就会报错，db无法找到实体类对应的数据库表</p>\r\n<p>4.分页查询mp版本与jsql不兼容，手动再引入</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241214174058272.png\"\r\nalt=\"image-20241214174058272\" />\r\n<figcaption aria-hidden=\"true\">image-20241214174058272</figcaption>\r\n</figure>\r\n<p>JSqlParser 在 MyBatis-Plus\r\n分页中的作用：分页操作中，<code>JSqlParser</code> 是由 MyBatis-Plus 的\r\n<code>PaginationInnerInterceptor</code> 使用的，它的主要作用是\r\n<strong>解析原始 SQL 并在其基础上自动添加分页逻辑</strong>。</p>\r\n<p>5.设置用户端查询时，利用cacheclient的quryByID函数进行查询，改装函数，改进：1.缓存穿透和缓存击穿同时实现\r\n2.解决第一次查询为null的问题</p>\r\n<p>在缓存击穿的逻辑上增加穿透的实现，利用互斥锁，获得锁的线程去重建缓存数据，其开启一个新线程去重建数据，可以最多等待0.5秒获取新数据，其他没获得锁的线程返回旧的信息</p>\r\n<p>6.TODO：当前缓存查询只能通过ID查询缓存并解决缓存击穿，不能通过其他属性类，且是按照ID，没法返回List（不确定）</p>\r\n<p>7.添加优惠券到数据库的时候，会添加秒杀券到redis，虽然voucherSeckill.getStock()是一个Integer对象，但因为\r\n<code>RedisTemplate</code>\r\n的序列化方式存入Redis变成了乱码，导致在lua脚本无法识别数字</p>\r\n<p><strong>解决办法</strong>：</p>\r\n<p>无效尝试：在存储库存值时将 <code>Integer</code>\r\n显式转换为字符串存储，还是有乱码只是少了点；</p>\r\n<p><strong>有效方案：</strong>使用 <code>StringRedisTemplate</code>\r\n来简化处理，<code>@Autowired</code>注入，然后利用其来保证存储正确数据；</p>\r\n<p><code>stringRedisTemplate.opsForValue().set(\"seckill:stock:\" + voucherSeckill.getVoucherId(), voucherSeckill.getStock().toString());</code></p>\r\n<p>确保在 Lua 脚本中将 Redis 中存储的字符串值通过\r\n<code>tonumber()</code> 转换为数字。</p>\r\n<p>8.执行Lua脚本，始终返回1，代表库存不足，没找到原因</p>\r\n<p>在Lua中添加调试信息：</p>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> stock = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, stockKey)</span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;set&#x27;</span>, <span class=\"string\">&#x27;debug:stockKey_check&#x27;</span>, <span class=\"string\">&#x27;StockKey is: &#x27;</span> .. stockKey)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (stock == <span class=\"literal\">false</span> <span class=\"keyword\">or</span> <span class=\"built_in\">tonumber</span>(stock) &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"comment\">-- 3.2 库存不存在或不足则返回1</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;set&#x27;</span>, <span class=\"string\">&#x27;debug:stock_check&#x27;</span>, <span class=\"string\">&#x27;Stock is: &#x27;</span> .. <span class=\"built_in\">tostring</span>(<span class=\"built_in\">tonumber</span>(stock)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\r\n<p>发现stockKey的名称为乱码：seckill:stock:�� \u0005t\r\n\u000210，遂检查代码，发现执行脚本时也是redisTemplate，于是把所有的redisTemplate全部换成StringRedisTemplate</p>\r\n<p>最终测试：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241216210259589.png\"\r\nalt=\"image-20241216210259589\" />\r\n<figcaption aria-hidden=\"true\">image-20241216210259589</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241216222127491.png\"\r\nalt=\"image-20241216222127491\" />\r\n<figcaption aria-hidden=\"true\">image-20241216222127491</figcaption>\r\n</figure>\r\n<p>最终结果：只有一个线程可以同时下单成功</p>\r\n<h1 id=\"四mybatis-plus学习总结\">四、Mybatis-plus学习总结</h1>\r\n<p>配置mp：</p>\r\n<p>引入依赖：</p>\r\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.baomidou<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.3.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>配置：</p>\r\n<p>application.yml:</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">mybatis-plus:</span></span><br><span class=\"line\">    <span class=\"attr\">mapper-locations:</span> <span class=\"string\">$&#123;sky.mybatis-plus.mapper-locations&#125;</span> <span class=\"comment\"># 如果使用 XML 映射文件</span></span><br><span class=\"line\">    <span class=\"attr\">configuration:</span></span><br><span class=\"line\">      <span class=\"attr\">log-impl:</span> <span class=\"string\">$&#123;sky.mybatis-plus.configuration.log-impl&#125;</span> <span class=\"comment\"># 开启 SQL 日志</span></span><br></pre></td></tr></table></figure>\r\n<p>配置实体类的别名扫描包：（一般都会默认配好）：</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mybatis-plus:</span></span><br><span class=\"line\">  <span class=\"attr\">type-aliases-package:</span> <span class=\"string\">com.itheima.mp.domain.po</span></span><br><span class=\"line\">  <span class=\"attr\">global-config:</span></span><br><span class=\"line\">    <span class=\"attr\">db-config:</span></span><br><span class=\"line\">      <span class=\"attr\">id-type:</span> <span class=\"string\">auto</span> <span class=\"comment\"># 全局id类型为自增长</span></span><br><span class=\"line\">  <span class=\"attr\">mapper-locations:</span> <span class=\"string\">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class=\"comment\"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure>\r\n<p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD，因此自定义的Mapper只要实现了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sky.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sky.entity.User;</span><br><span class=\"line\"><span class=\"comment\">// 泛型中的User就是与数据库对应的实体对象PO.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">VoucherMapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</p>\r\n<ul>\r\n<li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li>\r\n<li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li>\r\n<li>MybatisPlus会把名为id的字段作为主键</li>\r\n</ul>\r\n<p>至此我们已经配置好MP：1.引入pom文件，配置xml信息 2.实现BaseMapper</p>\r\n<h2 id=\"基本的增删改查crud\">基本的增删改查CRUD</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  @Autowired</span><br><span class=\"line\">    private UserMapper userMapper;</span><br><span class=\"line\">void method ()&#123;</span><br><span class=\"line\">\t userMapper.insert(user);</span><br><span class=\"line\">\t User user = userMapper.selectById(5L);</span><br><span class=\"line\">\t List&lt;User&gt; users = userMapper.selectBatchIds(List.of(1L, 2L, 3L, 4L, 5L));</span><br><span class=\"line\">\t userMapper.updateById(user);</span><br><span class=\"line\">\t userMapper.deleteById(5L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>常见注解：</strong></p>\r\n<p><code>@TableName</code>：用在实体类上，数据库注解，标识实体类对应的数据库表</p>\r\n<p>属性：value（表名）、schema（schema如sky-take-out(.表)）</p>\r\n<p><code>@TableId</code>：用在实体类的主键字段，主键注解，标识实体类中的主键字段、</p>\r\n<p>属性：value（表名）和type（主键类型）</p>\r\n<p><code>@TableField</code>：普通字段注解，一般不用</p>\r\n<h2 id=\"核心用法\">核心用法</h2>\r\n<h3 id=\"where条件\">Where条件</h3>\r\n<p>因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件，参数中的<code>Wrapper</code>就是条件构造的抽象类</p>\r\n<p>即<code>wrapper</code>是用来实现where条件的</p>\r\n<p>一般常用的有四种：</p>\r\n<p><strong>QueryWrapper</strong>：修改、删除、查询，都可以使用QueryWrapper来构建查询条件</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class=\"line\">QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;User&gt;()</span><br><span class=\"line\">        .select(<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;info&quot;</span>, <span class=\"string\">&quot;balance&quot;</span>)</span><br><span class=\"line\">        .like(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;o&quot;</span>)</span><br><span class=\"line\">        .ge(<span class=\"string\">&quot;balance&quot;</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2.查询数据</span></span><br><span class=\"line\">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>\r\n<p><strong>UpdateWrapper</strong>：SET的赋值结果是基于字段现有值的，需要利用UpdateWrapper的setSql功能</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testUpdateWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    List&lt;Long&gt; ids = List.of(<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">4L</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 1.生成SQL</span></span><br><span class=\"line\">    UpdateWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">UpdateWrapper</span>&lt;User&gt;()</span><br><span class=\"line\">            .setSql(<span class=\"string\">&quot;balance = balance - 200&quot;</span>) <span class=\"comment\">// SET balance = balance - 200</span></span><br><span class=\"line\">            .in(<span class=\"string\">&quot;id&quot;</span>, ids); <span class=\"comment\">// WHERE id in (1, 2, 4)</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class=\"line\">    <span class=\"comment\">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class=\"line\">    userMapper.update(<span class=\"literal\">null</span>, wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>对于前两种Wrapper写死了构造条件的字段值，下面利用Lambda的Wrapper更为常用（基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了）</p>\r\n<p><strong>LambdaQueryWrapper/LambdaUpdateWrapper</strong>：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testLambdaQueryWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class=\"line\">    QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;&gt;();</span><br><span class=\"line\">    wrapper.lambda()</span><br><span class=\"line\">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class=\"line\">            .like(User::getUsername, <span class=\"string\">&quot;o&quot;</span>) <span class=\"comment\">//利用这种方式获取数据库的信息，后面的是传入的参数信息</span></span><br><span class=\"line\">            .ge(User::getBalance, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2.查询</span></span><br><span class=\"line\">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class=\"line\">    users.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"自定义sql\">自定义SQL</h3>\r\n<p>在上面的测试案例中，SQL语句写在了Service层，是不可以的，现在要写到Mapper，自定义SQL：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testCustomWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.准备自定义查询条件</span></span><br><span class=\"line\">    List&lt;Long&gt; ids = List.of(<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">4L</span>);</span><br><span class=\"line\">    QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;User&gt;().in(<span class=\"string\">&quot;id&quot;</span>, ids);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class=\"line\">    userMapper.deductBalanceByIds(<span class=\"number\">200</span>, wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后在UserMapper中自定义SQL：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itheima.mp.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.po.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Update;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserMapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下面的$&#123;ew.customSqlSegment&#125;是固定写法</span></span><br><span class=\"line\">    <span class=\"meta\">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deductBalanceByIds</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;money&quot;)</span> <span class=\"type\">int</span> money, <span class=\"meta\">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><code>UPDATE user SET balance = balance - #&#123;money&#125;</code>：更新\r\n<code>user</code> 表中的 <code>balance</code>\r\n字段，扣除指定金额，<code>#&#123;money&#125;</code> 是一个 MyBatis\r\n的占位符，表示将方法参数 <code>money</code>\r\n的值传入。而<code>$&#123;ew.customSqlSegment&#125;</code>则表示将\r\n<code>QueryWrapper&lt;User&gt;</code> 类型的参数 <code>ew</code> 中的\r\n<code>customSqlSegment</code> 内容插入到 SQL\r\n语句中。<code>customSqlSegment</code> 是 <code>QueryWrapper</code>\r\n对象中一个特殊的属性，它允许我们在查询条件中动态地插入额外的 SQL\r\n片段（例如 <code>WHERE</code>\r\n子句）。利用${}而不是#{}，因为#{}是参数替换，${}是字符串拼接</p>\r\n<p><code>QueryWrapper&lt;User&gt;</code> 中的泛型是 <code>User</code>，\r\n<code>QueryWrapper</code> 基于User实体类构建 <code>User</code> 表的 SQL\r\n条件</p>\r\n<p>MyBatisPlus不支持多表查询，我们可以利用Wrapper<strong>中自定义条件</strong>结合自定义SQL来实现多表查询的效果：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testCustomJoinWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.准备自定义查询条件</span></span><br><span class=\"line\">    QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;User&gt;()</span><br><span class=\"line\">            .in(<span class=\"string\">&quot;u.id&quot;</span>, List.of(<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">4L</span>))</span><br><span class=\"line\">            .eq(<span class=\"string\">&quot;a.city&quot;</span>, <span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2.调用mapper的自定义方法</span></span><br><span class=\"line\">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class=\"line\"></span><br><span class=\"line\">    users.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后在UserMapper中自定义方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class=\"line\">List&lt;User&gt; <span class=\"title function_\">queryUserByWrapper</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure>\r\n<p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p>\r\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;queryUserByIdAndAddr&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class=\"line\">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"service接口\">Service接口</h2>\r\n<h3 id=\"基本用法\">基本用法</h3>\r\n<p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法</p>\r\n<p><code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法</p>\r\n<p>自定义IUserService接口继承IService</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itheima.mp.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.po.User;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IUserService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">IService</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拓展自定义方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后，编写<code>UserServiceImpl</code>类，继承<code>ServiceImpl</code>，实现<code>UserService</code>：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itheima.mp.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.po.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.po.service.IUserService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.mapper.UserMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ServiceImpl</span>&lt;UserMapper, User&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserService</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><code>ServiceImpl</code> 是 MyBatis-Plus\r\n提供的一个基类，它是一个通用的服务类实现，封装了很多常见的 CRUD\r\n操作。<code>ServiceImpl</code> 实现了 <code>IService</code>\r\n接口，并且提供了 <code>IService</code> 中定义的方法的默认实现</p>\r\n<p>有了Service接口，可以直接在Controller中操作到数据库</p>\r\n<p>编写Controller层代码：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;users&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IUserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(&quot;新增用户&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">saveUser</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> UserFormDTO userFormDTO)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.转换DTO为PO</span></span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> BeanUtil.copyProperties(userFormDTO, User.class);</span><br><span class=\"line\">        <span class=\"comment\">// 2.新增</span></span><br><span class=\"line\">        userService.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(&quot;删除用户&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeUserById</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class=\"line\">        userService.removeById(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(&quot;根据id查询用户&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserVO <span class=\"title function_\">queryUserById</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.查询用户</span></span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> userService.getById(userId);</span><br><span class=\"line\">        <span class=\"comment\">// 2.处理vo</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;UserVO&gt; <span class=\"title function_\">queryUserByIds</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.查询用户</span></span><br><span class=\"line\">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class=\"line\">        <span class=\"comment\">// 2.处理vo</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><code>@RequiredArgsConstructor</code> 是 <strong>Lombok</strong>\r\n提供的一个注解，它会自动生成一个构造函数，该构造函数包含所有\r\n<strong><code>final</code></strong> 或\r\n<strong><code>@NonNull</code></strong>\r\n注解标注的字段。代码中的作用是自动为 <code>userService</code>\r\n字段生成一个构造函数，以便在类初始化时注入依赖。（<code>@RequiredArgsConstructor</code>，不需要手动写构造函数，只需要标注\r\n<code>final</code>\r\n字段，它会自动完成依赖注入的工作，就不用@Autowired了）</p>\r\n<p>上面的例子非常方便的实现了在Controller层的简单CRUD，但是业务逻辑代码就需要在Service层再写了</p>\r\n<p>如：根据id扣减用户余额</p>\r\n<p>需要先判断用户状态，然后判断余额，最后扣减</p>\r\n<p>首先在UserController中定义一个方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ApiOperation(&quot;扣减用户余额&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deductBalance</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long id, <span class=\"meta\">@PathVariable(&quot;money&quot;)</span>Integer money)</span>&#123;</span><br><span class=\"line\">    userService.deductBalance(id, money);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后是UserService接口：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itheima.mp.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.po.User;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IUserService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">IService</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deductBalance</span><span class=\"params\">(Long id, Integer money)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后是UserServiceImpl实现类：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ServiceImpl</span>&lt;UserMapper, User&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deductBalance</span><span class=\"params\">(Long id, Integer money)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.查询用户</span></span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getById(id);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断用户状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span> || user.getStatus() == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;用户状态异常&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3.判断用户余额</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;用户余额不足&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.扣减余额 baseMapper是父接口</span></span><br><span class=\"line\">        baseMapper.deductMoneyById(id, money);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后是mapper：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">deductMoneyById</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Long id, <span class=\"meta\">@Param(&quot;money&quot;)</span> Integer money)</span>;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"lambda功能简化\">Lambda功能简化</h3>\r\n<p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</p>\r\n<p>接下来我们在UserController中定义一个controller方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/list&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;UserVO&gt; <span class=\"title function_\">queryUsers</span><span class=\"params\">(UserQuery query)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.组织条件</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> query.getName();</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> query.getStatus();</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">minBalance</span> <span class=\"operator\">=</span> query.getMinBalance();</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">maxBalance</span> <span class=\"operator\">=</span> query.getMaxBalance();</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class=\"line\">            .like(username != <span class=\"literal\">null</span>, User::getUsername, username)</span><br><span class=\"line\">            .eq(status != <span class=\"literal\">null</span>, User::getStatus, status)</span><br><span class=\"line\">            .ge(minBalance != <span class=\"literal\">null</span>, User::getBalance, minBalance)</span><br><span class=\"line\">            .le(maxBalance != <span class=\"literal\">null</span>, User::getBalance, maxBalance);</span><br><span class=\"line\">    <span class=\"comment\">// 2.查询用户</span></span><br><span class=\"line\">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class=\"line\">    <span class=\"comment\">// 3.处理vo</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在组织查询条件的时候，我们加入了 <code>username != null</code>\r\n这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<code>&lt;if&gt;</code>标签。这样就实现了动态查询条件效果了</p>\r\n<p>进一步地，Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code></p>\r\n<p>基于Lambda查询：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/list&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;UserVO&gt; <span class=\"title function_\">queryUsers</span><span class=\"params\">(UserQuery query)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.组织条件</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> query.getName();</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> query.getStatus();</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">minBalance</span> <span class=\"operator\">=</span> query.getMinBalance();</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">maxBalance</span> <span class=\"operator\">=</span> query.getMaxBalance();</span><br><span class=\"line\">    <span class=\"comment\">// 2.查询用户</span></span><br><span class=\"line\">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class=\"line\">            .like(username != <span class=\"literal\">null</span>, User::getUsername, username)</span><br><span class=\"line\">            .eq(status != <span class=\"literal\">null</span>, User::getStatus, status)</span><br><span class=\"line\">            .ge(minBalance != <span class=\"literal\">null</span>, User::getBalance, minBalance)</span><br><span class=\"line\">            .le(maxBalance != <span class=\"literal\">null</span>, User::getBalance, maxBalance)</span><br><span class=\"line\">            .list();</span><br><span class=\"line\">    <span class=\"comment\">// 3.处理vo</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：</p>\r\n<ul>\r\n<li><code>.one()</code>：最多1个结果</li>\r\n<li><code>.list()</code>：返回集合结果</li>\r\n<li><code>.count()</code>：返回计数结果</li>\r\n</ul>\r\n<p><strong>同理：IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务</strong></p>\r\n<p>实现如下：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deductBalance</span><span class=\"params\">(Long id, Integer money)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.查询用户</span></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getById(id);</span><br><span class=\"line\">    <span class=\"comment\">// 2.校验用户状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span> || user.getStatus() == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;用户状态异常！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3.校验余额是否充足</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;用户余额不足！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">remainBalance</span> <span class=\"operator\">=</span> user.getBalance() - money;</span><br><span class=\"line\">    lambdaUpdate()</span><br><span class=\"line\">            .set(User::getBalance, remainBalance) <span class=\"comment\">// 更新余额</span></span><br><span class=\"line\">            .set(remainBalance == <span class=\"number\">0</span>, User::getStatus, <span class=\"number\">2</span>) <span class=\"comment\">// 动态判断，是否更新status</span></span><br><span class=\"line\">            .eq(User::getId, id)</span><br><span class=\"line\">            .eq(User::getBalance, user.getBalance()) <span class=\"comment\">// 乐观锁</span></span><br><span class=\"line\">            .update();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>但是存在ABA问题：ABA 问题通常指的是在并发环境中，某个值在某个时刻从 A\r\n变成了 B，然后又变回\r\nA，外部系统无法检测到这个值曾经经历过变化，但实际上它已经发生了变化。这个问题常见于基于版本号或时间戳的乐观锁机制中。例如，乐观锁使用的是\r\n<code>eq(User::getBalance, user.getBalance())</code>，这意味着在更新余额时，系统会校验当前数据库中的余额是否与用户获取的余额相同。如果中间有其他线程修改了余额，但最终余额恢复到原值，则当前线程会错误地认为数据没有变化，导致错误的更新操作，所以用<strong>version比较好</strong></p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">lambdaUpdate()</span><br><span class=\"line\">    .set(User::getBalance, remainBalance)</span><br><span class=\"line\">    .set(remainBalance == <span class=\"number\">0</span>, User::getStatus, <span class=\"number\">2</span>)</span><br><span class=\"line\">    .eq(User::getId, id)</span><br><span class=\"line\">    .eq(User::getBalance, user.getBalance()) <span class=\"comment\">// 乐观锁</span></span><br><span class=\"line\">    .eq(User::getVersion, user.getVersion()) <span class=\"comment\">// 校验版本号</span></span><br><span class=\"line\">    .update();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"iservice中的批量新增功能\">IService中的批量新增功能</h3>\r\n<p>我们尝试逐条插入数据，发现时间非常慢，后调用mp的批量插入，发现效率也不高：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">    userService.save(buildUser(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 和</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">    list.add(buildUser(i));</span><br><span class=\"line\">    <span class=\"comment\">// 每1000条批量插入一次</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i % <span class=\"number\">1000</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        userService.saveBatch(list);</span><br><span class=\"line\">        list.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>查看MP部分源码：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">saveBatch</span><span class=\"params\">(Collection&lt;T&gt; entityList, <span class=\"type\">int</span> batchSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">sqlStatement</span> <span class=\"operator\">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...SqlHelper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"type\">boolean</span> <span class=\"title function_\">executeBatch</span><span class=\"params\">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class=\"type\">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class=\"line\">    Assert.isFalse(batchSize &lt; <span class=\"number\">1</span>, <span class=\"string\">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> list.size();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">idxLimit</span> <span class=\"operator\">=</span> Math.min(batchSize, size);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (E element : list) &#123;</span><br><span class=\"line\">            consumer.accept(sqlSession, element);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == idxLimit) &#123;</span><br><span class=\"line\">                sqlSession.flushStatements();</span><br><span class=\"line\">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>\r\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Preparing: <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class=\"keyword\">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class=\"line\">Parameters: user_1, <span class=\"number\">123</span>, <span class=\"number\">18688190001</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span></span><br><span class=\"line\">Parameters: user_2, <span class=\"number\">123</span>, <span class=\"number\">18688190002</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span></span><br><span class=\"line\">Parameters: user_3, <span class=\"number\">123</span>, <span class=\"number\">18688190003</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span></span><br></pre></td></tr></table></figure>\r\n<p>为了提高性能，我们希望插入语句是这样：</p>\r\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(user_1, <span class=\"number\">123</span>, <span class=\"number\">18688190001</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>),</span><br><span class=\"line\">(user_2, <span class=\"number\">123</span>, <span class=\"number\">18688190002</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>),</span><br><span class=\"line\">(user_3, <span class=\"number\">123</span>, <span class=\"number\">18688190003</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>),</span><br><span class=\"line\">(user_4, <span class=\"number\">123</span>, <span class=\"number\">18688190004</span>, &quot;&quot;, <span class=\"number\">2000</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>, <span class=\"number\">2023</span><span class=\"number\">-07</span><span class=\"number\">-01</span>);</span><br></pre></td></tr></table></figure>\r\n<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:即开启重写批处理的<code>statement</code>语句</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">MySQL123</span></span><br></pre></td></tr></table></figure>\r\n<p>可以大大提高效率啦~</p>\r\n<h2 id=\"其他功能\">其他功能</h2>\r\n<p><code>MyBatisPlus</code>插件：直接配置数据库，然后code\r\ngenerator即可</p>\r\n<p>Service之间相互调用可能会出现循环依赖问题（在插入订单Service中，还需要调用插入订单详情的Service，maybe死锁，互相等待对方注入），MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能。</p>\r\n<p>改造原本的UserVO：新增地址属性，List列表类型为AddressVO</p>\r\n<p><code>@ApiModelProperty(\"收货地址列表\")</code></p>\r\n<p><code>private List&lt;AddressV0&gt;addresses:</code>首先在IUserService中定义方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itheima.mp.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.po.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IUserService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">IService</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deduct</span><span class=\"params\">(Long id, Integer money)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVO <span class=\"title function_\">queryUserAndAddressById</span><span class=\"params\">(Long userId)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后，在UserServiceImpl中实现该方法：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> UserVO <span class=\"title function_\">queryUserAndAddressById</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.查询用户</span></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getById(userId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.查询收货地址</span></span><br><span class=\"line\">    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)</span><br><span class=\"line\">            .eq(Address::getUserId, userId)</span><br><span class=\"line\">            .list();</span><br><span class=\"line\">    <span class=\"comment\">// 3.处理vo</span></span><br><span class=\"line\">    <span class=\"type\">UserVO</span> <span class=\"variable\">userVO</span> <span class=\"operator\">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class=\"line\">    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p>\r\n<h2 id=\"分页查询\">分页查询</h2>\r\n<p>在config中添加配置类</p>\r\n<p>其代码如下：</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sky.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MybatisConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MybatisPlusInterceptor <span class=\"title function_\">mybatisPlusInterceptor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化核心插件</span></span><br><span class=\"line\">        <span class=\"type\">MybatisPlusInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MybatisPlusInterceptor</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 添加分页插件</span></span><br><span class=\"line\">        interceptor.addInnerInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interceptor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 真正查询代码</span></span><br><span class=\"line\"> <span class=\"comment\">//  1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class=\"line\">    Page&lt;User&gt; p = userService.page(<span class=\"keyword\">new</span> <span class=\"title class_\">Page</span>&lt;&gt;(<span class=\"number\">2</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 2.总条数</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;total = &quot;</span> + p.getTotal());</span><br><span class=\"line\">    <span class=\"comment\">// 3.总页数</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;pages = &quot;</span> + p.getPages());</span><br><span class=\"line\">    <span class=\"comment\">// 4.数据</span></span><br><span class=\"line\">    List&lt;User&gt; records = p.getRecords();</span><br><span class=\"line\">    records.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"五rabbitmq学习总结\">五、RabbitMQ学习总结</h1>\r\n<h2 id=\"rabbitmq基础知识学习\">5.1 RabbitMQ基础知识学习</h2>\r\n<h3 id=\"rabbitmq-配置定义交换机队列和路由键\">1. <strong>RabbitMQ\r\n配置：定义交换机、队列和路由键</strong></h3>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java复制代码<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitMqConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;voucher_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义队列</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;voucher_order_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义路由</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ROUTING_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;voucher.order&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Exchange <span class=\"title function_\">exchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ExchangeBuilder.directExchange(EXCHANGE).durable(<span class=\"literal\">true</span>).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE).build(); <span class=\"comment\">//队列持久化</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">binding</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"交换机exchange\">1.1 交换机（Exchange）</h4>\r\n<ul>\r\n<li><strong>Exchange</strong> 是 <code>RabbitMQ</code>\r\n中的一个核心概念，负责接收生产者发送的消息，并根据路由规则将消息分发到不同的队列。</li>\r\n<li>这里定义了一个名为 <code>voucher_exchange</code> 的 <strong>direct\r\nexchange</strong>，它将根据路由键将消息定向到具体的队列。</li>\r\n<li>使用 <code>durable(true)</code> 表示交换机是持久化的，意味着即使\r\nRabbitMQ 重启，交换机也不会丢失。</li>\r\n</ul>\r\n<h4 id=\"队列queue\">1.2 队列（Queue）</h4>\r\n<ul>\r\n<li><strong>Queue</strong>\r\n是消息的存储容器，消费者会从队列中获取消息进行处理。</li>\r\n<li>这里定义了一个名为 <code>voucher_order_queue</code> 的队列，并且通过\r\n<code>durable(true)</code>\r\n设置队列持久化，确保消息在队列重启后不会丢失。</li>\r\n</ul>\r\n<h4 id=\"路由routing-key和绑定binding\">1.3 路由（Routing\r\nKey）和绑定（Binding）</h4>\r\n<ul>\r\n<li><strong>Routing Key</strong>\r\n是一种路由机制，用于决定消息应发送到哪个队列。<code>voucher.order</code>\r\n是一个简单的字符串，用来与交换机的绑定进行匹配。</li>\r\n<li><strong>Binding</strong>\r\n将交换机和队列通过路由键绑定起来。<code>BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs()</code>\r\n表示将 <code>voucher_order_queue</code> 队列与\r\n<code>voucher_exchange</code> 交换机通过路由键\r\n<code>voucher.order</code> 进行绑定。</li>\r\n</ul>\r\n<h2 id=\"mq实现消息队列\">5.2 MQ实现消息队列</h2>\r\n<h3 id=\"rabbitmq-配置定义交换机队列和路由键-1\">1. <strong>RabbitMQ\r\n配置：定义交换机、队列和路由键</strong></h3>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitMqConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;voucher_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义队列</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;voucher_order_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义路由</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ROUTING_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;voucher.order&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Exchange <span class=\"title function_\">exchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ExchangeBuilder.directExchange(EXCHANGE).durable(<span class=\"literal\">true</span>).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE).build(); <span class=\"comment\">//队列持久化</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">binding</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"交换机exchange-1\">1.1 交换机（Exchange）</h3>\r\n<ul>\r\n<li><strong>Exchange</strong> 是 <code>RabbitMQ</code>\r\n中的一个核心概念，负责接收生产者发送的消息，并根据路由规则将消息分发到不同的队列。</li>\r\n<li>这里定义了一个名为 <code>voucher_exchange</code> 的 <strong>direct\r\nexchange</strong>，它将根据路由键将消息定向到具体的队列。</li>\r\n<li>使用 <code>durable(true)</code> 表示交换机是持久化的，意味着即使\r\nRabbitMQ 重启，交换机也不会丢失。</li>\r\n</ul>\r\n<h3 id=\"队列queue-1\">1.2 队列（Queue）</h3>\r\n<ul>\r\n<li><strong>Queue</strong>\r\n是消息的存储容器，消费者会从队列中获取消息进行处理。</li>\r\n<li>这里定义了一个名为 <code>voucher_order_queue</code> 的队列，并且通过\r\n<code>durable(true)</code>\r\n设置队列持久化，确保消息在队列重启后不会丢失。</li>\r\n</ul>\r\n<h3 id=\"路由routing-key和绑定binding-1\">1.3 路由（Routing\r\nKey）和绑定（Binding）</h3>\r\n<ul>\r\n<li><strong>Routing Key</strong>\r\n是一种路由机制，用于决定消息应发送到哪个队列。<code>voucher.order</code>\r\n是一个简单的字符串，用来与交换机的绑定进行匹配。</li>\r\n<li><strong>Binding</strong>\r\n将交换机和队列通过路由键绑定起来。<code>BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs()</code>\r\n表示将 <code>voucher_order_queue</code> 队列与\r\n<code>voucher_exchange</code> 交换机通过路由键\r\n<code>voucher.order</code> 进行绑定。</li>\r\n</ul>\r\n<p>在 <code>RabbitMQ</code>\r\n中，<strong>消息的路由</strong>是由交换机（Exchange）和路由键（Routing\r\nKey）来控制的，发送者并不需要直接指定消息发送到具体的队列，而是通过交换机将消息发送到队列，当消息发送到\r\n<code>voucher_exchange</code>\r\n交换机时，交换机会根据绑定的路由规则将消息分发到相应的队列即配置类中的:</p>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Binding <span class=\"title function_\">binding</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>将 <code>voucher_order_queue</code> 队列绑定到\r\n<code>voucher_exchange</code> 交换机，并使用路由键\r\n<code>voucher.order</code></p>\r\n<p>此外，<strong>RabbitMQ</strong>\r\n允许将同一条消息发送到多个队列，这是通过交换机的绑定关系来实现的，即创建两个<code>queue</code>，两个<code>binding</code>即可，如果不关心路由键，而是想把消息广播到多个队列，可以使用\r\n<code>fanout</code> 类型的交换机;<code>fanout</code>\r\n交换机会将所有消息广播到绑定到该交换机的所有队列，无论路由键是什么。</p>\r\n<h3 id=\"发送消息到-rabbitmq\">2. <strong>发送消息到\r\nRabbitMQ</strong></h3>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java复制代码<span class=\"keyword\">public</span> Result <span class=\"title function_\">purchase</span><span class=\"params\">(Long voucherId)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> <span class=\"number\">1010108L</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> redisIdWorker.nextId(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class=\"line\">            voucherId.toString(), userId.toString(), String.valueOf(orderId));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> result.intValue();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;库存不足&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;同一用户不能重复下单&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建订单对象</span></span><br><span class=\"line\">    <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> VoucherOrder.builder().userId(userId).voucherId(voucherId).id(orderId).build();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 发送消息到 RabbitMQ 队列</span></span><br><span class=\"line\">    amqpTemplate.convertAndSend(RabbitMqConfig.EXCHANGE, RabbitMqConfig.ROUTING_KEY, voucherOrder);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Result.success(<span class=\"string\">&quot;下单成功，订单号：&quot;</span> + orderId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>2.1 消息发送 </strong></p>\r\n<ul>\r\n<li>代码中通过 <code>amqpTemplate.convertAndSend()</code>\r\n发送消息。<code>amqpTemplate</code> 是 Spring\r\n提供的消息发送模板，它可以简化与 RabbitMQ 的交互。</li>\r\n<li><strong><code>convertAndSend</code></strong>\r\n方法将消息发送到指定的交换机、路由键和消息体。这里发送的是一个\r\n<code>voucherOrder</code> 对象，表示用户下单的请求。</li>\r\n<li><code>RabbitMqConfig.EXCHANGE</code>：交换机的名称，确保消息发送到正确的交换机。</li>\r\n<li><code>RabbitMqConfig.ROUTING_KEY</code>：路由键，用于确定消息应该被路由到哪个队列。</li>\r\n<li>消息体是 <code>voucherOrder</code> 对象，它封装了用户 ID、优惠券 ID\r\n和订单 ID。</li>\r\n</ul>\r\n<h3 id=\"消费消息并处理订单\">3. <strong>消费消息并处理订单</strong></h3>\r\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java复制代码<span class=\"meta\">@RabbitListener(queues = RabbitMqConfig.QUEUE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processOrder</span><span class=\"params\">(VoucherOrder voucherOrder, Channel channel, Message message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理订单逻辑，创建订单并扣减库存</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> voucherOrder.getUserId();</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">voucherId</span> <span class=\"operator\">=</span> voucherOrder.getVoucherId();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建锁对象，防止重复下单</span></span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">redisLock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;lock:order&quot;</span> + userId);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> redisLock.tryLock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 锁获取失败直接确认，不需要重新入队</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;不允许重复下单&quot;</span>);</span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查询订单是否已经存在</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> voucherOrderService.query().eq(<span class=\"string\">&quot;user_id&quot;</span>, userId).eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;不允许重复下单&quot;</span>);</span><br><span class=\"line\">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 扣减库存</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> seckillVoucherService.update().setSql(<span class=\"string\">&quot;stock = stock - 1&quot;</span>)</span><br><span class=\"line\">                    .eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherId).gt(<span class=\"string\">&quot;stock&quot;</span>, <span class=\"number\">0</span>).update();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;库存不足&quot;</span>);</span><br><span class=\"line\">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 创建订单</span></span><br><span class=\"line\">            voucherOrderService.save(voucherOrder);</span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            redisLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;处理订单失败&quot;</span>, e);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 异常时，发送 nack，重新入队重试</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;确认消息失败&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>3.1 消费者（Consumer）</strong></p>\r\n<ul>\r\n<li><code>@RabbitListener</code>\r\n注解用于声明该方法是一个消息监听器，它会自动从指定的队列（<code>voucher_order_queue</code>）接收消息。消费者监听该队列并处理队列中的消息。</li>\r\n</ul>\r\n<p><strong>3.2 锁机制</strong></p>\r\n<ul>\r\n<li>使用 Redisson 分布式锁 (<code>RLock</code>)\r\n防止同一用户重复下单。当获取到锁时，处理业务逻辑；如果获取锁失败（表示当前请求正在被其他线程处理），则直接返回，并且确认消息（<code>channel.basicAck()</code>），确保该消息不再被消费。</li>\r\n</ul>\r\n<p><strong>3.3 消息确认（Acknowledgment）</strong></p>\r\n<ul>\r\n<li><code>channel.basicAck()</code>：手动确认消息。当消息成功处理时（比如订单创建成功），通过\r\n<code>basicAck</code> 确认消息已处理，RabbitMQ 会将其从队列中移除。</li>\r\n<li><code>channel.basicNack()</code>：如果处理失败（比如扣减库存失败，或者发生异常），使用\r\n<code>basicNack</code>\r\n将消息重新入队，以便重试。<code>requeue=true</code>\r\n表示消息重新进入队列，待下次消费。</li>\r\n</ul>\r\n<p><strong>3.4 异常处理</strong></p>\r\n<ul>\r\n<li>如果在处理订单的过程中发生异常，<code>basicNack</code>\r\n会重新将消息放回队列，并且设置\r\n<code>requeue=true</code>，使得消息可以重新被消费。</li>\r\n</ul>\r\n","categories":["进厂学习记录"],"tags":["Redis","互斥锁","秒杀","mybatisplus"]}]