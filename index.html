<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">


<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/sjn/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="记录下学习与生活">
<meta property="og:type" content="website">
<meta property="og:title" content="SJN的个人小屋">
<meta property="og:url" content="https://github.com/Ning565/Ning565.github.io/index.html">
<meta property="og:site_name" content="SJN的个人小屋">
<meta property="og:description" content="记录下学习与生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="NING565">
<meta property="article:tag" content="加油、加油、加油">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Ning565/Ning565.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SJN的个人小屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SJN的个人小屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">静水流深，无问西东</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/12/17/%E6%98%9F%E9%A3%9F%E9%93%BE%E2%80%94%E2%80%94Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E6%98%9F%E9%A3%9F%E9%93%BE%E2%80%94%E2%80%94Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">星食链——Java学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-16 22:52:55 / 修改时间：15:27:14" itemprop="dateCreated datePublished" datetime="2024-12-16T22:52:55Z">2024-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="点餐系统搭建java项目总结报告">点餐系统搭建——Java项目总结报告</h1>
<p>开学以来到10月底先是以课内课程和准备英语免修为主，在考完英语免修以后开始系统学习<strong>黑马程序员</strong>的2024JavaWeb课程，其中并没有更新完毕的部分参考2023课程和飞书云文档自己学完了；此后便开始学习《苍穹外卖》项目，全程跟敲了所有内容，在外卖项目结束，为了提高自己对于Redis以及其他中间件的学习使用，在原基础上增加了秒杀优惠券业务，学习了RabbitMQ队列，下面的项目涉及的技术选型</p>
<h2 id="星食链项目技术报告">《星食链》项目技术报告</h2>
<p>“星食链”是一款为餐饮行业量身定制的全新智能餐饮服务平台，旨在通过科技驱动餐饮业的数字化转型，提升餐饮企业的运营效率和用户体验。作为一个面向商家与消费者的双向平台，<strong>星食链</strong>不仅能帮助餐饮企业优化日常管理流程、提升数据分析能力，还为消费者提供便捷的智能订餐体验。以下是技术层面的总结内容：</p>
<h3 id="前端技术栈">1. 前端技术栈</h3>
<p><strong>系统管理后台</strong>： 前端采用了 H5 技术结合
<strong>Vue.js</strong> 和 <strong>ElementUI</strong> 构建，利用 Vue.js
的组件化思想和 ElementUI
提供的丰富组件来实现管理后台的页面交互。同时，我们还使用 <strong>Apache
ECharts</strong>
进行数据可视化展示，帮助餐饮企业更好地分析运营数据。</p>
<p><strong>小程序端</strong>： 为了适应移动端用户的需求，我们使用
<strong>微信小程序</strong>
开发了消费者端应用，实现了菜品浏览、购物车管理、在线下单、支付、催单等功能。</p>
<h3 id="网关层">2. 网关层</h3>
<p><strong>Nginx</strong>： Nginx 作为 Web
服务器，承担了静态资源的托管以及反向代理和负载均衡的职责。在项目部署时，我们通过
Nginx 实现了 Tomcat
的负载均衡，提高了系统的可扩展性和高并发处理能力。</p>
<h3 id="应用层">3. 应用层</h3>
<p><strong>Spring Boot</strong>： 项目使用 <strong>Spring Boot</strong>
框架快速构建，采用了 "约定优于配置"
的开发模式，简化了配置过程，并加速了开发进程。</p>
<p><strong>Spring MVC</strong>： 我们使用 <strong>Spring MVC</strong>
来处理 Web 请求，Spring MVC
的高度模块化让我们能够方便地进行控制器管理。</p>
<p><strong>Spring Task</strong>：
为了定时执行一些任务，如发送通知等，项目集成了 <strong>Spring
Task</strong> 定时任务框架，支持定时任务调度。</p>
<p><strong>HttpClient</strong>： 用于向其他系统发送 HTTP 请求，集成了
<strong>HttpClient</strong> 库来简化网络请求的操作。</p>
<p><strong>Spring Cache</strong>： 为提高系统性能，项目使用了
<strong>Spring Cache</strong> 框架进行数据缓存，减少了数据库的负载。</p>
<p><strong>JWT</strong>： 通过 <strong>JWT (JSON Web Token)</strong>
进行用户身份验证，确保每次请求的安全性和一致性。</p>
<p><strong>阿里云 OSS</strong>： 为了方便管理用户上传的图片和文件使用了
<strong>阿里云 OSS</strong> 进行文件存储，利用 Spring Boot 自动配置集成
OSS 服务。</p>
<p><strong>Swagger</strong>： 为了提升开发和测试效率，我们使用了
<strong>Swagger</strong> 自动生成 API 文档，并且可以通过 Swagger
进行接口测试。</p>
<p><strong>POI</strong>： 项目中有涉及到 Excel
文件的导入和导出功能，使用了 <strong>POI</strong> 库来封装对 Excel
文件的常用操作。</p>
<p><strong>WebSocket</strong>： 为了实现实时消息推送，我们通过
<strong>WebSocket</strong>
实现了订单推送、催单等功能，使得用户能够即时获取订单进度。</p>
<p><strong>AOP</strong>： 项目中使用了 <strong>AOP
(面向切面编程)</strong>
技术，通过切面来处理跨越多个模块的逻辑，如日志记录、权限检查等，提升了系统的模块化和可维护性。</p>
<h3 id="数据层">4. 数据层</h3>
<p><strong>MySQL</strong>： 核心业务数据都使用 <strong>MySQL</strong>
存储，利用其关系型数据库特性来处理各种复杂的查询和数据管理需求。</p>
<p><strong>Redis</strong>： 为了解决高并发下的数据访问问题，使用
<strong>Redis</strong>
来缓存热点数据，提高了数据访问的效率。项目实现了缓存的多种策略，包括缓存穿透、缓存击穿和缓存雪崩等问题的解决方案。</p>
<p><strong>Mybatis</strong>： 项目使用 <strong>Mybatis</strong>
作为数据持久层框架，简化了 SQL
操作和对象映射，增强了代码的可读性和可维护性。</p>
<p><strong>Mybatis-Plus</strong>： 在 <strong>Mybatis</strong>
基础上，我们还引入了 <strong>Mybatis-Plus</strong> 来简化 CRUD
操作，减少了开发者的工作量。</p>
<h3 id="消息队列与异步处理">5. 消息队列与异步处理</h3>
<p><strong>RabbitMQ</strong>： 项目中有复杂的秒杀业务，我们将
<strong>RabbitMQ</strong>
作为异步消息队列，处理秒杀过程中的高并发请求，提高了系统的响应速度和吞吐量。</p>
<p><strong>Lua脚本</strong>：
为了实现秒杀的高性能操作，同时确保Redis操作的原子性，利用 Redis
的计数器功能配合 Lua 脚本实现了秒杀的快速库存扣减。</p>
<h3 id="并发控制与优化">6. 并发控制与优化</h3>
<p><strong>Redisson 互斥锁</strong>：
为了解决高并发下的资源竞争问题，项目使用了 <strong>Redisson</strong>
实现互斥锁，确保在并发场景下对共享资源（如库存）的操作是安全的，避免了出现超卖等问题。Redisson
提供的分布式锁机制极大地提升了分布式环境下的并发控制能力，确保在秒杀等高并发操作中数据的准确性和一致性。</p>
<p><strong>缓存优化</strong>：
为了解决缓存击穿、缓存穿透和缓存雪崩等问题，我们在 Redis
中采用了互斥锁来控制并发访问，确保缓存的稳定性。</p>
<h3 id="测试与工具">7. 测试与工具</h3>
<p><strong>Git</strong>： 在团队开发中，我们使用 <strong>Git</strong>
进行版本控制，确保代码的版本管理和团队协作顺畅。</p>
<p><strong>Maven</strong>： 项目采用 <strong>Maven</strong>
作为构建工具，自动化管理依赖和构建过程。</p>
<p><strong>JUnit</strong>： 通过 <strong>JUnit</strong>
进行单元测试，确保每个模块的功能正确性，提升了代码的稳定性。</p>
<p><strong>ApiFox</strong>： 在接口开发过程中，我们使用
<strong>ApiFox</strong> 进行接口调试和测试，模拟各种 HTTP 请求，确保 API
的高效与准确。</p>
<h1 id="总结">总结</h1>
<p>整体来说：<strong>后端基于 Spring Boot 构建，采用了 SpringMVC 和
Mybatis 技术栈，结合 Mybatis-Plus
提供了简洁且灵活的开发方式；此外，增加了优惠券业务，使用 Redis
分布式锁和消息队列实现分布式架构，支持高并发秒杀活动，利用RabbitMQ中间件实现消息队列。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/12/17/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%A2%9E%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%9A%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%A2%9E%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%9A%E5%8A%A1/" class="post-title-link" itemprop="url">基本框架增加优惠券业务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-16 23:04:48 / 修改时间：15:26:56" itemprop="dateCreated datePublished" datetime="2024-12-16T23:04:48Z">2024-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一秒杀业务note重点">一、秒杀业务note重点</h1>
<h2 id="i-短信登录">I 短信登录</h2>
<h3 id="redis替换session的具体细节和操作流程">1.1
Redis替换Session的具体细节和操作流程</h3>
<p>1.存储短信验证码时，key-value分别是phone和code，均为String类型（唯一性、方便携带），存储User对象时，采用hash类型（json格式数据）</p>
<p>2.存储用户数据/需要返回给前端时，用phone作key不合适，暴露隐私，在后台生成一个随机串token（利用令牌技术）设置过期时间，完成识别认证</p>
<p>3.利用UUID随机生成token，将User对象转为Map（定制 beanToMap
转换行为），将<strong>每个字段的值</strong>转换为 String
类型，存储后返回token</p>
<h3 id="状态登录刷新解决方案">1.2 状态登录刷新解决方案</h3>
<p>设置两个拦截器，第一个拦截器拦截所有路径（拦截而不处理return
true），仅用于刷新token时间，同时将前来认证/访问的User放入ThreadLocal（利用UserHolder，自定义的工具类，存放读取线程池的信息）；</p>
<p>第二个拦截器做真正的拦截功能，拦截所有需要登录才能访问的路径，随后注册配置两个拦截器，注意先执行第一个拦截器，配置order</p>
<h2 id="ii-商户查询缓存">II 商户查询缓存</h2>
<h3 id="缓存更新策略双写一致">2.1 缓存更新策略、双写一致</h3>
<p>原本的添加缓存的机制为，提交商铺id、查询缓存、命中返回商铺信息，未命中去数据库查（数据库不存在该商铺返回404）、存在该商铺写入Redis，返回商铺信息</p>
<p>内存数据有限宝贵，不可以redis插入太多数据，适当更新机制：</p>
<p><strong>内存淘汰：</strong>自动进行，redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除</p>
<p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和<strong>数据库不一致</strong>问题</p>
<p>低一致性需求：内存淘汰</p>
<p>高一致性需求：主动更新为主、超时为辅</p>
<h4 id="解决一致性问题">解决一致性问题</h4>
<p>数据库数据域发生变化后，缓存数据没有同步，产生一致性问题</p>
<p><strong>解决方式：主动更新</strong>，实现方案：</p>
<p>Cache Aside Pattern
缓存调用者在更新完数据库后去更新缓存，称之为<strong>双写方案</strong>（主要采用）</p>
<p><em>利用缓存服务：</em></p>
<p><em>Read/Write Through Pattern :
由<strong>系统本身</strong>完成，数据库与缓存的问题交由系统本身去处理，调用者无需关心一致性</em></p>
<p><em>Write Behind Caching Pattern
：调用者只操作缓存，<strong>其他线程去异步</strong>处理数据库，实现最终一致</em></p>
<h4 id="双写一致方案">双写一致方案</h4>
<p>采用双写一致方案，明确操作内容：</p>
<p>1.每次更新动作是直接删除缓存，而非更新</p>
<p>2.缓存与数据库的操作的同时成功或失败，采用一个<strong>事务</strong></p>
<p>3.先操作数据库，再删除缓存，why：</p>
<ul>
<li>方案一：两个线程并发来访问时，线程1先来，删除缓存还没来得及更新数据库；此时线程2查询缓存数据并不存在，故查询旧数据库获取旧数据写入缓存；线程1再执行更新数据库动作时，造成数据库和缓存不一致</li>
<li>方案二：当缓存失效时（时间等各原因），线程1查发现没有，查数据库旧数据，此时线程2先更新数据库改为新数据，然后删除缓存（本来就是空）相当于没删，此时线程1来写缓存，写的是旧数据（但发生的概率较小，先更新数据库）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653323595206.png" alt="1653323595206" style="zoom:50%;" /></p>
<p>住：写缓存是ums级别的，但数据库操作比写缓存时间多很多</p>
<p><strong>实现：</strong></p>
<p>查询操作：在ShopServiceImpl的queryById方法中：<strong>设置redis缓存时添加过期时间</strong></p>
<p>修改确保双写一致操作：在update方法中，<strong>先更新数据库再删除缓存</strong></p>
<h3 id="缓存穿透问题">2.2 缓存穿透问题</h3>
<p>缓存穿透是指客户端恶意请求数据在缓存中和数据库中都不存在，这些请求都会打到数据库。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>缓存空对象：访问数据库也不存在的数据时，把这个数据存入到redis中，给null，下次来访问直接返回个null
<ul>
<li>实现简单，额外内存消耗，缓存中需要存储
带TTL的null，短期不一致（后来此字段出现了）</li>
</ul></li>
<li>布隆过滤：在客户端访问到达redis前，设置布隆过滤器，哈希思想，通过一个庞大的二进制数组，判断当前这个要查询的这个数据是否存在（存在放行，不存在拒绝）
<ul>
<li>内存占用较少，没有多余key，实现复杂，误判可能</li>
</ul></li>
</ul>
<p>主动解决方案：</p>
<ul>
<li>增强id的复杂度</li>
<li>避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h4 id="缓存空对象解决">缓存空对象解决</h4>
<p>原本：发现这个数据在mysql中不存在，直接就返回404</p>
<p>现在：会把这个数据写入到Redis中，并且将value设置为""，再次查询时，判断value为null，则为之前写的空数据，直接返回；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">     <span class="comment">// 2、判断是否存在</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">         <span class="comment">// 存在,直接返回</span></span><br><span class="line">         <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//判断命中的值是否是空值，说明此时shopJson有值，但是为blank（上一步没判断出来的），是奇怪的</span></span><br><span class="line">     <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//返回一个错误信息</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">// 5.不存在，采用缓存空对象解决</span></span><br><span class="line">     <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//将空值写入redis</span></span><br><span class="line">         stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">         <span class="comment">//返回错误信息</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;		</span><br><span class="line"></span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="缓存击穿问题">2.3 缓存击穿问题</h3>
<p>缓存击穿问题也叫<strong>热点Key问题</strong>，某个被高并发访问并且缓存重建业务较复杂的key突然<strong>失效</strong>了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>线程1查询缓存，未命中，去查询数据库然后重建缓存数据（耗费时间较长），在此过程中，若干线程执行同线程1的操作，同时在访问数据库执行重建操作；</p>
<p><strong>解决方案：</strong></p>
<h4 id="互斥锁">互斥锁</h4>
<p>锁能实现互斥性，第一个查询未命中的线程在重建的时候获得锁的资源，其他之后的线程来没有锁的资源，无法访问到数据库，只能休眠等待（定期回到查询缓存步骤），直到线程1释放锁。</p>
<ul>
<li>让查询的性能从并行变成了串行，只能一个线程在操作，其他在休眠，效率低；死锁风险</li>
<li>实现简单，无额外内存消耗</li>
<li>牺牲可用性，保证一致性</li>
</ul>
<p>实现思路：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653357860001-1734362376722.png"
alt="1653357860001" />
<figcaption aria-hidden="true">1653357860001</figcaption>
</figure>
<p>核心思路：</p>
<ul>
<li>获取锁的方式：利用redis的<strong>setnx方法</strong>（redis中如果没有这个key，则插入成功，返回1/true，如果存在这个key，则插入失败）</li>
<li>利用key-"1"，setIfAbsent方法，如果存在这个资源则不会操作，成功插入key的线程认为获得了锁；删除这个key-value即代表释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line"> <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">    shop = getById(id);</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 释放互斥锁</span></span><br><span class="line">    unlock(lockKey);</span><br></pre></td></tr></table></figure>
<h4 id="逻辑过期">逻辑过期</h4>
<p>逻辑过期：为key-value不设置实际的TTL，存储他们的时候采用一个expireTime字段，每次都需要判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则当前线程直接返回过期数据，同时开启一个独立线程，独立线程去获取锁重构数据，重构完成后释放互斥锁。</p>
<ul>
<li>线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据</li>
<li>不保证一致性，有额外的内存消耗，且实现复杂</li>
<li>牺牲一致性，提高性能</li>
</ul>
<p>实现思路：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653360308731-1734362376722.png"
alt="1653360308731" />
<figcaption aria-hidden="true">1653360308731</figcaption>
</figure>
<p><strong>核心思路：</strong></p>
<p>现在redis中存储的数据的value需要带上过期时间，采用<strong>组合方式</strong>，<strong>对原来代码没有侵入性</strong>：</p>
<p>新定义一个实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>修改<strong>ShopServiceImpl</strong>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建,开启新线程获取互斥锁重建</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br></pre></td></tr></table></figure>
<h3 id="缓存雪崩问题">2.4 缓存雪崩问题</h3>
<p>缓存雪崩是指在同一时段<strong>大量的缓存key</strong>同时失效或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。(服务器本身的问题)</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值（避免TTL一起到期）</li>
<li>利用Redis集群提高服务的可用性（Redis哨兵机制）</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存（不仅在service缓存，nginx也可以缓存，数据库等）</li>
</ul>
<h3 id="封装redis工具类">2.5 封装Redis工具类</h3>
<p>泛型是 Java 中引入的一种
<strong>参数化类型</strong>，让类、接口和方法可以使用
<strong>不确定的数据类型</strong>，泛型可以实现：代码重用、类型安全、增强可读性</p>
<p>泛型通常通过 <code>&lt;T&gt;</code>、<code>&lt;R&gt;</code>
等尖括号包裹的字母表示，其中：</p>
<ul>
<li><code>T</code>：表示类型（Type）。</li>
<li><code>R</code>：表示返回类型（Return）。</li>
<li><code>ID</code>：可以表示输入的参数类型（例如 ID）</li>
</ul>
<p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</p></li>
<li><p>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题</p></li>
<li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用<strong>缓存空值的方式解决缓存穿透</strong>问题</p></li>
<li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要<strong>利用逻辑过期解决缓存击穿</strong>问题</p></li>
<li><p>方法5：根据指定的key查询缓存，并反序列化为指定类型，需要<strong>利用互斥锁解决缓存击穿</strong>问题</p></li>
</ul>
<p>将逻辑进行封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">	<span class="comment">// 设置十个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法1：设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法2：设置逻辑过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法3，利用泛型手段，不局限于Shop类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="comment">// type 用来帮助框架或工具进行对象的反序列化，即将字符串或JSON 转换为具体的对象类型R（type告诉方法：把 JSON 转换成 R 类型的对象）</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="comment">// 接受参数 ID 并返回 R 类型的函数</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法4：利用逻辑过期解决缓存击穿问题</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法5：利用互斥锁解决缓存击穿</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获得锁和释放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ShopServiceImpl
中直接调方法<code>Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</code></p>
<h2 id="iii-优惠券秒杀">III 优惠券秒杀</h2>
<h3 id="全局唯一id">3.1 全局唯一ID</h3>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p><strong>全局ID生成器</strong>：为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653363172079-1734362376722.png"
alt="1653363172079" />
<figcaption aria-hidden="true">1653363172079</figcaption>
</figure>
<p>永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.生成时间戳</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.生成序列号</span></span><br><span class="line"><span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line"><span class="comment">// 2.2.自增长</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.拼接并返回，右移后 或 count，比加效率高</span></span><br><span class="line"><span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br></pre></td></tr></table></figure>
<h3 id="秒杀下单超卖问题">3.2 秒杀下单超卖问题</h3>
<p>数据库信息：</p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等
tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>tb_order_voucher：订单表，在用户每次特价优惠券秒杀成功后，都会创建订单，在此表增加一项秒杀订单信息（订单id、用户id、代金券id）</p>
<p>秒杀下单思考：下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p><strong>超卖问题：</strong>线程1过来查询库存，判断库存大于1，正准备去扣减库存，还没扣；此时线程2也去查询库存，发现数量也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。（优惠券库存变为负数，订单表条目超过库存数量），超卖问题是典型的多线程安全问题</p>
<p><strong>解决方案就是加锁：</strong></p>
<ul>
<li><p><strong>悲观锁：</strong>认为线程安全很重要，操作数据前必须先获得锁，确保数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p></li>
<li><p><strong>乐观锁：</strong>认为线程安全问题不一定会发生，因此不直接加锁。会有一个版本号version，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1
，如果大1
，则进行操作成功（如果大了其他，或version不对应了，证明数据被修改过）。乐观锁还有一些变种的处理方式比如cas</p></li>
</ul>
<p>自旋操作（spin
lock）：如果一个线程正在尝试获取某个资源，但该资源当前被其他线程占用，它就会不断重复检查该资源的状态，直到资源可用</p>
<p>CAS（Compare-and-Swap）操作：一种常用的原子操作，主要用于解决多线程中的竞争条件，原子性保证了在多线程环境下的操作是线程安全</p>
<h4 id="乐观锁解决超卖问题">乐观锁解决超卖问题</h4>
<p>实现时，是由seckillVouncher方法的最后，若库存充足则扣减库存，调用createVoucherOrder方法</p>
<p>VoucherOrderServiceImpl
在扣减库存时，createVoucherOrder函数中扣减部分改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">// where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>
<p>以上逻辑的核心含义是：只要扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存;</p>
<p>但是以上这种方式通过测试发现会有很多失败的情况，原因：使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中<strong>只有1个人能扣减成功</strong>，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败，导致商品虽然不会超卖，但也很多没卖出去，操作失败率高。</p>
<p><strong>改成stock大于0 </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>
<h3 id="优惠券秒杀一人一单问题逐步加锁">3.3
优惠券秒杀——一人一单问题——逐步加锁</h3>
<p>现在的情况是一个人可以无限制的抢这个优惠卷（黄牛），要求同一个优惠券，一个用户只能下一单</p>
<p>实现思路：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653371854389-1734362376722.png"
alt="1653371854389" />
<figcaption aria-hidden="true">1653371854389</figcaption>
</figure>
<p>在优惠券订单实现类的createVoucherOrder方法中，增加一人一单逻辑：函数上需要增加@Transactional事务注解（查询订单、扣减库存和创建订单一致性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">   <span class="comment">// 5.1.用户id</span></span><br><span class="line">   <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">   <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">   <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 用户已经购买过了</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 订单表中不存在的用户可以购买</span></span><br><span class="line">   <span class="comment">//6.扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//7.创建订单</span></span><br><span class="line">   <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">   <span class="comment">// 7.1.订单id</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">   voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">   voucherOrder.setUserId(userId);</span><br><span class="line">   <span class="comment">// 7.3.代金券id</span></span><br><span class="line">   voucherOrder.setVoucherId(voucherId);</span><br><span class="line">   save(voucherOrder);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Result.ok(orderId);</span><br></pre></td></tr></table></figure>
<p><strong>存在问题：</strong>同一个用户id的多个线程并发过来，第一次购买，查询数据库，都不存在订单，都可以走到第六步购买；</p>
<p>针对这个问题，我们还是需要加锁，但是乐观锁比较适合更新数据(不同线程带来不同版本，解决超卖)，而现在是插入数据(不同线程同时插入)，所以我们需要使用悲观锁操作</p>
<ol type="1">
<li><p>封装了一个<code>createVoucherOrder</code>方法，在方法上增加<code>synchronized</code>锁，当前锁是this，当前对象，此方法实现查询订单，扣减库存，创建订单，返回结果</p>
<ol type="1">
<li>问题：锁的范围过大，任何用户来了都得等锁，而非是同一用户，粒度太粗了</li>
<li>在使用锁过程中，控制<strong>锁粒度</strong>
是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住</li>
</ol></li>
<li><p>加锁的时候按照用户ID来加，同一用户加一把锁，不同用户不同锁，获取到代码，然后<code>synchronized(userId.toString().intern())&#123;剩下代码&#125;</code>，toString每次都是一个全新字符串，返回字符串的规范表示：从常量池中拿到数据，只按值判断；此时在方法内部加锁</p>
<ol type="1">
<li>问题：在方法内部加锁，在执行完逻辑代码，理论上锁已经释放了，其他线程可以进来，但是又有@transactional事务逻辑，若未提交事务时，其他线程面对的数据库还是之前的，仍然可以进来，产生订单安全问题</li>
<li>事务没提交而锁已经释放</li>
</ol></li>
<li><p>故应该加在整个函数的外面，锁住整个函数：在<code>seckillVoucher</code>方法中，添加以下逻辑，先获取ID，然后锁住要返回的函数（创建订单），函数执行完，事务一定已经提交，数据库已经更新，释放的锁才能被其他进程正确使用。保证事务特效同时也控制了锁的粒度；</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373434815-1734362376722.png"
alt="1653373434815" />
<figcaption aria-hidden="true">1653373434815</figcaption>
</figure>
<p>问题：调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效</p></li>
<li><p>Spring事务失效：事务是创建一个代理对象，对代理对象事务一致性操作；但是this.的方式调用的是非代理对象，目标对象；</p>
<ol type="1">
<li><p>需要拿到代理对象：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653383810643-1734362376722.png"
alt="1653383810643" />
<figcaption aria-hidden="true">1653383810643</figcaption>
</figure></li>
</ol></li>
<li><p>需要引入asproxy依赖，加@Enable...注解设置为true才能生效</p>
<p>​ <strong>还需要去掉sekillVouncher方法上面的注解</strong></p></li>
</ol>
<h3 id="分布式集群环境的并发问题">3.4 分布式集群环境的并发问题</h3>
<p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373887844-1734362376722.png"
alt="1653373887844" />
<figcaption aria-hidden="true">1653373887844</figcaption>
</figure>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653373908620-1734362376722.png"
alt="1653373908620" />
<figcaption aria-hidden="true">1653373908620</figcaption>
</figure>
<p><strong>有关锁失效原因分析</strong></p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，同一JVM内部锁维护锁监视器对象(user_id)，利用同一常量池的id是可以实现互斥，但此时服务器JVM不一样时，又有两个线程但是却不是同一个锁监视器，故线程1和线程3就可以是同一个用户</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653374044740-1734362376722.png"
alt="1653374044740" />
<figcaption aria-hidden="true">1653374044740</figcaption>
</figure>
<p>故要使用跨集群的锁——<strong>分布式锁</strong></p>
<h3 id="分布式锁simplelock自己实现">3.5
分布式锁——simpleLock(自己实现)</h3>
<p>分布式锁需要满足：<strong>多进程可见、互斥</strong>、高可用、高并发（高性能）、安全性</p>
<p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且互斥的锁，原本一个JVM一个锁监视器，现在统一用一个锁监视器了</p>
<p><strong>常见分布式锁：</strong></p>
<p>Mysql：本身互斥锁机制，性能一般；Redis：常见方式，<strong>setnx</strong>方法，插入Key成功则成功获得锁，后续的人无法成功插入这个数据；Zookeeper：利用节点有序性和唯一性实现互斥</p>
<p><strong>Redis实现：</strong></p>
<p>获取锁：互斥（一次只能一个获取）、非阻塞（尝试一次、成功true，失败false，无法再重试）</p>
<p>释放锁：手动释放、超时释放（超时时间）</p>
<h4 id="核心思路与基本实现">3.5.1 核心思路与基本实现</h4>
<p><strong>setNx
方法：</strong>有多个线程进入时，第一个线程进入时，setnx key
value，其中key是携带用户id信息的，可以创建成功，即获取了锁，返回1，去执行业务，后删除锁delete
key实现退出锁逻辑；其他线程无法再设置这个key，执行返回0，需要等待一定时间后重试setnx。</p>
<ul>
<li><strong>加锁逻辑</strong></li>
</ul>
<p>utils下增加：<strong>接口：ILock</strong></p>
<p>实现两个方法<code>boolean tryLock(传入锁持有时间，过期自动释放)</code>和<code>void unlock()</code></p>
<p>utils下增加：<strong>SimpleRedisLock实现ILock</strong></p>
<p>有参构造，传入name和redistemplate实例化对象，</p>
<p>tryLock：获取线程标识，利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性（setnx
expire 一起执行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>释放锁逻辑：</strong></li>
</ul>
<p>直接删除<code>stringRedisTemplate.delete(KEY_PREFIX + name);</code></p>
<ul>
<li>设计完工具方法后，修改vouncherOrderService实现类的<strong>seckillVoncher</strong>方法：</li>
</ul>
<p>在发现库存充足后，此时不需要在<code>proxy.createVoucherOrder</code>外部利用synchronized上锁了（用分布式锁了，更高级，不需要刚才实现的防止一人一单的方法了）<strong>但是：</strong>分布式锁确保了同一时间只有一个用户能执行
<code>createVoucherOrder</code>
方法，而事务管理确保了方法执行过程中的一致性和原子性，所以此时仍需要代理对象</p>
<p>在判断库存后面上锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">// 创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">// 获取锁对象，加锁1200秒</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">// 加锁失败：证明同一用户正在下单了</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)：执行查询订单、扣减库存、创建订单</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="误删问题">3.5.2 误删问题</h4>
<p><strong>问题</strong>：我们设置了锁的自动过期时间，若持有锁的线程1在锁的内部出现了阻塞，导致他的锁自动释放，被其他线程获取；但线程1本身并不知晓，阻塞结束后继续执行本身逻辑，完成逻辑后删除锁（释放锁），此时删除的是属于线程2刚才获取的锁，这就是误删别人锁的情况；</p>
<p><strong>解决方案：</strong>每个线程释放锁的时候，去判断一下当前这把锁<strong>是否属于自己</strong>，属于自己则可以释放，是属于自己，证明已经被释放了，此时不删除锁。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653385920025-1734362376722.png"
alt="1653385920025" />
<figcaption aria-hidden="true">1653385920025</figcaption>
</figure>
<p><strong>实现方案：</strong>集群的模式下，直接利用threadID，不同JVM可能相同，因此在获取锁时存入线程标示（可以用该线程UUID
+ 线程ID），此时再拼接同一JVM的不同线程ID</p>
<p>UUID：全局唯一的标识符，区分不同的 JVM 实例</p>
<p>修改tryLock和unLock代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前JVM的唯一标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原子性问题lua脚本">3.5.3 原子性问题——Lua脚本</h4>
<p><strong>误删问题2：</strong>阻塞发生在线程判断标识一致和释放锁之间：线程1持有锁后执行业务逻辑，结束后他准备删除锁，此时发生阻塞，线程1锁在阻塞过程中到期已经自动释放。此时线程2进来，线程1阻塞完后会删除当前线程2获取的锁（因为他刚刚判断了锁是自己的，但是没来得及删），这就是删锁时的原子性问题。</p>
<p><strong>本质</strong>：线程1的拿锁，比锁，删锁，并不是原子性</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653387764938-1734362376722.png"
alt="1653387764938" />
<figcaption aria-hidden="true">1653387764938</figcaption>
</figure>
<p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的<strong>原子性</strong>。</p>
<p>重点介绍Lua脚本中Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>
<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<p>写好脚本以后，需要用Redis命令来调用脚本</p>
<p>脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653392438917-1734362376722.png"
alt="1653392438917" />
<figcaption aria-hidden="true">1653392438917</figcaption>
</figure>
<p>之前释放锁的业务流程是这样的：</p>
<p>1.获取锁的唯一线程标识</p>
<p>2.比较是否和当前线程标识一致</p>
<p>3.一致则删除；不一致则直接over</p>
<p><strong>Lua脚本实现：</strong></p>
<p>线程标识是key-value中的value即UUID+线程标识，key是userID</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="comment">-- 利用redis.call(&#x27;GET&#x27;, KEYS[1])先取Key（拼接lock:(order:userId传入)）对应的value（锁的线程标识），与当前线程标识比较</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>在Java代码中调用Lua脚本</strong>：</p>
<p>RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653393304844-1734362376722.png"
alt="1653393304844" />
<figcaption aria-hidden="true">1653393304844</figcaption>
</figure>
<p><strong>Java代码</strong></p>
<p><code>static</code> 的作用是确保指示 Lua 脚本
的变量<code>UNLOCK_SCRIPT</code> 只被加载和初始化一次</p>
<p><strong>静态代码块</strong>，它会在
<strong>类加载时自动执行</strong>，且只执行一次。它用于初始化静态变量
<code>UNLOCK_SCRIPT</code>，在静态代码块中被初始化为一个新的
<code>DefaultRedisScript</code> 对象，并且设置了 Lua
脚本的路径（<code>unlock.lua</code>）以及脚本的执行结果类型（<code>Long.class</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UNLOCK_SCRIPT是一个静态变量，它被声明为 static，它属于类本身，而不是类的实例，无论你创建多少个该类的实例，UNLOCK_SCRIPT 始终只有一个实例，UNLOCK_SCRIPT 只在类加载时初始化一次，且所有实例共享同一个对象，避免了重复的初始化操作（节省资源）</span></span><br><span class="line"><span class="comment">// final 关键字保证了 UNLOCK_SCRIPT 一旦被赋值就无法再改变它指向的对象。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁的时候判断和删除一起做</span></span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name), <span class="comment">//（脚本中的参数KEYS[1]）</span></span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId()); <span class="comment">// （脚本中的参数ARGV[1]）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>：添加过期时间，防止死锁问题的发生，但可能出现到期以后误删别人锁的问题，开始是利用删之前对比锁标识和自己标识，但可能出现原子性问题也会误删，通过lua表达式来解决这个问题。</p>
<p><strong>基于setnx分布式锁实现存在问题：</strong></p>
<p><strong>重入问题</strong>：获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，如A方法获得锁，调用B方法，而B方法也需要锁，则B在等待A释放，A调用的B未执行A没法释放，此时发生死锁；synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：目前的分布式中只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，自己锁已经释放，存在安全问题；利用redission也可以实现到期续约，不会误删别人的锁；</p>
<p><strong>主从一致性：</strong>
如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653546070602.png" alt="1653546070602" style="zoom: 38%;" /></p>
<h3 id="分布式锁redisson">3.6 分布式锁——redisson</h3>
<h4 id="redisson介绍与应用">3.6.1 Redisson介绍与应用</h4>
<p>Redisson在Redis的基础上实现的Java驻内存数据网格（In-Memory Data
Grid），是一个 <strong>Java Redis 客户端</strong>，它封装了 Redis
的基本操作，并且提供了许多高层次的抽象。Redisson 的目标是简化与 Redis
的交互，同时提供一些高级功能，如分布式锁、分布式集合、分布式缓存。简言之：Redis的儿子（增强版），更高级，交互更方便</p>
<p>引入依赖，注册配置客户端</p>
<p><strong>使用案例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span> <span class="comment">// 引入Redisson客户端实例</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 VoucherOrderServiceImpl注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="comment">// 在seckillVoucher函数块中部分核心代码：</span></span><br><span class="line"> <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 创建锁对象 下面代码不用了，因为我们现在要使用Redisson提供的锁，不用自己创建的simple锁了</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId); <span class="comment">// 锁的名称即key</span></span><br><span class="line">        <span class="comment">// 获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>利用以上RedissonClient提供的锁我们即可实现Reddision锁，解决上述的四个问题，下面我们剖析一下Reddisson实现这些功能的原理</p>
<h4 id="reddisson可重入可重试超时释放原理">3.6.2
Reddisson可重入、可重试、超时释放原理</h4>
<p>** 可重入**</p>
<p>Lock锁中，借助于底层的一个voaltile（关键字，修饰变量确保该变量的值对所有线程可见的）的一个state变量来记录重入的状态的，无人拥有此锁state
= 0，每有一个人拥有state +
1；对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，直到减少成0
时，表示当前这把锁没有被人持有；</p>
<p>在redission中，支持可重入锁：采用hash结构用来存储锁，其中key表示这把锁是否存在，field表示当前这把锁被哪个线程持有（线程标识）,value代表重入次数。分析源码：trylock调用tryLockAsync，返回
tryAcquireOnceAsync，函数中调用tryLockInnerAsync，其中存在lua表达式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"> <span class="string">&quot;end; &quot;</span> +</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]： 锁失效时间</strong></p>
<p><strong>ARGV[2]： id + ":" + threadId;
锁的小key，标识当前锁的被哪个线程持有</strong></p>
<ul>
<li><p>首先进行判断：exists 判断Redis数据库中是否存在
name：如果==0，就表示当前这把锁不存在，可以获取锁：</p>
<p><code>redis.call('hset', KEYS[1], ARGV[2], 1)</code>;此时他就开始往redis里边去写数据
，hash结构，锁名称通常是用户ID(KEYS[1])-线程标识符或
UUID（ARGV[2]），数字1代表当前线程已经获得锁；<code>pexpire</code>
命令为锁设置一个过期时间，单位是毫秒最后返回nil；</p></li>
<li><p>如果这把锁已经存在，<code>hexists</code>
命令检查这把锁是否是属于自己，即对比当前线程标识符ID和锁的标识符（key对应的value），如果是自己的，<code>hincrby</code>将当前这个锁的value进行+1
，然后再对其设置过期时间<code>redis.call('pexpire', KEYS[1], ARGV[1])</code>;返回nil</p></li>
<li><p>如果以上两个条件都不满足，即当前锁已被其他线程或进程占用且无法重入，脚本返回当前锁的剩余有效时间（<code>pttl</code>
命令返回的是锁的过期时间，单位毫秒；</p></li>
</ul>
<p>整体：<strong>加锁（无人获取）</strong>、<strong>重入锁（同一线程已经获取了锁，可以就行获取，重入增加次数，延长过期时间）</strong>、<strong>锁的过期（持锁线程在过期时间内没有释放锁，其他线程可以重新获取该锁。）</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653548087334-1734362376722.png"
alt="1653548087334" />
<figcaption aria-hidden="true">1653548087334</figcaption>
</figure>
<p>** 可重试**</p>
<p>** 实现思路：**</p>
<ul>
<li><strong>获取锁：</strong></li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241210123703596-1734362376722.png"
alt="image-20241210123703596" />
<figcaption aria-hidden="true">image-20241210123703596</figcaption>
</figure>
<p>ttl表示获取已有锁的过期时间，null表示当前没有已存在的锁，即可以成功获取锁；否则判断剩余等待时间，如果等待时间小于0了，则证明已经不需要等了，直接返回；如果大于0（证明还需要接着等），此时利用Lock的Pubsub订阅锁并等待释放，定期判断等待时间若超时则取消订阅并返回false，否则尝试获取；</p>
<p>leaseTime是释放时间（有效期），如果过了有效期，则可以重新获取锁，返回true；</p>
<p>如果在有效期内，则开启看门狗机制，watchDog不停更新锁的有效期</p>
<ul>
<li><strong>释放锁</strong>：</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241210123803989-1734362376723.png"
alt="image-20241210123803989" />
<figcaption aria-hidden="true">image-20241210123803989</figcaption>
</figure>
<p>unlock相对简单很多，执行释放脚本，释放成功发送释放消息publish，取消watchDog任务</p>
<p>** 超时释放**</p>
<p>renewExpiration此逻辑就是续约逻辑</p>
<p>分析lock()方法的源码解析</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>3、锁存在且不是这个线程，开始抢锁（尝试获取锁），即上面的执行流程图；</p>
<p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕；但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，此时有个while(
true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数则leaseTime是他本身，一个是不带参数默认传入leaseTime
= -1；leaseTime时间内都会去抢锁，抢锁过程的逻辑与之前相同。</p>
<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间
commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p><strong>ttlRemainingFuture.onComplete((ttlRemaining, e)</strong>
这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程，续约逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>
<p>commandExecutor.getConnectionManager().newTimeout（）方法：Method(
<strong>new</strong> TimerTask() {},参数2 ，参数3 )</p>
<p>通过参数2，参数3
去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask
就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mutilock应用">3.6.3 MutiLock应用</h4>
<p>利用redission锁可以实现上述的功能，但无法实现<strong>主从一致性</strong></p>
<p>Redis集群中，主节点：存数据；从节点：读数据。主从同步时，数据会有一定延时，如主节点获取锁，写在主节点的数据还没来得及写从节点上，此时主机宕机，哨兵发现，选举一个slave变成<strong>新的master</strong>，而此时新的master中实际上<strong>并没有锁信息</strong>，此时锁信息就已经丢掉了，其他线程可以获得锁了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553998403.png" alt="1653553998403" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>redission提出来了MutiLock锁，使用这把锁每个节点地位一致，<strong>加锁的逻辑需要写入到每一个主丛节点上</strong>，只有所有的服务器都写入成功，此时才是加锁成功；若一个节点挂了，其他乘虚而入的进程获得锁的时候，只要有一个节点的拿不到，就不算加锁成功。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653554055048-1734362376723.png"
alt="1653554055048" />
<figcaption aria-hidden="true">1653554055048</figcaption>
</figure>
<p><strong>MultiLock加锁原理：</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653553093967-1734362376723.png"
alt="1653553093967" />
<figcaption aria-hidden="true">1653553093967</figcaption>
</figure>
<p>设置多个锁的时候，redisson将多个锁加入一个集合中，（在总的加锁时间内，这个时间是用需要加锁的个数
* 1500ms）并且while循环不断尝试拿锁，假设这时间内，所有的锁都加锁成功，
那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试。</p>
<p><strong>测试：</strong>test类中配置RedisClient中若干个主从节点redisClient1/2/3，给他们获取对应的lock1/2/3，创建multiLock，<code>lock  = redissonClient1/2/3.getMultiLock(lock1,lock2,lock3)</code></p>
<h4 id="小结redis解决四个问题">小结：Redis解决四个问题</h4>
<ol type="1">
<li><strong>可重入问题：</strong>同一线程(不同函数)可以调用自己的锁，获取锁：利用hash结构记录线程标识和重入次数；释放：每释放一次，重入-1，减为0，真正释放锁</li>
<li><strong>锁失败重试问题</strong>：失败后可以重试获取，而不是直接false，利用信号量和pubsub订阅（发布-订阅模式）功能实现等待、唤醒、获取锁失败的重试机制，也非无限制重试，有等待时间；</li>
<li><strong>锁超时释放（续约）问题：</strong>利用watchDog，开启定时任务，每隔一段时间重新配置expire，重置超时时间</li>
<li><strong>主从一致性问题：</strong>利用multipleLock，分布式锁实现</li>
</ol>
<p>此时我们便利用Redis解决四个问题<strong>：可重入问题、可重试、超时释放、主从一致性</strong>；至此，项目秒杀优惠券业务完成一人一单的优化，但是性能还可以做一定的优化</p>
<h2 id="iv-秒杀优化">IV 秒杀优化</h2>
<p>回顾一下购买优惠券下单流程：</p>
<p>用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：</p>
<p>1、查询优惠卷</p>
<p>2、判断秒杀<strong>库存是否足够</strong></p>
<p>3、查询订单</p>
<p>4、校验是否是<strong>一人一单</strong></p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>其中，查询优惠券、查询订单、扣减库存和创建订单都是对数据库的直接操作，且在一个线程内串行执行，效率较低；需要异步执行加速</p>
<h3 id="异步秒杀">4.1 异步秒杀</h3>
<h4 id="思路">4.1.1 思路</h4>
<ol type="1">
<li>将耗时比较短的逻辑判断放入到redis中，判断是否库存足够及一人一单，快速的逻辑判断后，将下单信息存入消息队列，然后直接给用户返回成功；</li>
<li>再在后台开一个线程，后台线程从队列取出下单信息，去执行和数据库相关逻辑；</li>
</ol>
<p><strong>两大问题：</strong></p>
<ul>
<li>redis中去快速库存判断和校验一人一单</li>
<li>由于校验和tomct下单是两个线程，如何知道到底是哪个单，以及最后是否成功</li>
</ul>
<p><strong>解决方案</strong>：库存判断利用key-value中的value，一人一单通过set集合区分该用户是否下过单；在redis操作完之后，我们会将一些信息（订单id）返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653561657295-1734362376723.png"
alt="1653561657295" />
<figcaption aria-hidden="true">1653561657295</figcaption>
</figure>
<p><strong>整体：</strong>用户下单-&gt;判断库存充足（不足结束）-&gt;
校验一人一单（不是结束）-&gt;
完成下单，扣除Redis库存，此后将用户id和优惠卷信息存入到redis（Lua
脚本实现原子性库存充足和校验需要原子性操作，否则超卖和重复下单）-&gt;
对Redis操作完毕返回值（0代表成功，1代表超卖，-1代表重复下单）-&gt;
成功即将刚才存入的信息放入queue，利用新线程异步下单</p>
<p>前端可以通过返回的订单id来判断是否下单成功，整体流程类似于饭店接单，服务员先接单给个小票（告诉顾客已经完成），同时告诉厨师可以炒了，厨师异步操作</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653562234886-1734362376723.png"
alt="1653562234886" />
<figcaption aria-hidden="true">1653562234886</figcaption>
</figure>
<h4 id="redis实现资格判断">4.1.2 Redis实现资格判断</h4>
<p>实现资格判断时，核心在于：管理端保存优惠券到Redis，用户端下单的时候基于Lua脚本判断库存容量和一人一单、成功下单后将优惠券id和用户id封装后存入阻塞队列、开启线程任务不断从阻塞队列中获取信息实现异步下单，共四步任务，<strong>实现代码</strong>如下：</p>
<p>用户购买进入Vounchercontroller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管理端增加优惠卷的时候，调用VoucherService接口，实现类VoucherServiceImpl中，<strong>实现保存优惠券到Redis</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户端下单购买优惠券的时候，会进入VouncherOrdercontroller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> voucherOrderService.seckillVoucher(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入优惠券ID，在VoucherOrderServiceImpl中，我们实现第二步：<strong>基于Lua脚本判断库存容量和一人一单</strong></p>
<p>再次修改seckillVouncher代码：此时创建订单和判断是否下单成功是异步操作，Redis
操作和库存更新、订单创建是分离的，<code>createVoucherOrder</code>
方法已经独立，不依赖代理对象的事务支持或锁逻辑；故</p>
<ol type="1">
<li><code>createVouncher</code>方法不需要再通过代理对象调用，去掉proxy</li>
<li>此外，现在去掉了@Transactional，将分布式锁直接加在了<code>createVouncher</code>上，通过
Redis 校验和分布式锁减少了对事务的依赖</li>
</ol>
<p>其实在Redis中我们已经判断一人一单和超卖问题了，因而无需在此时加锁再次判断，但为了以防万一，代码健壮性~，再次加锁再次判断一遍超卖和；</p>
<p>修改代码后，seckillVouncher仅用来对接用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建1024*1024的阻塞队列，ArrayBlockingQueue 是 Java 中的一个阻塞队列实现，基于 数组 实现</span></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 2.2.为0 ，有购买资格，把下单信息保存到阻塞队列</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的Lua脚本实现判断库存容量和一人一单：</p>
<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>seckill执行完以后，若可以创建订单，则开启另一个线程调用createVouncherOrder用来实现真正创建订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">        log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步下单：判断有没有资格，执行业务加各种锁，业务执行完耗时较久</p>
<p>异步下单：业务分成两部分，一部分是Redis进行抢购资格的判断（如果有资格，则立即下单成功）；耗时较久的下单部分（操作数据库）异步完成，放入阻塞队列</p>
<p>故接下来利用阻塞队列实现异步下单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    createVouncherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程池（<code>SECKILL_ORDER_EXECUTOR</code>）</strong>：</p>
<ul>
<li>创建了一个单线程的线程池（<code>Executors.newSingleThreadExecutor()</code>），用于异步处理订单。</li>
<li><code>orderTasks</code> 是一个阻塞队列，用于存储待处理的订单</li>
<li>利用 <code>@PostConstruct</code> 注解，在 Spring
容器初始化该类后便会执行init方法， 调用submit方法将
<code>VoucherOrderHandler</code> 任务提交到线程池</li>
<li><strong><code>VoucherOrderHandler</code> 任务的核心逻辑：</strong>
<ul>
<li><code>while (true)</code>：保证线程池中的线程
<strong>持续运行</strong>，不停从队列中获取订单进行处理。</li>
<li><code>orderTasks.take()</code>：
<ul>
<li>这是从阻塞队列中获取订单的逻辑，如果队列为空，<code>take()</code>
方法会阻塞线程，直到队列中有新的订单加入（实现高效的任务调度）。</li>
</ul></li>
<li><strong><code>createVoucherOrder(voucherOrder)</code>：</strong>取到订单后，调用
<code>createVoucherOrder</code> 方法完成实际的订单创建操作。</li>
</ul></li>
</ul>
<h3 id="redis消息队列">4.2 Redis消息队列</h3>
<h4 id="消息队列三种类型介绍">4.2.1 消息队列三种类型介绍</h4>
<p>消息队列是JVM以外独立服务，解决内存问题；存入磁盘，且需要消费者确认，不然一直投递到消费者。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653574849336-1734362376723.png"
alt="1653574849336" />
<figcaption aria-hidden="true">1653574849336</figcaption>
</figure>
<p><strong>基于List结构模拟消息队列</strong>：Redis的list数据结构是一个双向链表，很容易模拟出队列效果</p>
<p>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限，基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失（从队列中取走未消费，想去再取发现没了）</li>
<li>只支持单消费者</li>
</ul>
<p><strong>基于PubSub的消息队列</strong>：PubSub（发布订阅）是Redis2.0版本引入的消息传递模型，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化（更像是一个通道，未被订阅则消失）</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失（不在内存保存，数据在消费者有个缓存区域，做处理，处理较慢时空间超过则丢失）</li>
</ul>
<p><strong>基于Stream的消息队列</strong>：Redis 5.0
引入的一种新数据类型，可以实现一个功能非常完善的消息队列</p>
<h4 id="基于stream的消息队列实现">4.2.2 基于Stream的消息队列实现</h4>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li><strong>有消息漏读的风险</strong></li>
</ul>
<p><strong>漏读</strong>：如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p><strong>解决方案：</strong>利用消费者组</p>
<p>消费者组（Consumer
Group）：将多个消费者划分到一个组中，监听同一个队列；可以进行<strong>消息分流</strong>，队列中的消息会分流给组内的不同消费者（组内消费者竞争）、<strong>消息标识</strong>，消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费、<strong>消息确认</strong>，消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。</p>
<p>创建消费者组： <img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653577984924-1734362376723.png"
alt="1653577984924" /> key：队列名称 groupName：消费者组名称
ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息
MKSTREAM：队列不存在时自动创建队列</p>
<p><strong>小结：</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1653578560691-1734362376723.png"
alt="1653578560691" />
<figcaption aria-hidden="true">1653578560691</figcaption>
</figure>
<p>修改lua表达式,新增3.6
，将消息发送到队列中，队列名称为stream.orders</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/1656082824939-1734362376723.png"
alt="1656082824939" />
<figcaption aria-hidden="true">1656082824939</figcaption>
</figure>
<p>修改VouncherOrderServiceImpl代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中
handlePendingList即用来处理异常订单，即没有被ACK标记已经处理的订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们对于优惠券秒杀业务已经全部完成！下面是利用一些现成的mq，比如（kafka，<strong>rabbitmq</strong>）来实现消息队列，见五、RabbitMQ篇</p>
<h1 id="二新增业务数据库准备">二、新增业务数据库准备</h1>
<p>涉及到优惠券秒杀业务的数据库有：</p>
<p>管理端表 employee ：已经存在，<strong>实现增删优惠券</strong></p>
<p>用户表 user: 已经存在，<strong>实现抢购秒杀优惠券</strong></p>
<p>优惠券表voucher包括：优惠券标题、副标题、使用规则、支付金额、抵扣金额、劵类型、优惠券状态、创建时间和更新时间，<strong>实现记录优惠券信息</strong></p>
<p>优惠券订单表voucher_order包括：下单用户的ID、购买优惠券ID、支付方式、订单状态、下单时间、支付时间、核销时间、退款时间、更新时间，<strong>实现记录用户抢购的优惠券订单，普通券没库存</strong></p>
<p>秒杀券表voucher_seckill包括：关联的优惠券ID（主键）、库存、创建时间、生效时间、失效时间、更新时间、外键关联秒杀优惠券表，与优惠券是一对一关系</p>
<h2 id="接口设计和实体类设计">接口设计和实体类设计</h2>
<p>管理端操作优惠券：实现如下功能</p>
<p>路径：<code>http://localhost:8080/admin/voucher</code></p>
<ol type="1">
<li>添加普通券：路径不变、POST方式（传入VoucherDTO对象）、返回优惠券ID</li>
<li>添加秒杀券：路径：<code>/seckill</code>、Post方式（传入VoucherDTO对象，其中额外包括秒杀属性）、返回优惠券ID</li>
<li>分页查询优惠券列表：路径：<code>/list</code>、Get方式（传入VoucherPageQueryDTO），返回VoucherVO对象（包含voucher中部分属性：优惠券标题、副标题、使用规则、支付金额、抵扣金额、劵类型、优惠券状态）</li>
<li>下架优惠券，路径：<code>/delete/&#123;id&#125;</code>、DELETE方式，返回无，直接按照id删除对应优惠券</li>
</ol>
<p>实体类：</p>
<p>public class Voucher :包含属性同数据库属性</p>
<p>public class VouncherSeckill：仅含秒杀券的属性</p>
<p>public class VouncherDTO：普通券表 +
秒杀券表的额外属性，去掉创建和更新时间</p>
<p>客户端：</p>
<p>查询优惠券，路径同前面</p>
<p>购买优惠券：路径<code>http://localhost:8080/user/voucher/&#123;id&#125;</code>、POST请求路径参数传入购买的用户券ID、返回购买的优惠券ID或购买失败信息；</p>
<p>public class VouncherOrder：与订单表对应</p>
<h2 id="代码框架与实现思路">代码框架与实现思路</h2>
<p>管理端（小）：</p>
<p>controller层做接受信息，调用voucherService实现业务逻辑，在service中调用mapper实现数据库操作</p>
<ul>
<li><p>添加普通券：利用MybatisPlus在Service中直接实现save（）</p></li>
<li><p>添加秒杀券：调用service实现类，先利用mp添加优惠券，再保存秒杀信息，利用mp添加秒杀券</p></li>
<li><p>查询优惠券订单：调用service的Query方法，利用mp自定义实体类实现</p></li>
</ul>
<p>分页查询，利用插件设置分页参数，自动加入Limit语句（创建一个
<code>Page</code> 对象，这个 <code>Page</code> 对象用于 MyBatis Plus
的分页查询，它会自动计算 SQL 查询的分页偏移量
<code>LIMIT</code>），同时传入<code>wrapper</code>设置查询条件（注意if条件判断，如果没有就不加这个查询条件），返回<code>Page&lt;Voucher&gt;</code>
对象，它包含了查询结果和分页信息，再转换为voucherVO传给前端</p>
<p>传给前端时需要：new 一个PageResult对象</p>
<p><code>page.getTotal()</code>：获取分页结果的总记录数。</p>
<p><code>page.getRecords()</code>：获取分页后的数据记录（即
<code>VoucherVO</code> 对象的列表）。</p>
<ul>
<li>删除优惠券：通过路径参数传入删除的券ID，判断券是否是秒杀券类型，如果是还要删除秒杀券表中的信息；</li>
</ul>
<p>客户端（大）：</p>
<p>实现查询优惠券，分页查询，用redis实现，解决缓存击穿/穿透问题</p>
<p>购买时按照note中的逻辑实现：</p>
<p>建立User的Controller，Service，重点是serviceImpl</p>
<p>主要流程：</p>
<p>本质上是用户下单，减少库存，创建订单表</p>
<p>1.乐观锁解决超卖问题</p>
<p>2.redisson分布式锁解决集群模式下一人一单问题</p>
<p>3.秒杀优化中实现异步秒杀（Redis解决前面两个问题，多线程消息队列对接数据库操作）</p>
<p>实现思路（逻辑）：</p>
<p>Controller传入下单ID，orderService调用下单方法</p>
<p>下单方法实现：</p>
<ol type="1">
<li>创建订单全局唯一ID</li>
<li>执行lua脚本，全程在redis实现：判断库存是否充足（解决超卖）、判断用户是否下单（一人一单）、扣库存，下单（保存用户ID到redis），发送下单消息到消息队列</li>
<li>返回Lua脚本执行结果（1库存不足，2不能重复下单，0成功），成功直接返回订单全局唯一ID（返回给用户认为已经下单）</li>
</ol>
<p>异步下单：</p>
<ul>
<li>在下单方法的所在类初始化完成即会创建一个单线程的线程池，提交任务；</li>
<li>新定义任务类，不断地从消息队列取订单消息（利用GROUP），如果为null(没有消息时)，继续下一次循环；取到消息后解析数据，调用创建订单函数创建订单，发送ACK确认消息，代表取到消息了；一旦发送堵塞等某些异常消息，有未确认消息线程进入
Pending List，系统定期处理（与上面的一样的处理方式）</li>
<li>在创建订单部分，再次加锁（双重保证一人一单问题）</li>
</ul>
<p>实现了一个基于 Redis 和 Spring 的高性能秒杀系统，采用 Redis 的
<strong>Lua
脚本</strong>进行秒杀资格的快速校验，包括库存扣减和防止重复下单，同时将秒杀成功的订单数据写入
Redis <strong>Stream 队列</strong>。后台通过线程池异步监听队列，从
Stream 中消费订单数据并创建订单，保证主线程的响应速度。订单创建中使用
<strong>分布式锁</strong>（Redisson
实现）确保同一用户不会重复下单，并安全扣减库存。系统还实现了异常处理机制，通过
Pending List
确保未确认的订单消息不会丢失，从而实现了高并发场景下的订单创建、一人一单、库存安全以及消息可靠性保障的完整流程。</p>
<h3 id="秒杀总结流程图">秒杀总结流程图</h3>
<p>前置：1. 生成全局唯一ID 2.编写Lua脚本内容 3.创建常量，以及线程池</p>
<ol type="1">
<li>用户发起秒杀请求 → 执行 Redis Lua 脚本：
<ul>
<li>库存扣减，创建订单到消息队列</li>
<li>数据写入 Redis Stream 队列。</li>
</ul></li>
<li>后台线程不断监听 Redis Stream：
<ul>
<li>读取订单消息 → 解析数据 → 执行订单逻辑 → 确认消息。</li>
</ul></li>
<li>异常处理机制：
<ul>
<li>未确认消息进入 Pending List，系统定期处理。</li>
</ul></li>
</ol>
<h1 id="三实现过程中遇到的qa">三、实现过程中遇到的Q&amp;A</h1>
<ol type="1">
<li>mapper中方法对应的xml映射文件报错</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241213182608385.png"
alt="image-20241213182608385" />
<figcaption aria-hidden="true">image-20241213182608385</figcaption>
</figure>
<p>在升级为mp后，xml映射文件中的parameterType和resultType报错，传统的
MyBatis 配置中，如果 <code>parameterType</code> 和
<code>resultType</code> 中只写类名，MyBatis 会假定你的类在
<code>typeAliasesPackage</code> 配置中定义的包路径下；在 MyBatis-Plus
中，通常鼓励开发者使用注解而不是 XML 映射。MyBatis-Plus
并不会自动假设类的路径，因为它简化了传统的 XML
映射配置，所以现在需要加上全部路径的类名</p>
<p>2.请求路径正确，代码正确，如果发送没有反应，就检查@Requestbody是否添加（json格式数据接收时），如果也没问题，检查实体类和发送的json数据是否有不一样的地方，大多是类型不一样的时候（如BigDecimal需要带小数），测试的数据必须一点点排查</p>
<p>3.在批量删除时，也想利用save方法直接实现类似新增的一样，直接构建wrapper条件，不去调用其他的service/mapper，但是报错：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241214171044538.png"
alt="image-20241214171044538" />
<figcaption aria-hidden="true">image-20241214171044538</figcaption>
</figure>
<p>只能调用相对应的mapper进行，如果用Db去实现就会报错，db无法找到实体类对应的数据库表</p>
<p>4.分页查询mp版本与jsql不兼容，手动再引入</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241214174058272.png"
alt="image-20241214174058272" />
<figcaption aria-hidden="true">image-20241214174058272</figcaption>
</figure>
<p>JSqlParser 在 MyBatis-Plus
分页中的作用：分页操作中，<code>JSqlParser</code> 是由 MyBatis-Plus 的
<code>PaginationInnerInterceptor</code> 使用的，它的主要作用是
<strong>解析原始 SQL 并在其基础上自动添加分页逻辑</strong>。</p>
<p>5.设置用户端查询时，利用cacheclient的quryByID函数进行查询，改装函数，改进：1.缓存穿透和缓存击穿同时实现
2.解决第一次查询为null的问题</p>
<p>在缓存击穿的逻辑上增加穿透的实现，利用互斥锁，获得锁的线程去重建缓存数据，其开启一个新线程去重建数据，可以最多等待0.5秒获取新数据，其他没获得锁的线程返回旧的信息</p>
<p>6.TODO：当前缓存查询只能通过ID查询缓存并解决缓存击穿，不能通过其他属性类，且是按照ID，没法返回List（不确定）</p>
<p>7.添加优惠券到数据库的时候，会添加秒杀券到redis，虽然voucherSeckill.getStock()是一个Integer对象，但因为
<code>RedisTemplate</code>
的序列化方式存入Redis变成了乱码，导致在lua脚本无法识别数字</p>
<p><strong>解决办法</strong>：</p>
<p>无效尝试：在存储库存值时将 <code>Integer</code>
显式转换为字符串存储，还是有乱码只是少了点；</p>
<p><strong>有效方案：</strong>使用 <code>StringRedisTemplate</code>
来简化处理，<code>@Autowired</code>注入，然后利用其来保证存储正确数据；</p>
<p><code>stringRedisTemplate.opsForValue().set("seckill:stock:" + voucherSeckill.getVoucherId(), voucherSeckill.getStock().toString());</code></p>
<p>确保在 Lua 脚本中将 Redis 中存储的字符串值通过
<code>tonumber()</code> 转换为数字。</p>
<p>8.执行Lua脚本，始终返回1，代表库存不足，没找到原因</p>
<p>在Lua中添加调试信息：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> stock = redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;debug:stockKey_check&#x27;</span>, <span class="string">&#x27;StockKey is: &#x27;</span> .. stockKey)</span><br><span class="line"><span class="keyword">if</span> (stock == <span class="literal">false</span> <span class="keyword">or</span> <span class="built_in">tonumber</span>(stock) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2 库存不存在或不足则返回1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;debug:stock_check&#x27;</span>, <span class="string">&#x27;Stock is: &#x27;</span> .. <span class="built_in">tostring</span>(<span class="built_in">tonumber</span>(stock)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>发现stockKey的名称为乱码：seckill:stock:�� t
10，遂检查代码，发现执行脚本时也是redisTemplate，于是把所有的redisTemplate全部换成StringRedisTemplate</p>
<p>最终测试：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241216210259589.png"
alt="image-20241216210259589" />
<figcaption aria-hidden="true">image-20241216210259589</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20241216222127491.png"
alt="image-20241216222127491" />
<figcaption aria-hidden="true">image-20241216222127491</figcaption>
</figure>
<p>最终结果：只有一个线程可以同时下单成功</p>
<h1 id="四mybatis-plus学习总结">四、Mybatis-plus学习总结</h1>
<p>配置mp：</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置：</p>
<p>application.yml:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="attr">mapper-locations:</span> <span class="string">$&#123;sky.mybatis-plus.mapper-locations&#125;</span> <span class="comment"># 如果使用 XML 映射文件</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">      <span class="attr">log-impl:</span> <span class="string">$&#123;sky.mybatis-plus.configuration.log-impl&#125;</span> <span class="comment"># 开启 SQL 日志</span></span><br></pre></td></tr></table></figure>
<p>配置实体类的别名扫描包：（一般都会默认配好）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure>
<p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD，因此自定义的Mapper只要实现了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.sky.entity.User;</span><br><span class="line"><span class="comment">// 泛型中的User就是与数据库对应的实体对象PO.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VoucherMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</p>
<ul>
<li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li>
<li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li>
<li>MybatisPlus会把名为id的字段作为主键</li>
</ul>
<p>至此我们已经配置好MP：1.引入pom文件，配置xml信息 2.实现BaseMapper</p>
<h2 id="基本的增删改查crud">基本的增删改查CRUD</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">void method ()&#123;</span><br><span class="line">	 userMapper.insert(user);</span><br><span class="line">	 User user = userMapper.selectById(5L);</span><br><span class="line">	 List&lt;User&gt; users = userMapper.selectBatchIds(List.of(1L, 2L, 3L, 4L, 5L));</span><br><span class="line">	 userMapper.updateById(user);</span><br><span class="line">	 userMapper.deleteById(5L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常见注解：</strong></p>
<p><code>@TableName</code>：用在实体类上，数据库注解，标识实体类对应的数据库表</p>
<p>属性：value（表名）、schema（schema如sky-take-out(.表)）</p>
<p><code>@TableId</code>：用在实体类的主键字段，主键注解，标识实体类中的主键字段、</p>
<p>属性：value（表名）和type（主键类型）</p>
<p><code>@TableField</code>：普通字段注解，一般不用</p>
<h2 id="核心用法">核心用法</h2>
<h3 id="where条件">Where条件</h3>
<p>因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件，参数中的<code>Wrapper</code>就是条件构造的抽象类</p>
<p>即<code>wrapper</code>是用来实现where条件的</p>
<p>一般常用的有四种：</p>
<p><strong>QueryWrapper</strong>：修改、删除、查询，都可以使用QueryWrapper来构建查询条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">        .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2.查询数据</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<p><strong>UpdateWrapper</strong>：SET的赋值结果是基于字段现有值的，需要利用UpdateWrapper的setSql功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line">        <span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前两种Wrapper写死了构造条件的字段值，下面利用Lambda的Wrapper更为常用（基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了）</p>
<p><strong>LambdaQueryWrapper/LambdaUpdateWrapper</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>) <span class="comment">//利用这种方式获取数据库的信息，后面的是传入的参数信息</span></span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义sql">自定义SQL</h3>
<p>在上面的测试案例中，SQL语句写在了Service层，是不可以的，现在要写到Mapper，自定义SQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在UserMapper中自定义SQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 下面的$&#123;ew.customSqlSegment&#125;是固定写法</span></span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UPDATE user SET balance = balance - #&#123;money&#125;</code>：更新
<code>user</code> 表中的 <code>balance</code>
字段，扣除指定金额，<code>#&#123;money&#125;</code> 是一个 MyBatis
的占位符，表示将方法参数 <code>money</code>
的值传入。而<code>$&#123;ew.customSqlSegment&#125;</code>则表示将
<code>QueryWrapper&lt;User&gt;</code> 类型的参数 <code>ew</code> 中的
<code>customSqlSegment</code> 内容插入到 SQL
语句中。<code>customSqlSegment</code> 是 <code>QueryWrapper</code>
对象中一个特殊的属性，它允许我们在查询条件中动态地插入额外的 SQL
片段（例如 <code>WHERE</code>
子句）。利用${}而不是#{}，因为#{}是参数替换，${}是字符串拼接</p>
<p><code>QueryWrapper&lt;User&gt;</code> 中的泛型是 <code>User</code>，
<code>QueryWrapper</code> 基于User实体类构建 <code>User</code> 表的 SQL
条件</p>
<p>MyBatisPlus不支持多表查询，我们可以利用Wrapper<strong>中自定义条件</strong>结合自定义SQL来实现多表查询的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在UserMapper中自定义方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="service接口">Service接口</h2>
<h3 id="基本用法">基本用法</h3>
<p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法</p>
<p><code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法</p>
<p>自定义IUserService接口继承IService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，编写<code>UserServiceImpl</code>类，继承<code>ServiceImpl</code>，实现<code>UserService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceImpl</code> 是 MyBatis-Plus
提供的一个基类，它是一个通用的服务类实现，封装了很多常见的 CRUD
操作。<code>ServiceImpl</code> 实现了 <code>IService</code>
接口，并且提供了 <code>IService</code> 中定义的方法的默认实现</p>
<p>有了Service接口，可以直接在Controller中操作到数据库</p>
<p>编写Controller层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> UserFormDTO userFormDTO)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.转换DTO为PO</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.copyProperties(userFormDTO, User.class);</span><br><span class="line">        <span class="comment">// 2.新增</span></span><br><span class="line">        userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">        userService.removeById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">        <span class="comment">// 2.处理vo</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUserByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">        <span class="comment">// 2.处理vo</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@RequiredArgsConstructor</code> 是 <strong>Lombok</strong>
提供的一个注解，它会自动生成一个构造函数，该构造函数包含所有
<strong><code>final</code></strong> 或
<strong><code>@NonNull</code></strong>
注解标注的字段。代码中的作用是自动为 <code>userService</code>
字段生成一个构造函数，以便在类初始化时注入依赖。（<code>@RequiredArgsConstructor</code>，不需要手动写构造函数，只需要标注
<code>final</code>
字段，它会自动完成依赖注入的工作，就不用@Autowired了）</p>
<p>上面的例子非常方便的实现了在Controller层的简单CRUD，但是业务逻辑代码就需要在Service层再写了</p>
<p>如：根据id扣减用户余额</p>
<p>需要先判断用户状态，然后判断余额，最后扣减</p>
<p>首先在UserController中定义一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;扣减用户余额&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@PathVariable(&quot;money&quot;)</span>Integer money)</span>&#123;</span><br><span class="line">    userService.deductBalance(id, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是UserService接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是UserServiceImpl实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 2.判断用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断用户余额</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.扣减余额 baseMapper是父接口</span></span><br><span class="line">        baseMapper.deductMoneyById(id, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是mapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deductMoneyById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;money&quot;)</span> Integer money)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="lambda功能简化">Lambda功能简化</h3>
<p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</p>
<p>接下来我们在UserController中定义一个controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组织查询条件的时候，我们加入了 <code>username != null</code>
这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<code>&lt;if&gt;</code>标签。这样就实现了动态查询条件效果了</p>
<p>进一步地，Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code></p>
<p>基于Lambda查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：</p>
<ul>
<li><code>.one()</code>：最多1个结果</li>
<li><code>.list()</code>：返回集合结果</li>
<li><code>.count()</code>：返回计数结果</li>
</ul>
<p><strong>同理：IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务</strong></p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是存在ABA问题：ABA 问题通常指的是在并发环境中，某个值在某个时刻从 A
变成了 B，然后又变回
A，外部系统无法检测到这个值曾经经历过变化，但实际上它已经发生了变化。这个问题常见于基于版本号或时间戳的乐观锁机制中。例如，乐观锁使用的是
<code>eq(User::getBalance, user.getBalance())</code>，这意味着在更新余额时，系统会校验当前数据库中的余额是否与用户获取的余额相同。如果中间有其他线程修改了余额，但最终余额恢复到原值，则当前线程会错误地认为数据没有变化，导致错误的更新操作，所以用<strong>version比较好</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lambdaUpdate()</span><br><span class="line">    .set(User::getBalance, remainBalance)</span><br><span class="line">    .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>)</span><br><span class="line">    .eq(User::getId, id)</span><br><span class="line">    .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">    .eq(User::getVersion, user.getVersion()) <span class="comment">// 校验版本号</span></span><br><span class="line">    .update();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="iservice中的批量新增功能">IService中的批量新增功能</h3>
<p>我们尝试逐条插入数据，发现时间非常慢，后调用mp的批量插入，发现效率也不高：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    userService.save(buildUser(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    list.add(buildUser(i));</span><br><span class="line">    <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        userService.saveBatch(list);</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看MP部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure>
<p>为了提高性能，我们希望插入语句是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:即开启重写批处理的<code>statement</code>语句</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure>
<p>可以大大提高效率啦~</p>
<h2 id="其他功能">其他功能</h2>
<p><code>MyBatisPlus</code>插件：直接配置数据库，然后code
generator即可</p>
<p>Service之间相互调用可能会出现循环依赖问题（在插入订单Service中，还需要调用插入订单详情的Service，maybe死锁，互相等待对方注入），MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能。</p>
<p>改造原本的UserVO：新增地址属性，List列表类型为AddressVO</p>
<p><code>@ApiModelProperty("收货地址列表")</code></p>
<p><code>private List&lt;AddressV0&gt;addresses:</code>首先在IUserService中定义方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line"></span><br><span class="line">    UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在UserServiceImpl中实现该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询收货地址</span></span><br><span class="line">    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)</span><br><span class="line">            .eq(Address::getUserId, userId)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));</span><br><span class="line">    <span class="keyword">return</span> userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p>
<h2 id="分页查询">分页查询</h2>
<p>在config中添加配置类</p>
<p>其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正查询代码</span></span><br><span class="line"> <span class="comment">//  1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="五rabbitmq学习总结">五、RabbitMQ学习总结</h1>
<h2 id="rabbitmq基础知识学习">5.1 RabbitMQ基础知识学习</h2>
<h3 id="rabbitmq-配置定义交换机队列和路由键">1. <strong>RabbitMQ
配置：定义交换机、队列和路由键</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;voucher_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="string">&quot;voucher_order_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义路由</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;voucher.order&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE).build(); <span class="comment">//队列持久化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换机exchange">1.1 交换机（Exchange）</h4>
<ul>
<li><strong>Exchange</strong> 是 <code>RabbitMQ</code>
中的一个核心概念，负责接收生产者发送的消息，并根据路由规则将消息分发到不同的队列。</li>
<li>这里定义了一个名为 <code>voucher_exchange</code> 的 <strong>direct
exchange</strong>，它将根据路由键将消息定向到具体的队列。</li>
<li>使用 <code>durable(true)</code> 表示交换机是持久化的，意味着即使
RabbitMQ 重启，交换机也不会丢失。</li>
</ul>
<h4 id="队列queue">1.2 队列（Queue）</h4>
<ul>
<li><strong>Queue</strong>
是消息的存储容器，消费者会从队列中获取消息进行处理。</li>
<li>这里定义了一个名为 <code>voucher_order_queue</code> 的队列，并且通过
<code>durable(true)</code>
设置队列持久化，确保消息在队列重启后不会丢失。</li>
</ul>
<h4 id="路由routing-key和绑定binding">1.3 路由（Routing
Key）和绑定（Binding）</h4>
<ul>
<li><strong>Routing Key</strong>
是一种路由机制，用于决定消息应发送到哪个队列。<code>voucher.order</code>
是一个简单的字符串，用来与交换机的绑定进行匹配。</li>
<li><strong>Binding</strong>
将交换机和队列通过路由键绑定起来。<code>BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs()</code>
表示将 <code>voucher_order_queue</code> 队列与
<code>voucher_exchange</code> 交换机通过路由键
<code>voucher.order</code> 进行绑定。</li>
</ul>
<h2 id="mq实现消息队列">5.2 MQ实现消息队列</h2>
<h3 id="rabbitmq-配置定义交换机队列和路由键-1">1. <strong>RabbitMQ
配置：定义交换机、队列和路由键</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;voucher_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="string">&quot;voucher_order_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义路由</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;voucher.order&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE).build(); <span class="comment">//队列持久化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交换机exchange-1">1.1 交换机（Exchange）</h3>
<ul>
<li><strong>Exchange</strong> 是 <code>RabbitMQ</code>
中的一个核心概念，负责接收生产者发送的消息，并根据路由规则将消息分发到不同的队列。</li>
<li>这里定义了一个名为 <code>voucher_exchange</code> 的 <strong>direct
exchange</strong>，它将根据路由键将消息定向到具体的队列。</li>
<li>使用 <code>durable(true)</code> 表示交换机是持久化的，意味着即使
RabbitMQ 重启，交换机也不会丢失。</li>
</ul>
<h3 id="队列queue-1">1.2 队列（Queue）</h3>
<ul>
<li><strong>Queue</strong>
是消息的存储容器，消费者会从队列中获取消息进行处理。</li>
<li>这里定义了一个名为 <code>voucher_order_queue</code> 的队列，并且通过
<code>durable(true)</code>
设置队列持久化，确保消息在队列重启后不会丢失。</li>
</ul>
<h3 id="路由routing-key和绑定binding-1">1.3 路由（Routing
Key）和绑定（Binding）</h3>
<ul>
<li><strong>Routing Key</strong>
是一种路由机制，用于决定消息应发送到哪个队列。<code>voucher.order</code>
是一个简单的字符串，用来与交换机的绑定进行匹配。</li>
<li><strong>Binding</strong>
将交换机和队列通过路由键绑定起来。<code>BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs()</code>
表示将 <code>voucher_order_queue</code> 队列与
<code>voucher_exchange</code> 交换机通过路由键
<code>voucher.order</code> 进行绑定。</li>
</ul>
<p>在 <code>RabbitMQ</code>
中，<strong>消息的路由</strong>是由交换机（Exchange）和路由键（Routing
Key）来控制的，发送者并不需要直接指定消息发送到具体的队列，而是通过交换机将消息发送到队列，当消息发送到
<code>voucher_exchange</code>
交换机时，交换机会根据绑定的路由规则将消息分发到相应的队列即配置类中的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue()).to(exchange()).with(ROUTING_KEY).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>voucher_order_queue</code> 队列绑定到
<code>voucher_exchange</code> 交换机，并使用路由键
<code>voucher.order</code></p>
<p>此外，<strong>RabbitMQ</strong>
允许将同一条消息发送到多个队列，这是通过交换机的绑定关系来实现的，即创建两个<code>queue</code>，两个<code>binding</code>即可，如果不关心路由键，而是想把消息广播到多个队列，可以使用
<code>fanout</code> 类型的交换机;<code>fanout</code>
交换机会将所有消息广播到绑定到该交换机的所有队列，无论路由键是什么。</p>
<h3 id="发送消息到-rabbitmq">2. <strong>发送消息到
RabbitMQ</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> Result <span class="title function_">purchase</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1010108L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;同一用户不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建订单对象</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> VoucherOrder.builder().userId(userId).voucherId(voucherId).id(orderId).build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送消息到 RabbitMQ 队列</span></span><br><span class="line">    amqpTemplate.convertAndSend(RabbitMqConfig.EXCHANGE, RabbitMqConfig.ROUTING_KEY, voucherOrder);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;下单成功，订单号：&quot;</span> + orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.1 消息发送 </strong></p>
<ul>
<li>代码中通过 <code>amqpTemplate.convertAndSend()</code>
发送消息。<code>amqpTemplate</code> 是 Spring
提供的消息发送模板，它可以简化与 RabbitMQ 的交互。</li>
<li><strong><code>convertAndSend</code></strong>
方法将消息发送到指定的交换机、路由键和消息体。这里发送的是一个
<code>voucherOrder</code> 对象，表示用户下单的请求。</li>
<li><code>RabbitMqConfig.EXCHANGE</code>：交换机的名称，确保消息发送到正确的交换机。</li>
<li><code>RabbitMqConfig.ROUTING_KEY</code>：路由键，用于确定消息应该被路由到哪个队列。</li>
<li>消息体是 <code>voucherOrder</code> 对象，它封装了用户 ID、优惠券 ID
和订单 ID。</li>
</ul>
<h3 id="消费消息并处理订单">3. <strong>消费消息并处理订单</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@RabbitListener(queues = RabbitMqConfig.QUEUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(VoucherOrder voucherOrder, Channel channel, Message message)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理订单逻辑，创建订单并扣减库存</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建锁对象，防止重复下单</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order&quot;</span> + userId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 锁获取失败直接确认，不需要重新入队</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询订单是否已经存在</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> voucherOrderService.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建订单</span></span><br><span class="line">            voucherOrderService.save(voucherOrder);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;处理订单失败&quot;</span>, e);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 异常时，发送 nack，重新入队重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;确认消息失败&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.1 消费者（Consumer）</strong></p>
<ul>
<li><code>@RabbitListener</code>
注解用于声明该方法是一个消息监听器，它会自动从指定的队列（<code>voucher_order_queue</code>）接收消息。消费者监听该队列并处理队列中的消息。</li>
</ul>
<p><strong>3.2 锁机制</strong></p>
<ul>
<li>使用 Redisson 分布式锁 (<code>RLock</code>)
防止同一用户重复下单。当获取到锁时，处理业务逻辑；如果获取锁失败（表示当前请求正在被其他线程处理），则直接返回，并且确认消息（<code>channel.basicAck()</code>），确保该消息不再被消费。</li>
</ul>
<p><strong>3.3 消息确认（Acknowledgment）</strong></p>
<ul>
<li><code>channel.basicAck()</code>：手动确认消息。当消息成功处理时（比如订单创建成功），通过
<code>basicAck</code> 确认消息已处理，RabbitMQ 会将其从队列中移除。</li>
<li><code>channel.basicNack()</code>：如果处理失败（比如扣减库存失败，或者发生异常），使用
<code>basicNack</code>
将消息重新入队，以便重试。<code>requeue=true</code>
表示消息重新进入队列，待下次消费。</li>
</ul>
<p><strong>3.4 异常处理</strong></p>
<ul>
<li>如果在处理订单的过程中发生异常，<code>basicNack</code>
会重新将消息放回队列，并且设置
<code>requeue=true</code>，使得消息可以重新被消费。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/12/17/%E5%9F%BA%E6%9C%AC%E4%B8%9A%E5%8A%A1%E2%80%94%E2%80%94cq%E5%A4%96%E5%8D%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E5%9F%BA%E6%9C%AC%E4%B8%9A%E5%8A%A1%E2%80%94%E2%80%94cq%E5%A4%96%E5%8D%96/" class="post-title-link" itemprop="url">基本业务——cq外卖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-16 23:07:05 / 修改时间：15:10:11" itemprop="dateCreated datePublished" datetime="2024-12-16T23:07:05Z">2024-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件开发介绍">软件开发介绍</h1>
<p>作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程，
以及软件开发过程中涉及到的岗位角色，角色的分工、职责，
并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从
软件开发流程、角色分工、软件环境 三个方面整体介绍一下软件开发。</p>
<h3 id="软件开发流程">1.1 软件开发流程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106162815172.png" alt="image-20221106162815172"  style="zoom:80%;" /></p>
<p><strong>1). 第1阶段: 需求分析</strong></p>
<p>完成需求规格说明书、产品原型编写。</p>
<p>需求规格说明书， 一般来说就是使用 Word
文档来描述当前项目的各个组成部分，如：系统定义、应用环境、功能规格、性能需求等，都会在文档中描述。<strong>例如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106163758703.png" alt="image-20221106163758703" style="zoom: 50%;" /></p>
<p>产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据,
页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。
<strong>例如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106163925031.png" alt="image-20221106163925031" style="zoom:50%;" /></p>
<p><strong>2). 第2阶段: 设计</strong></p>
<p>设计的内容包含 UI设计、数据库设计、接口设计。</p>
<p>UI设计：用户界面的设计，主要设计项目的页面效果，小到一个按钮，大到一个页面布局，还有人机交互逻辑的体现。<strong>例如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106165303946.png" alt="image-20221106165303946" style="zoom:50%;" /></p>
<p>数据库设计：需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段。<strong>例如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106165554917.png" alt="image-20221106165554917" style="zoom:50%;" /></p>
<p>接口设计：通过分析原型图，首先，粗粒度地分析每个页面有多少接口，然后，再细粒度地分析每个接口的传入参数，返回值参数，同时明确接口路径及请求方式。<strong>例如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106171538880.png" alt="image-20221106171538880" style="zoom:50%;" /></p>
<p><strong>3). 第3阶段: 编码</strong></p>
<p>编写项目代码、并完成单元测试。</p>
<p>项目代码编写：作为软件开发工程师，我们需要对项目的模块功能分析后，进行编码实现。</p>
<p>单元测试：编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。<strong>例如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106175351594.png" alt="image-20221106175351594" style="zoom:50%;" /></p>
<p><strong>4). 第4阶段: 测试</strong></p>
<p>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试,
并出具测试报告。</p>
<p><strong>5). 第5阶段: 上线运维</strong></p>
<p>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置，
配置完毕后， 再将我们开发好的项目，部署在服务器上运行。</p>
<h3 id="角色分工">1.2 角色分工</h3>
<p>在对整个软件开发流程熟悉后，
我们还有必要了解一下在整个软件开发流程中涉及到的岗位角色，以及各个角色的职责分工。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20210725234015404.png"
alt="image-20210725234015404" />
<figcaption aria-hidden="true">image-20210725234015404</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 27%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">岗位/角色</th>
<th>对应阶段</th>
<th style="text-align: left;">职责/分工</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">项目经理</td>
<td>全阶段</td>
<td style="text-align: left;">对整个项目负责，任务分配、把控进度</td>
</tr>
<tr class="even">
<td style="text-align: left;">产品经理</td>
<td>需求分析</td>
<td
style="text-align: left;">进行需求调研，输出需求调研文档、产品原型等</td>
</tr>
<tr class="odd">
<td style="text-align: left;">UI设计师</td>
<td>设计</td>
<td style="text-align: left;">根据产品原型输出界面效果图</td>
</tr>
<tr class="even">
<td style="text-align: left;">架构师</td>
<td>设计</td>
<td style="text-align: left;">项目整体架构设计、技术选型等</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><font color='red'>开发工程师</font></td>
<td><font color='red'>编码</font></td>
<td style="text-align: left;"><font color='red'>功能代码实现</font></td>
</tr>
<tr class="even">
<td style="text-align: left;">测试工程师</td>
<td>测试</td>
<td style="text-align: left;">编写测试用例，输出测试报告</td>
</tr>
<tr class="odd">
<td style="text-align: left;">运维工程师</td>
<td>上线运维</td>
<td style="text-align: left;">软件环境搭建、项目上线</td>
</tr>
</tbody>
</table>
<p>上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工,
但是在实际的项目中, 有一些项目组由于人员配置紧张,
可能并没有专门的架构师或测试人员,
这个时候可能需要有项目经理或者程序员兼任。</p>
<h3 id="软件环境">1.3 软件环境</h3>
<p>作为软件开发工程师，在编码的过程中就不可避免地会接触多种软件环境，我们主要来分析在工作中经常遇到的三套环境，
分别是: 开发环境、测试环境、生产环境。
接下来，我们分别介绍一下这三套环境的作用和特点。</p>
<p><strong>1). 开发环境(development)</strong></p>
<p>我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。</p>
<p>比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地，
也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用，
项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。</p>
<p><strong>2). 测试环境(testing)</strong></p>
<p>当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境，
也就是测试环境，用于项目测试，一般外部用户无法访问。</p>
<p><strong>3). 生产环境(production)</strong></p>
<p>当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对外提供服务，这个线上环境也称之为生产环境。</p>
<p>首先，会在开发环境中进行项目开发，往往开发环境大多数都是本地的电脑环境和局域网内的环境，当开发完毕后，然后会把项目部署到测试环境，测试环境一般是一台独立测试服务器的环境，项目测试通过后，最终把项目部署到生产环境，生产环境可以是机房或者云服务器等线上环境。</p>
<h1 id="项目技术介绍">项目技术介绍</h1>
<p>本项目（苍穹外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括
系统管理后台 和 小程序端应用
两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜品、套餐、订单、员工等进行管理维护，对餐厅的各类数据进行统计，同时也可进行来单语音播报功能。小程序端主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单、支付、催单等。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106185252326.png"
alt="image-20221106185252326" />
<figcaption aria-hidden="true">image-20221106185252326</figcaption>
</figure>
<p>接下来，通过功能架构图来展示<strong>管理端</strong>和<strong>用户端</strong>的具体业务功能模块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106194424735.png" alt="image-20221106194424735" style="zoom: 67%;" /></p>
<p><strong>1). 管理端功能</strong></p>
<p>员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 ,
菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p>
<p><strong>2). 用户端功能</strong></p>
<p>微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 ,
购物车功能 , 下单 , 支付、分类及菜品浏览。</p>
<p><strong>用户端原型图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106195354556.png" alt="image-20221106195354556" style="zoom:50%;" /></p>
<p><strong>1). 管理端</strong></p>
<p>餐饮企业内部员工使用。 主要功能有:</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>模块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>登录/退出</td>
<td>内部员工必须登录后,才可以访问系统管理后台</td>
</tr>
<tr class="even">
<td>员工管理</td>
<td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td>
</tr>
<tr class="odd">
<td>分类管理</td>
<td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护，
包含查询、新增、修改、删除等功能</td>
</tr>
<tr class="even">
<td>菜品管理</td>
<td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td>
</tr>
<tr class="odd">
<td>套餐管理</td>
<td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td>
</tr>
<tr class="even">
<td>订单管理</td>
<td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td>
</tr>
<tr class="odd">
<td>数据统计</td>
<td>主要完成对餐厅的各类数据统计，如营业额、用户数量、订单等</td>
</tr>
</tbody>
</table>
<p><strong>2). 用户端</strong></p>
<p>移动端应用主要提供给消费者使用。主要功能有:</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>模块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>登录/退出</td>
<td>用户需要通过微信授权后登录使用小程序进行点餐</td>
</tr>
<tr class="even">
<td>点餐-菜单</td>
<td>在点餐界面需要展示出菜品分类/套餐分类,
并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td>
</tr>
<tr class="odd">
<td>点餐-购物车</td>
<td>用户选中的菜品就会加入用户的购物车, 主要包含
查询购物车、加入购物车、删除购物车、清空购物车等功能</td>
</tr>
<tr class="even">
<td>订单支付</td>
<td>用户选完菜品/套餐后, 可以对购物车菜品进行结算支付,
这时就需要进行订单的支付</td>
</tr>
<tr class="odd">
<td>个人信息</td>
<td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址,
也可以查询历史订单数据</td>
</tr>
</tbody>
</table>
<h3 id="技术选型">2.3 技术选型</h3>
<p>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层
这几个方面进行介绍，主要用于展示项目中使用到的技术框架和中间件等。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221106185646994.png"
alt="image-20221106185646994" />
<figcaption aria-hidden="true">image-20221106185646994</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/09/25/leetcode%E7%AE%80%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/25/leetcode%E7%AE%80%E8%AE%B0/" class="post-title-link" itemprop="url">leetcode简记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-09-24 16:23:08 / 修改时间：08:23:08" itemprop="dateCreated datePublished" datetime="2024-09-24T16:23:08Z">2024-09-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/09/18/%E6%96%B0%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%96%B0%E5%BC%80%E5%A7%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/18/%E6%96%B0%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%96%B0%E5%BC%80%E5%A7%8B/" class="post-title-link" itemprop="url">新生活，新开始</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-09-17 21:27:22 / 修改时间：15:24:47" itemprop="dateCreated datePublished" datetime="2024-09-17T21:27:22Z">2024-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虽然很久很久没有写博客了，但是会经常打开博客，会经常通过写日记的方式来记录一下零散的生活。5月份以后专注于毕设的实验分析和论文撰写，到6月份的答辩，顺利通过，最后成功从XDU毕业，为我的大学四年画上了一个不大不小的句号，也为新的生活另起了一段。</p>
<p>问自己大学有什么成长和难忘遗憾，固然是有很多，可能是受制于性格，缺乏在做选择时的勇气，特别是大三大四，做什么选择总是想从网上找到一个最优解，总想看一下别人的看法，好似那不是我的选择，而是别人的，推卸责任。我逐渐意识到那份勇气的重要性，心中换导师的想法愈加强烈，我想要什么，我能得到什么。大学伊始，从小镇走出的"乡下人"没有充足广阔的视野，我想要啥啊？不知道，先好好学习，然后考研保研，漫无目的；学了一段时间，成绩没有很突出，我想要啥啊，那就是保研了，随波逐流地开始卷，卷成绩，卷竞赛，卷项目；真正出保研成绩排名的时候，感觉天都塌下来了，这个rank不支持我去到华五及以上的学校，彷佛我就定格在了武大及以下，那一下午的我思想空洞，不知道三年的努力是为了什么，我仔细搜索了科大、浙大、复旦上交、北大清华的考研大纲，想要放弃保研通过考研走出自己想要的路，这个时候如果问我想要的路是什么？可能是不停地向上爬，爬到一个很好的学校，很棒的title才能证明自己的努力。和父母家人同学商议以后，大家都是在说不要放弃，先试试，武大也很不错等等话语，因为那个时候我怂，我懦弱，我不敢去做选择，我没有这个勇气，我还是妥协了，听取大家的意见，继续奋斗备战保研的夏令营和预推免。父母家人和朋友总是想让我们平平安安地活着，可是我是个喜欢赌的人，但是那个时候的我不是个固执的人。在三个月以后，我拿到了武大、北理、北航、信工所等学校的offer，也联系了一些导师，最后好似命运的安排般，我选了北航，来到了首都北京。还是那个注重title的我，他最后用好的title来决定硕士生涯。随着大学到了尾声，也逐渐发现自己越来越难地专注，就是那种心流状态，十分专注地做一件事情，感觉很难达到，希望自己能找回那种感觉，而不是被动功利性目的式去思考去学习。</p>
<p>研究生最重要的是导师，当时联系导师的时候也很懦，不敢再去多一些尝试，总是把很多事情想的很顺利，实际并不是这样，顺利的事情是靠不顺利的人造就的。在整个大四生涯，我感受到来自我的导师的各种压力，组会科研，项目本子，学术分享，毕设进度，那个时候我已然对就业有些了解，但还是没能勇敢地说出来换导师，不过已经产生了这个念头。我知道了我想要什么，现在要做的就是去努力得到它。到了即将进入研究生的那个暑假，过了一个很难忘的生日，非常颓废，在家里的床上，吃了睡睡了吃，吃了焦虑，焦虑组会，焦虑和老师交流，然后不知道哪里来的勇气，我决定换导师了，我联系了新的导师，我写了一封很长很长的信，我的原导师人是很nice的，很快便同意了我的请求，我现在的导师就是一个很放养的导师，基本上没有什么事情，我的目标已经明确了，途径也很顺滑了，没有什么障碍了，我现在要做的任务就是实习、实习还是实习，学开发进厂，去做喜欢的，去做想要的吧。</p>
<p>悟已往之不谏，知来者之可追。</p>
<h1 id="我希望的研一">我希望的研一</h1>
<p>踏入硕士生活半月有余，上课才一整周，大概摸清了各个课程的结构内容，对整体的生活只感觉是<strong>形单影只衣单薄，心旷神飞无所指</strong>。研究生是一个人的生活，一定要明确目标，最终目标就是就业，我读研就是为了毕业有个985头衔，所以我希望的研一是这样的。</p>
<p><strong>目标：</strong>期末不挂科为前提，学完Java实习的框架知识，力扣刷完基本结构＋Hot100</p>
<p><strong>DDL：</strong>期末考试2025.01.13</p>
<h2 id="上学期规划">上学期规划</h2>

<div class="markmap-container" style="height:800">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,30]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;学习&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;学分课程&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;数学类：矩阵/最优化跟上课，省时间、为复习做铺垫&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;其他：做好汇报不挂科，不急不卷不浪费&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;实习准备&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Java八股:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Java基础，Java集合，Java并发，JVM以及其他&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;计算机基础:计算机网络，操作系统，计算机组成&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;数据库:MySQL，Redis基本操作&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;框架学习:Spring，SpringBoot，设计模式，常用工具(Git,Maven,Docker)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;实战项目&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;JavaWeb课程→外卖项目→AI若依（黑马路线）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;改编一个项目(黑马头条，学成在线，尚硅谷尚庭公寓等)-&amp;gt;完整手撕（待定项目）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;算法力扣&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;按框架刷代码随想录&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;hot100+剑指offer&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;多次刷多轮刷&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;兴趣&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;阅读练字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;读书：希望大量阅读各类感兴趣的书籍，纸质版/电子书，静下心去读； 针对书中好的句子进行摘抄，顺便练习钢笔字&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;学习摄影：摄影课程的学习+相机购买+实战运用&quot;}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,38]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;锻炼&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;跑步：中长跑，每日坚持，循序渐进，&lt;strong&gt;目标&lt;/strong&gt;超过3km/15分钟&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;游泳：1.考深水证  2.蛙泳可以连续500  3.学会自由泳&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;无氧增肌：1.腹肌训练（按照NEXTworkout每天一组 + 其他教程的5*4组）  2.胸肌/肱二头肌（引体向上，每次跑步后）&quot;}]}]}],&quot;p&quot;:{}}"></svg>
</div>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/04/26/Day9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/Day9/" class="post-title-link" itemprop="url">Day9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-25 21:13:39 / 修改时间：13:26:20" itemprop="dateCreated datePublished" datetime="2024-04-25T21:13:39Z">2024-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法">算法</h1>
<p>继续刷回溯专题的内容，今天效率有些低，就写了两道题，都是组合总和的题，在回溯中，很多剪枝技巧都是很妙的，可遇而不可求，需要记住，理解，在代码中体会。</p>
<p>去重操作是很多题中必不可少的：需要理解去重的逻辑，在回溯/二叉树去重中，分清<strong>树层去重”和“树枝去重”</strong>，continue和break，去重和剪枝的区别，别搞混</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240425211918718.png" /></p>
<h1 id="开发">开发</h1>
<p>学习完了Spring
MVC的基本内容，请求的最后部分——不同类型的参数，响应的相关注解，进一步学习了三层架构M
V C</p>
<p>控制层Controller、业务逻辑层Service、数据访问层Dao，学习了分层解耦IOC和DI的基本用法</p>
<p>具体内容见JavaWeb文档 ~</p>
<h1 id="毕设">毕设</h1>
<p>今天毕设的进度很少，仅仅把研究现状参考文献全部搞完，搞完数了数，一共50多篇参考文献，属实是有点多了，突出一个又臭又长的参考文献~</p>
<p>至少学会了bibtex的一些使用，上次搞武大的latex代码时，xelatex-&gt;
pdftex -&gt;
xelatex的编译，然后编译运行的操作学到了很多，所以在看xduts.pdf时也不会觉得懵逼，现在可以bibtex的正常编译了，在用xduts模版是：xe
-&gt; bibter -&gt; xe</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/03/20/JavaWeb%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/20/JavaWeb%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">JavaWeb开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 20:10:06" itemprop="dateCreated datePublished" datetime="2024-03-19T20:10:06Z">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-25 13:11:20" itemprop="dateModified" datetime="2024-04-25T13:11:20Z">2024-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="maven">Maven</h1>
<h2 id="maven入门">1.Maven入门</h2>
<h3 id="概述">概述</h3>
<p>Maven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。</p>
<p><strong>Maven作用：</strong></p>
<ol type="1">
<li><strong>依赖管理</strong></li>
</ol>
<ul>
<li>方便快捷的管理项目依赖的资源(jar包)，避免引入大量的jar包，不同jar包之间的版本冲突问题</li>
<li>当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。
我们只需要在maven项目的pom.xml文件中，添加一段<dependency>依赖实现</li>
</ul>
<ol start="2" type="1">
<li><strong>统一项目结构</strong></li>
</ol>
<ul>
<li>提供标准、统一的项目结构，使用不同的开发工具Eclipse或者IDEA创建项目工程时发现项目结构不一致，若创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221130220539444.png"
alt="image-20221130220539444" />
<figcaption aria-hidden="true">image-20221130220539444</figcaption>
</figure>
<p>统一结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- src/main/java: java源代码目录</span><br><span class="line">- src/main/resources:  配置文件信息</span><br><span class="line">- src/test/java: 测试代码</span><br><span class="line">- src/test/resources: 测试配置文件信息</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>项目构建</strong></li>
</ol>
<p>maven提供了标准的、跨平台(Linux、Windows、MacOS)
的自动化项目构建方式<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221130222907628.png"
alt="image-20221130222907628" /></p>
<ul>
<li>Maven中的坐标是==资源的唯一标识== ,
通过该坐标可以唯一定位资源位置</li>
<li>使用坐标来定义项目或引入项目中需要的依赖</li>
</ul>
<p>坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置，坐标由:<groupld>、<artifactld>、<version>三个标签组成；</p>
<ul>
<li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li>
<li>artifactId：定义当前Maven项目名称（通常是模块名称，例如
order-service、goods-service）</li>
<li>version：定义当前项目版本号</li>
</ul>
<p>依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包</p>
<p>pom.xml文件中的坐标能找到所要的jar包，利用Maven<strong>仓库</strong></p>
<h3 id="maven仓库">Maven仓库</h3>
<p>Maven仓库分为：</p>
<ul>
<li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li>
<li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/</li>
<li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li>
</ul>
<p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包</p>
<ul>
<li><p>如果有，则在项目直接引用</p></li>
<li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库</p></li>
</ul>
<p>如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库
--&gt; 远程仓库--&gt; 中央仓库</p>
<p>由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p>
<p>进入到conf目录下修改settings.xml配置文件即可（<strong>阿里云私服</strong>）==注:
只可配置一个<mirror>(另一个要注释!)
，不然两个可能发生冲突，导致jar包无法下载!!!!!!!==</p>
<h2 id="maven项目">2.Maven项目</h2>
<blockquote>
<ul>
<li><p>Maven项目的目录结构:</p>
<p>maven-project01 |--- src (源代码目录和测试代码目录) |--- main
(源代码目录) |--- java (源代码java文件目录) |--- resources
(源代码配置文件目录) |--- test (测试代码目录) |--- java
(测试代码java目录) |--- resources (测试代码配置文件目录) |--- target
(编译、打包生成文件存放目录)</p></li>
</ul>
</blockquote>
<p>POM (Project Object Model)
：指的是项目对象模型，用来描述当前的maven项目。</p>
<ul>
<li>使用pom.xml文件来实现</li>
</ul>
<p>pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- POM模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 打包方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>pom文件详解：</p>
<ul>
<li><project> ：pom文件的根标签，表示当前maven项目</li>
<li><modelVersion> ：声明项目描述遵循哪一个POM模型版本
<ul>
<li>虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0</li>
</ul></li>
<li>坐标 ：<groupId>、<artifactId>、<version>
<ul>
<li>定位项目在本地仓库中的位置，由以上三个标签组成一个坐标</li>
</ul></li>
<li><packaging>
：maven项目的打包方式，通常设置为jar或war（默认值：jar）</li>
</ul>
<p>使用Maven面板，通过导入pox文件可以快速导入Maven文件</p>
<h2 id="maven依赖管理">3.Maven依赖管理</h2>
<p>依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：</p>
<p>例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：</p>
<ol type="1">
<li>在pom.xml中编写<dependencies>标签</li>
<li>在<dependencies>标签中使用<dependency>引入坐标</li>
<li>定义坐标的 groupId、artifactId、version</li>
<li>点击刷新按钮，引入最新加入的坐标
<ul>
<li>刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标</li>
</ul></li>
</ol>
<p><strong>添加依赖的几种方式：</strong></p>
<ol type="1">
<li>利用中央仓库搜索的依赖坐标</li>
<li>利用IDEA工具搜索依赖 Alt+Insert快捷键 -&gt; Dependencies</li>
</ol>
<p><strong>依赖具有传递性</strong></p>
<p>早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。若需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下。</p>
<p><strong>However，</strong>我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可，在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。</p>
<p>依赖传递可以分为：</p>
<ol type="1">
<li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li>
<li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li>
</ol>
<p><strong>排除依赖：</strong></p>
<p>在maven项目中，我们可以通过排除依赖来实现：A依赖B，B依赖C，如果<strong>A不想将C</strong>依赖进来</p>
<p>什么是排除依赖？<exclusions> <exclusion></p>
<ul>
<li>排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）</li>
</ul>
<p>依赖排除示例：</p>
<ul>
<li>maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit</li>
</ul>
<p>使用排除依赖后，maven-projectA不再依赖了Junit</p>
<p><strong>依赖范围：</strong></p>
<p>在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。</p>
<p>如果希望限制依赖的使用范围，可以通过<scope>标签设置其作用范围。</p>
<p>作用范围：</p>
<ol type="1">
<li>主程序范围有效（main文件夹范围内）</li>
<li>测试程序范围有效（test文件夹范围内）</li>
<li>是否参与打包运行（package指令范围内）</li>
</ol>
<h2 id="maven生命周期">4.Maven生命周期</h2>
<p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。
描述了一次项目构建，经历哪些阶段。在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行<strong>清理，编译，测试及部署</strong>。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。</p>
<p>Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。</p>
<p>Maven对项目构建的生命周期划分为3套（相互独立）：</p>
<ul>
<li>clean：清理工作。</li>
<li>default：核心工作。如：编译、测试、打包、安装、部署等。</li>
<li>site：生成报告、发布站点等。</li>
</ul>
<p>主要关注以下几个：</p>
<p>• clean：移除上一次构建生成的文件</p>
<p>• compile：编译项目源代码</p>
<p>• test：使用合适的单元测试框架运行测试(junit)</p>
<p>• package：将编译后的文件打包，如：jar、war等</p>
<p>• install：安装项目到本地仓库</p>
<p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong></p>
<p><strong>生命周期的顺序</strong>是：clean --&gt; validate --&gt;
compile --&gt; test --&gt; package --&gt; verify --&gt; install --&gt;
site --&gt; deploy</p>
<p>我们需要关注的就是：clean --&gt; compile --&gt; test --&gt; package
--&gt; install</p>
<p>在<strong>同一套</strong>生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。（执行package时，compile会执行，但clean不会，因为不是一套）</p>
<p>在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：</p>
<ol type="1">
<li>在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行</li>
<li>在DOS命令行中，通过maven命令执行</li>
</ol>
<p>compile后：只对main文件夹（主函数）源代码编译，生成target目录</p>
<p>test：对test文件夹（测试程序）进行编译</p>
<p>package：对项目打包，生成jar包，打包后生成的jar包放在target目录下</p>
<p>install：把jar文件安装在当前项目文件夹指定坐标路径下（target）</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221201170830837.png"
alt="image-20221201170830837" />
<figcaption aria-hidden="true">image-20221201170830837</figcaption>
</figure>
<p>clean：删除target目录</p>
<p>DOS操作：需要在Poweshell窗口操作 mvn clean....</p>
<h2 id="其他maven知识点持续补充">5.其他Maven知识点（持续补充）</h2>
<p>有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：</p>
<p>打开设置----搜索maven----Repositories----选中本地仓库-----点击Update</p>
<p>清理Maven仓库：初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。</p>
<p>如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set REPOSITORY_PATH=E:\develop\apache-maven-3.6.1\mvn_repo</span><br><span class="line">rem 正在搜索...</span><br><span class="line"></span><br><span class="line">del /s /q %REPOSITORY_PATH%\*.lastUpdated</span><br><span class="line"></span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>操作步骤如下：</p>
<p>1). 定义批处理文件del_lastUpdated.bat
(直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可
)</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221214154949482.png"
alt="image-20221214154949482" />
<figcaption aria-hidden="true">image-20221214154949482</figcaption>
</figure>
<p>2). 在上面的bat文件上<strong>右键---》编辑</strong>
。修改文件：REPOSITORY为自己的仓库 mvn-3.6.1/mvn_repo</p>
<p>修改完毕后，双击运行即可删除maven仓库中的残留文件。</p>
<h1 id="springboot">SpringBoot</h1>
<p>Spring的官网(https://spring.io)，去看一下Spring的简介：Spring makes
Java simple。</p>
<p>Spring的官方提供很多开源的项目，可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：</p>
<p>SpringBoot SpringFrameWork SpringData SpringCloud SpringCloudDataFlow
SpringSecurity</p>
<p>Spring若干个子项目完成特点的功能，统称为：<strong>spring全家桶</strong></p>
<p>最基础、最核心的是
SpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p>
<p><strong>However</strong>：直接基于SpringFramework进行开发，存在个问题：配置繁琐、入门难度大；基于此，spring官方推荐从另外一个项目开始学习，那就是目前最火爆的<strong>SpringBoot。</strong></p>
<p>SB最大特点：简单配置 + 快速开发 <strong>Spring Boot
可以帮助我们非常快速的构建应用程序、简化开发、提高效率 </strong></p>
<h2 id="基础入门">1.基础入门</h2>
<h3 id="创建工程">创建工程</h3>
<p>需求：基于<strong>SpringBoot的方式</strong>开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串
“Hello World”。</p>
<p>第1步：创建SpringBoot工程项目</p>
<p>第2步：定义HelloController类，添加方法hello，并添加注解</p>
<p>第3步：测试运行</p>
<p>基于Spring官方骨架，创建SpringBoot工程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221201184702136.png" alt="image-20221201184702136" style="zoom:50%;" /></p>
<p>基本信息描述完毕之后，勾选web开发相关依赖。</p>
<p>点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：</p>
<p>src - main - java - com.ning -
SpringBootQuickStarte1Appication.java</p>
<p>在com.ning这个包下创建一个子包controller，再在controller包下新建一个类：HelloController</p>
<p>编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span><span class="comment">//注解，非常有用！！！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>运行SpringBoot自动生成的引导类：SpringBootQuickStarte1Appication.java（有main函数）</p>
<p>打开浏览器，输入 <code>http://localhost:8080/hello</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823195048415.png" style="zoom:80%;" /></p>
<p>以上内容是基于Spring官方提供的骨架实现，Spring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。</p>
<p>同时，案例中也引用了：web依赖和test依赖（dependencies，Maven学到的）</p>
<p>spring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：<strong>起步依赖</strong></p>
<p>而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为<strong>起步依赖</strong>。</p>
<ul>
<li>spring-boot-starter-web：包含了web应用开发所需要的常见依赖</li>
<li>spring-boot-starter-test：包含了单元测试所需要的常见依赖</li>
</ul>
<p><strong>spring-boot-starter-web</strong>内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入
<code>spring-boot-starter-web</code>
依赖就可以实现Web开发的需要的功能（通过依赖传递，自动导入web开发所需依赖）</p>
<p>Spring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。</p>
<p>地址：https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters</p>
<p>每一个起步依赖，都用于开发一个特定的功能。</p>
<blockquote>
<p>例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis
，即可导入redis开发所需要的依赖。</p>
</blockquote>
<p>在之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。每一个SpringBoot工程，都有一个<strong>父工程</strong>。依赖的版本号，在<strong>父工程中统一管理</strong>。</p>
<p><parent>parent标签指示父工程</p>
<p>同时，在刚刚启动的SpringBoot项目中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器（下文要提到的Web服务器），我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。</p>
<p>当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。</p>
<h3 id="解析过程">解析过程</h3>
<p><strong>浏览器Browser：</strong></p>
<ul>
<li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p>
<ul>
<li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p>
<blockquote>
<p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p>
</blockquote></li>
<li><p>通过端口号8080找到计算机上运行的程序</p>
<blockquote>
<p><code>localhost:8080</code> ,
意思是在本地计算机中找到正在运行的8080端口的程序</p>
</blockquote></li>
<li><p>/hello是<strong>请求资源位置</strong></p>
<ul>
<li>资源：对计算机而言资源就是数据
<ul>
<li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li>
</ul></li>
</ul>
<blockquote>
<p><code>localhost:8080/hello</code>
，意思是向本地计算机中的8080端口程序，获取资源位置是/hello的数据</p>
<ul>
<li>8080端口程序，在服务器找/hello位置的资源数据，发给浏览器</li>
</ul>
</blockquote></li>
</ul></li>
</ul>
<p><strong>服务器：（可以理解为ServerSocket）</strong></p>
<ul>
<li>接收到浏览器发送的信息（如：/hello）</li>
<li>在服务器上找到/hello的资源</li>
<li>把资源发送给浏览器</li>
</ul>
<blockquote>
<p>网络三要素：</p>
<ul>
<li>IP ：网络中计算机的唯一标识</li>
<li>端口 ：计算机中运行程序的唯一标识</li>
<li>协议 ：网络中计算机之间交互的规则</li>
</ul>
<p><strong>浏览器和服务器两端进行数据交互，使用http协议</strong>**</p>
</blockquote>
<h2 id="http协议">2.HTTP协议</h2>
<h3 id="概述-1">概述</h3>
<p>HTTP：Hyper Text Transfer
Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p>
<ul>
<li>http是互联网上应用最为广泛的一种网络协议</li>
<li>http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照<strong>固定的格式</strong>进行数据传输</li>
</ul>
<p>格式：</p>
<p>浏览器向服务器进行请求时：</p>
<ul>
<li>服务器按照固定的格式进行解析</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221202111044434.png"
alt="image-20221202111044434" />
<figcaption aria-hidden="true">image-20221202111044434</figcaption>
</figure>
<p>服务器向浏览器进行响应时：</p>
<ul>
<li>浏览器按照固定的格式进行解析</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221202111307819.png"
alt="image-20221202111307819" />
<figcaption aria-hidden="true">image-20221202111307819</figcaption>
</figure>
<p><strong>HTTP协议有哪些特点？</strong></p>
<ul>
<li><p><strong>基于TCP协议: </strong> 面向连接，安全</p>
<blockquote>
<p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p>
</blockquote></li>
<li><p><strong>基于请求-响应模型:</strong>
一次请求对应一次响应（先请求后响应）</p>
<blockquote>
<p>请求和响应是一一对应关系，没有请求，就没有响应</p>
</blockquote></li>
<li><p><strong>HTTP协议是无状态协议:</strong>
对于数据没有记忆能力。每次请求-响应都是独立的</p>
<blockquote>
<p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p>
<ul>
<li>缺点: 多次请求间不能共享数据</li>
<li>优点: 速度快（只要速度快就够了，因为用户需要及时反馈）</li>
</ul>
<p>解决数据共享：Java中使用会话技术(Cookie、Session)来解决这个问题。</p>
</blockquote></li>
</ul>
<p>浏览器和服务器是按照HTTP协议进行数据通信的。</p>
<p>HTTP协议又分为：请求协议和响应协议</p>
<ul>
<li>请求协议：浏览器将数据以请求格式发送到服务器
<ul>
<li>包括：<strong>请求行</strong>、<strong>请求头</strong>
、<strong>请求体</strong></li>
</ul></li>
<li>响应协议：服务器将数据以响应格式返回给浏览器
<ul>
<li>包括：<strong>响应行</strong> 、<strong>响应头</strong>
、<strong>响应体</strong></li>
</ul></li>
</ul>
<h3 id="请求协议">请求协议</h3>
<p>最常见：</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">请求方式</th>
<th style="text-align: left;">请求说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>GET</strong></td>
<td
style="text-align: left;">获取资源。<br/>向特定的资源发出请求。例：http://www.baidu.com/s?wd=hehe2ning</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>POST</strong></td>
<td
style="text-align: left;">传输实体主体。<br/>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td>
</tr>
</tbody>
</table>
<p><strong>GET方式的请求协议：</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823200708026.png" /></p>
<ul>
<li><p>请求行
：HTTP请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）</p>
<ul>
<li>请求方式：GET<br />
</li>
<li>资源路径：/brand/findAll?name=OPPO&amp;status=1
<ul>
<li>请求路径：/brand/findAll</li>
<li>请求参数：name=OPPO&amp;status=1
<ul>
<li>请求参数是以key=value形式出现</li>
<li>多个请求参数之间使用<code>&amp;</code>连接</li>
</ul></li>
<li>请求路径和请求参数之间使用<code>?</code>连接<br />
</li>
</ul></li>
<li>协议/版本：HTTP/1.1</li>
</ul></li>
<li><p>请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key:
value形式</p>
<ul>
<li>http是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了</li>
</ul>
<p>常见请求头：</p>
<p><strong>Host:</strong> 表示请求的主机名</p>
<p><strong>User-Agent:</strong> 浏览器版本。
例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79
，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko</p>
<p><strong>Accept：</strong>表示浏览器能接收的资源类型，如text/<em>，image/</em>或者<em>/</em>表示所有；</p>
<p><strong>Accept-Language：</strong>表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</p>
<p><strong>Accept-Encoding：</strong>表示浏览器可以支持的压缩类型，例如gzip,
deflate等。</p>
<p><strong>Content-Type：</strong>请求主体的数据类型</p>
<p><strong>Content-Length：</strong>数据主体的大小（单位：字节）</p></li>
</ul>
<p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p>
<p><strong>POST方式的请求协议：</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823201303601.png" /></p>
<ul>
<li>请求行(以上图中红色部分)：包含请求方式、资源路径、协议/版本
<ul>
<li>请求方式：POST</li>
<li>资源路径：/brand</li>
<li>协议/版本：HTTP/1.1</li>
</ul></li>
<li>请求头(以上图中黄色部分)<br />
</li>
<li>请求体(以上图中绿色部分) ：存储<strong>请求参数</strong>
<ul>
<li>请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束）</li>
</ul></li>
</ul>
<p>GET请求和POST请求的区别：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 65%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>区别方式</th>
<th>GET请求</th>
<th>POST请求</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>请求参数</td>
<td>请求参数在请求行中。<br/>例：/brand/findAll?name=OPPO&amp;status=1</td>
<td>请求参数在请求体中</td>
</tr>
<tr class="even">
<td>请求参数长度</td>
<td>请求参数长度有限制(浏览器不同限制也不同)</td>
<td>请求参数长度没有限制</td>
</tr>
<tr class="odd">
<td>安全性</td>
<td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td>
<td>安全性相对高</td>
</tr>
</tbody>
</table>
<h3 id="响应协议">响应协议</h3>
<p>与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong>
、<strong>响应体</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220823202344149.png" /></p>
<ul>
<li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p>
<ul>
<li>协议/版本：HTTP/1.1</li>
<li>响应状态码：200</li>
<li>状态码描述：OK</li>
</ul></li>
<li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p>
<ul>
<li>http是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li>
</ul>
<p>常见的HTTP响应头有:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span><br><span class="line"></span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line"></span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip ；</span><br><span class="line"></span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ;</span><br><span class="line"></span><br><span class="line">Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span><br></pre></td></tr></table></figure></li>
<li><p>响应体(以上图中绿色部分)：
响应数据的最后一部分。存储响应的数据</p>
<ul>
<li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li>
</ul></li>
</ul>
<p><strong>响应状态码：</strong></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>状态码分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1xx</td>
<td><strong>响应中</strong> ---
临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td>
</tr>
<tr class="even">
<td>2xx</td>
<td><strong>成功</strong> --- 表示请求已经被成功接收，处理已完成</td>
</tr>
<tr class="odd">
<td>3xx</td>
<td><strong>重定向</strong> ---
重定向到其它地方，让客户端再发起一个请求以完成整个处理</td>
</tr>
<tr class="even">
<td>4xx</td>
<td><strong>客户端错误</strong> ---
处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr class="odd">
<td>5xx</td>
<td><strong>服务器端错误</strong> ---
处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td>
</tr>
</tbody>
</table>
<p>关于响应状态码，主要认识如下三个状态码：</p>
<ul>
<li>200 ok 客户端请求成功</li>
<li>404 Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务端发生不可预期的错误</li>
</ul>
<p>简单解析HTTP协议：首先服务器端启动ServerSocket程序 -&gt;
浏览器输入：<code>http://localhost:8080</code>
就会访问到ServerSocket程序</p>
<ul>
<li>ServerSocket程序，会读取服务器上<code>html/a.html</code>文件，并把文件数据发送给浏览器</li>
<li>浏览器接收到a.html文件中的数据后进行解析，显示以下内容</li>
</ul>
<p>在开发中真正用到的Web服务器都是使用目前比较流行的web服务器。如：<strong>Tomcat</strong></p>
<h2 id="web服务器">3.Web服务器</h2>
<h3 id="概述-2">概述</h3>
<p>服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。</p>
<p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p>
<p>服务器软件：基于ServerSocket编写的程序</p>
<ul>
<li>服务器软件本质是一个运行在服务器设备上的应用程序</li>
<li>能够接收客户端请求，并根据请求给客户端响应数据</li>
</ul>
<p>如：MySQL服务器上会存在MySQL软件，作用提供数据库操作服务；Nginx服务器上存在Nginx软件，作用发布静态Web资源（html，css,js）;Tomcat服务器上存在Tomcat软件，作用发布Web资源（静态+动态）；</p>
<p>Web服务器是一个应用程序(软件)，对<strong>HTTP协议的操作</strong>进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是"提供网上信息浏览服务"。</p>
<p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的<strong>Web项目部署到Tomcat服务器软件</strong>中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p>
<p><strong>Web服务器软件使用步骤</strong></p>
<ul>
<li>准备静态资源</li>
<li>下载安装Web服务器软件</li>
<li>将静态资源部署到Web服务器上（将静态资源resources文件夹复制到tomcat文件夹下的webapps中）</li>
<li>启动Web服务器使用浏览器访问对应的资源（tomcat的bin目录下双击startup.bat脚本即可启动）</li>
</ul>
<p>此时：浏览器输入：<code>http://localhost:8080/demo/index.html</code>便会出现资源内容</p>
<p>Tomcat运行前需要配置好环境变量中的JAVA_HOME路径，要想修改Tomcat启动的端口号，需要修改
conf/server.xml文件</p>
<h2 id="springboot请求响应">4.SpringBoot请求响应</h2>
<p>在实际开发web程序时，不会像刚才一样，直接请求我们的后端web服务器(也就是内置的Tomcat)，而是：</p>
<p>请求会被部署在Tomcat中的<strong>Controller</strong>接收，然后Controller再给浏览器一个响应，响应一个字符串
“Hello World”。
而在请求响应的过程中是遵循HTTP协议的。在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别
<strong>Servlet程序</strong>的。 那我们所编写的XxxController
是如何处理请求的，又与Servlet之间有什么联系呢？</p>
<p>在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序
<strong>DispatcherServlet</strong>，称之为 <strong>核心控制器</strong>。
DispatcherServlet
负责接收页面发送的请求，然后根据执行的规则，将请求再<strong>转发</strong>给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由<strong>DispatcherServlet</strong>给浏览器响应数据。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220826165340157.png"
alt="image-20220826165340157" />
<figcaption aria-hidden="true">image-20220826165340157</figcaption>
</figure>
<p>那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后将解析后的请求数据会传递给Servlet程序的<strong>HttpServletRequest对象</strong>，那也就意味着
HttpServletRequest 对象就可以获取到请求数据。
而Tomcat，还给Servlet程序传递了一个参数
HttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。</p>
<p>那上述所描述的这种浏览器/服务器的架构模式呢，我们称之为<strong>：BS架构。</strong></p>
<p>BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。浏览器和服务器之间请求与响应，在服务器对请求进行分层解耦。</p>
<h3 id="请求">请求</h3>
<p>当前最为主流的开发模式：前后端分离</p>
<p>在这种模式下，前端技术人员基于<strong>"接口文档"</strong>，开发前端程序；后端技术人员也基于"接口文档"，开发后端程序。</p>
<p>由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？</p>
<p>方式：使用专业的接口测试工具（如Postman工具），<em>其他方式参考外卖项目开发中的两种方式</em></p>
<p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求，还可以在发起请求时，携带一些请求参数、请求头等信息，常用于进行<strong>接口测试</strong></p>
<h4 id="简单参数">简单参数</h4>
<p>简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。</p>
<p><strong>后端程序接收简单参数的方式：</strong></p>
<p><strong>原始接收（仅了解）：</strong></p>
<p>在原始的Web程序当中，需要通过Servlet中提供的API：HttpServletRequest（请求对象），获取请求的相关信息。比如获取请求参数：</p>
<blockquote>
<p>Tomcat接收到http请求时：把请求的相关信息封装到HttpServletRequest对象中</p>
</blockquote>
<p>在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明
HttpServletRequest 对象。然后就可以通过该对象来获取请求信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据指定的参数名获取请求参数的数据值</span></span><br><span class="line">String  request.getParameter(<span class="string">&quot;参数名&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>SpringBoot接收：</strong></p>
<p>在SpringBoot的环境中，对原始的API进行了封装，接收参数的形式更加简单。
如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=10</span></span><br><span class="line">    <span class="comment">// 第1个请求参数： name=Tom   参数名:name，参数值:Tom</span></span><br><span class="line">    <span class="comment">// 第2个请求参数： age=10     参数名:age , 参数值:10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String name , Integer age )</span>&#123;<span class="comment">//形参名和请求参数名保持一致</span></span><br><span class="line">        System.out.println(name+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>postman测试( GET 请求)：</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203122405075.png" /></p>
<p><strong>postman测试( POST请求 )：</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20220826181117898.png" /></p>
<blockquote>
<p>结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证==<strong>请求参数名和Controller</strong>方法中的形参名保持一致==，就可以获取到请求参数中的数据值。</p>
</blockquote>
<p>如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String username , Integer age )</span>&#123;<span class="comment">//请求参数名和形参名不相同</span></span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：运行没有报错。
controller方法中的username值为：null，age值为20</p>
<ul>
<li>结论：对于简单参数来讲，<strong>请求参数名和controller方法中的形参名不一致时，无法接收到请求数据</strong></li>
</ul>
<p>那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？</p>
<p>解决方案：可以使用Spring提供的==<span class="citation"
data-cites="RequestParam注解">@RequestParam注解</span>==完成映射</p>
<p>在方法形参前面加上 <span class="citation"
data-cites="RequestParam">@RequestParam</span>
然后通过value属性执行请求参数名，从而完成映射。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意事项：</strong></p>
<p><span class="citation"
data-cites="RequestParam中的required属性默认为true">@RequestParam中的required属性默认为true</span>（默认值也是true），代表该请求参数<strong>必须传递</strong>，如果不传递将报错</p>
</blockquote>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203130726310.png" /></p>
<blockquote>
<p>如果该参数是可选的，可以将required属性设置为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;, required = false)</span> String username, Integer age)</span>&#123;</span><br><span class="line">System.out.println(username+ <span class="string">&quot;:&quot;</span> + age);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。</p>
<p>此时，我们可以考虑将请求参数封装到一个实体类对象中。
要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong></p>
<h4 id="实体参数">实体参数</h4>
<p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。</p>
<p>此时，我们可以考虑将请求参数封装到一个<strong>实体类对</strong>象中。
要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong></p>
<p>定义POJO实体类：<strong>POJO :(Plain Old Java
Objects)，简单的Java对象</strong>，其中有一些属性及其getter、setter方法的类,有时可以作为value
object或dto(Data Transform
Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//实体参数：简单实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simplePojo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplePojo</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//user实体类中的属性必须与请求参数一致，为age和name</span></span><br></pre></td></tr></table></figure>
<p>Postman测试：</p>
<ul>
<li>参数名和实体类属性名一致时，均为name：一切正常</li>
<li>不一致时，请求变成了username：则 User{name='null', age = 10}</li>
</ul>
<p>上面我们讲的呢是简单的实体对象，下面我们在来学习下复<strong>杂的实体对象</strong>。</p>
<p>复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的。如下：</p>
<ul>
<li><p>User类中有一个Address类型的属性（Address是一个实体类），即实体类中包含实体类</p></li>
<li><p>复杂实体对象的封装，需要遵守如下规则：</p>
<ul>
<li><strong>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数</strong></li>
</ul></li>
</ul>
<p>定义POJO实体类：</p>
<ul>
<li>Address实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProvince</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProvince</span><span class="params">(String province)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCity</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;province=&#x27;&quot;</span> + province + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, city=&#x27;&quot;</span> + city + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>User实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">//地址对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&quot;</span> + address +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//实体参数：复杂实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/complexPojo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">complexPojo</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postman测试：新加的内容为address.province和address.city</p>
<h4 id="数组集合参数">数组集合参数</h4>
<p>数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。其实多个值也是一个一个的提交。后端程序接收上述多个值的方式有两种：<strong>数组和集合</strong></p>
<p>数组参数：<strong>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203190218468.png" /></p>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//数组集合参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] hobby)</span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(hobby));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postman测试</p>
<p>在前端请求时，有两种传递形式：</p>
<p>方式一： xxxxxxxxxx?hobby=game&amp;hobby=java
方式二：xxxxxxxxxxxxx?hobby=game,java</p>
<p><strong>集合参数</strong>：请求参数名与形参集合对象名相同且请求参数为多个，<span
class="citation" data-cites="RequestParam">@RequestParam</span>
绑定参数关系</p>
<blockquote>
<p>默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系</p>
</blockquote>
<blockquote>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203211640646.png"
alt="image-20221203211640646" />
<figcaption aria-hidden="true">image-20221203211640646</figcaption>
</figure>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//数组集合参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hobby)</span>&#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Postman测试：</p>
<p>方式一： xxxxxxxxxx?hobby=game&amp;hobby=java  
方式二：xxxxxxxxxxxxx?hobby=game,java</p>
<h4 id="日期参数">日期参数</h4>
<p>上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求：</p>
<p>要选择一个活动/项目的起始时间和结束时间时</p>
<p>因为日期的格式多种多样（如：2022-12-12 10:05:45 、2022/12/12
10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过==<strong><span
class="citation"
data-cites="DateTimeFormat">@DateTimeFormat</span></strong>==注解，以及其pattern属性来设置日期的格式。</p>
<ul>
<li><span class="citation"
data-cites="DateTimeFormat注解的pattern属性中指定了哪种日期格式">@DateTimeFormat注解的pattern属性中指定了哪种日期格式</span>，前端的日期参数就必须按照指定的格式传递。</li>
<li>后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。</li>
</ul>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//日期时间参数</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span>&#123;</span><br><span class="line">        System.out.println(updateTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postman测试：</p>
<p>xxxxxxxxxx?updatetime=2024-4-25 10:05:45</p>
<h4 id="json参数">JSON参数</h4>
<p>JSON: JavaScript Object Notation(JavaScript 对象表示法)</p>
<p>JSON 是存储和交换文本信息的语法，类似XML；JSON 比XML
更小、更快，更易解析；JSON 易于人阅读和编写</p>
<p>如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。
（JSON是开发中最常用的前后端数据交互方式）</p>
<p>我们学习JSON格式参数，主要从以下两个方面着手：</p>
<ol type="1">
<li>Postman在发送请求时，如何传递json格式的请求参数</li>
<li>在服务端的controller方法中，如何接收json格式的请求参数</li>
</ol>
<p>Postman发送JSON格式数据：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203225623337.png" /></p>
<p>服务端Controller方法接收JSON格式数据：</p>
<ul>
<li>传递json格式的参数，在Controller中会使用实体类进行封装。</li>
<li>封装规则：<strong>JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用
==<span class="citation"
data-cites="RequestBody">@RequestBody</span>==标识。</strong></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221203230457901.png" /></p>
<ul>
<li><span class="citation"
data-cites="RequestBody注解">@RequestBody注解</span>：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致）</li>
</ul>
<p>实体类：Address</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//省略GET , SET 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实体类：User</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略GET , SET 方法</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//JSON参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/jsonParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">jsonParam</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postman测试：</p>
<p>xxxx/jsonParam：发送JSON数据，在后端成功接收</p>
<h4 id="路径参数">路径参数</h4>
<p>传统的开发中请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key=value的形式传递(GET请求)。</p>
<p>在现在的开发中，经常还会直接在<strong>请求的URL</strong>中传递参数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/1		</span><br><span class="line">http://localhost:880/user/1/0</span><br></pre></td></tr></table></figure>
<p>上述的这种传递请求参数的形式呢，我们称之为：路径参数。</p>
<p>学习主要掌握在后端的controller方法中，如何接收路径参数。</p>
<p>路径参数：</p>
<ul>
<li>前端：通过请求URL直接传递参数</li>
<li>后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204001520756.png" /></p>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postman测试：xxxx/path/1</p>
<p><strong>传递多个路径参数：</strong></p>
<p>Postman：xxxx/path/1/SJN</p>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, <span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(id+ <span class="string">&quot; : &quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应">响应</h3>
<p>Controller 是 Spring
中最基本的组件，主要处理用户交互，一般每个业务逻辑都会有一个
Controller，供用户请求接口进行数据访问。</p>
<p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet
分发的请求，它把用户请求的数据经过业务层处理之后封装成一个Model
，然后再把该Model 返回给对应的View 进行展示。</p>
<p>Spring MVC 只需使用@Controller
标记一个类即可，然后使用@RequestMapping 和@RequestParam
等一些注解以定义URL 请求和Controller 方法之间的映射，这样Controller
就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest
和HttpServletResponse 等HttpServlet 对象。</p>
<p>(SpringMVC：Spring MVC是一个基于Java的Web应用程序开发框架，它是Spring
Framework的一部分。MVC代表模型-视图-控制器（Model-View-Controller）)</p>
<p><code>@RequestMapping</code> 注解，为我们的应用提供了 “routing”
信息。在这里的 routing 可以理解为路径，在我们访问 Web
资源的时候都会要求提供一个路径的信息。 具体有关这个注解的解释为任何 HTTP
的请求，如果使用了 <code>/</code> 路径的话，所有的请求将会映像到
<code>home</code> 方法，或者可以理解为 <code>home</code> 方法
将会被执行。</p>
<p><code>@RestController</code> 注解将会告诉 Spring 将返回的结果使用
String 字符串来进行渲染，然后将渲染的结果返回给调用者。</p>
<p>Controller程序呢，除了接收请求外，还可以进行响应，前面代码中的return的结果内容即是响应的结果，如何响应给浏览器呢？</p>
<p>答案：使用==<span class="citation"
data-cites="ResponseBody">@ResponseBody</span>==注解</p>
<p><strong><span class="citation"
data-cites="ResponseBody注解">@ResponseBody注解</span>：</strong></p>
<ul>
<li>类型：方法注解、类注解</li>
<li>位置：书写在Controller方法上或类上</li>
<li>作用：将方法返回值直接响应给浏览器
<ul>
<li>如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器</li>
</ul></li>
</ul>
<p>但是在我们所书写的Controller中，只在类上添加了<strong><span
class="citation"
data-cites="RestController">@RestController</span></strong>注解、方法添加了<strong><span
class="citation"
data-cites="RequestMapping">@RequestMapping</span></strong>注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？</p>
<p>原因：在类上添加的@RestController注解，是一个组合注解。</p>
<ul>
<li><strong><span class="citation"
data-cites="RestController">@RestController</span> = <span
class="citation" data-cites="Controller">@Controller</span> + <span
class="citation"
data-cites="ResponseBody">@ResponseBody</span></strong></li>
</ul>
<p><span class="citation"
data-cites="RestController源码中含有注解">@RestController源码中含有注解</span><span
class="citation" data-cites="ResponseBody">@ResponseBody</span></p>
<p>类上有@RestController注解或<span class="citation"
data-cites="ResponseBody注解时">@ResponseBody注解时</span>：表示当前类下所有的<strong>方法返回值</strong>做为<strong>响应数据</strong>，返回值如果是一个POJO对象或集合时，会先转换为<strong>JSON格式</strong>，再响应给浏览器</p>
<h4 id="统一响应结果">统一响应结果</h4>
<p>我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204174537686.png" /></p>
<p>前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。</p>
<p>统一的返回结果使用类来描述，在这个结果中包含：</p>
<ul>
<li>响应状态码：当前请求是1成功，还是0失败</li>
<li>状态码信息：给页面的提示信息</li>
<li>返回的数据：给前端响应的数据（字符串、对象、集合）</li>
</ul>
<p>定义在一个实体类Result来包含以上信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//响应码，1 代表成功; 0 代表失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">//响应码 描述字符串</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改 成功响应(不需要给前端返回数据)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询 成功响应(把查询结果做为返回数据响应给前端)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123; </span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="comment">//return new Result(1,&quot;success&quot;,&quot;Hello World ~&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原本是return的字符串，现在return 统一响应数据 Result.success了</p>
<p>Springboot项目的静态资源(html，css，js等前端资源)默认存放目录为：classpath:/static
、 classpath:/public、 classpath:/resources</p>
<blockquote>
<p>在SpringBoot项目中，静态资源默认可以存放的目录：</p>
<ul>
<li>classpath:/static/</li>
<li>classpath:/public/</li>
<li>classpath:/resources/</li>
<li>classpath:/META-INF/resources/</li>
</ul>
<p>classpath：</p>
<ul>
<li>代表的是类路径，在maven的项目中，其实指的就是 src/main/resources
或者
src/main/java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在
src/main/resources下。</li>
</ul>
</blockquote>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204191650390.png" /></p>
<p>当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。</p>
<ul>
<li>当我们要修改<strong>操作数据</strong>部分的代码，需要改动Controller</li>
<li>当我们要完善<strong>逻辑处理</strong>部分的代码，需要改动Controller</li>
<li>当我们需要修改<strong>数据响应</strong>的代码，还是需要改动Controller</li>
</ul>
<p>===&gt; 整个工程代码的复用性比较差，而且代码难以维护</p>
<p>解决办法：分层开发</p>
<h2 id="分层解耦">5.分层解耦</h2>
<h3 id="概述-3">概述</h3>
<p>在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p>
<blockquote>
<p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p>
<p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p>
</blockquote>
<p>代码基本处理逻辑，从组成上看可以分为三个部分：</p>
<ul>
<li>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。</li>
<li>逻辑处理：负责业务逻辑处理的代码。</li>
<li>请求处理、响应数据：负责，接收页面的请求，给页面响应数据。</li>
</ul>
<p>按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：</p>
<ul>
<li><strong>Controller：</strong>控制层。接收前端发送的请求，对请求进行处理，并响应数据。=》解决请求响应</li>
<li><strong>Service：</strong>业务逻辑层。处理具体的业务逻辑。=》解决核心业务逻辑</li>
<li><strong>Dao：</strong>数据访问层(Data Access
Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。=》解决数据访问问题</li>
</ul>
<p>基于三层架构的程序执行流程：</p>
<ol type="1">
<li><p>前端发起的请求，由Controller层接收（Controller响应数据给前端）</p></li>
<li><p>Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）</p></li>
<li><p>Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）</p></li>
<li><p>Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）</p></li>
</ol>
<p>对任一层进行变更维护，都不会影响到其他层的处理</p>
<p>为了实现三层架构的思想，可以在工程代码中建立以下三个包：</p>
<ul>
<li>控制层包名：com.ning.controller<br />
</li>
<li>业务逻辑层包名：xxxx.service</li>
<li>数据访问层包名：xxxx.dao</li>
</ul>
<p><strong>分别实现：</strong></p>
<p><strong>控制层：</strong>接收前端发送的请求，对请求进行处理，并响应数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line">    <span class="comment">//业务层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EmpService</span> <span class="variable">empService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpServiceA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>业务逻辑层：</strong>处理具体的业务逻辑</p>
<ul>
<li>业务接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑接口（制定业务标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="comment">//获取员工列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>业务实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑实现类（按照业务标准实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="comment">//调用数据访问层dao层的：new dao层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EmpDao</span> <span class="variable">empDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpDaoA</span>();</span><br><span class="line">    <span class="comment">//重写接口方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据访问实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204201342490.png" /></p>
<p>三层架构的好处：</p>
<ol type="1">
<li>复用性强</li>
<li>便于维护</li>
<li>利用扩展</li>
</ol>
<h3 id="解耦">解耦</h3>
<p>解耦：解除耦合，什么是耦合呢？</p>
<p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p>
<ul>
<li><p>内聚：软件中各个功能模块内部的功能联系。</p></li>
<li><p>耦合：衡量软件中各个层/模块之间的依赖、关联的程度。</p></li>
</ul>
<p><strong>软件设计原则：高内聚低耦合。</strong></p>
<blockquote>
<p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即
"高内聚"。</p>
<p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p>
</blockquote>
<p>程序中高内聚的体现：</p>
<ul>
<li>EmpServiceA类中只编写了和员工相关的逻辑处理代码</li>
</ul>
<p>程序中<em>耦合代码</em>的体现：</p>
<ul>
<li>把业务类变为EmpServiceB时，需要修改controller层中的代码，即变成new
EmpServiceB</li>
</ul>
<p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p>
<p>之前我们在编写代码时，需要什么对象，就直接new一个就可以了。
这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后，
我们还需要修改controller层的代码。</p>
<p><strong>解耦思路：不 new 对象</strong></p>
<p>不能new，就意味着没有业务层对象，解决：</p>
<ul>
<li>提供一个<strong>容器</strong>，容器中存储一些对象(例：EmpService对象)</li>
<li>controller程序<strong>从容器中获取</strong>EmpService类型的对象</li>
</ul>
<p>我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：</p>
<ul>
<li><p><strong>控制反转：</strong> Inversion Of
Control，简称IOC。<strong>对象的创建控制权由程序自身转移到外部</strong>（容器），这种思想称为控制反转。</p>
<blockquote>
<p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器</p>
</blockquote></li>
<li><p><strong>依赖注入：</strong> Dependency
Injection，简称DI。<strong>容器为应用程序提供运行时，所依赖的资源</strong>，称之为依赖注入。</p>
<blockquote>
<p>程序运行时需要某个资源，此时容器就为其提供这个资源。</p>
<p>例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象</p>
</blockquote></li>
</ul>
<p>IOC容器中创建、管理的对象，称之为：bean对象</p>
<h3 id="ioc-di">IOC &amp; DI</h3>
<p>任务：完成Controller层、Service层、Dao层的代码解耦</p>
<ul>
<li>思路：
<ol type="1">
<li>删除Controller层、Service层中new对象的代码（不new了）</li>
<li>Service层及Dao层的实现类，交给IOC容器管理
（使用Spring提供的注解：==<span class="citation"
data-cites="Component">@Component</span>==，就可以实现类交给IOC容器管理）</li>
<li>为Controller及Service注入运行时依赖的对象（使用Spring提供的注解：==<span
class="citation" data-cites="Autowired">@Autowired</span>==
，就可以实现程序运行时IOC容器自动注入需要的依赖对象）
<ul>
<li>Controller程序中注入依赖的Service层对象</li>
<li>Service程序中注入依赖的Dao层对象</li>
</ul></li>
</ol></li>
</ul>
<p>完整的三层代码：</p>
<ul>
<li><strong>Controller层：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="comment">//不new了</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Service层：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//实现2. 将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//实现3.  运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Dao层：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean 实现2.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。</p>
<p>前面我们提到IOC控制反转，就是将<strong>对象的控制权</strong>交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p>
<p>在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：<span
class="citation" data-cites="Component">@Component</span></p>
<p>而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p>
<ul>
<li><span class="citation" data-cites="Controller">@Controller</span>
（标注在控制层类上）（由于代码中有标注@RestController = <span
class="citation" data-cites="Controller">@Controller</span> + <span
class="citation"
data-cites="ResponseBody">@ResponseBody</span>），故不用标注它</li>
<li><span class="citation" data-cites="Service">@Service</span>
（标注在业务层类上）</li>
<li><span class="citation" data-cites="Repository">@Repository</span>
（标注在数据访问层类上）</li>
</ul>
<p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">注解</th>
<th>说明</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="citation"
data-cites="Controller">@Controller</span></td>
<td><span class="citation"
data-cites="Component的衍生注解">@Component的衍生注解</span></td>
<td>标注在控制器类上</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="citation"
data-cites="Service">@Service</span></td>
<td><span class="citation"
data-cites="Component的衍生注解">@Component的衍生注解</span></td>
<td>标注在业务类上</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="citation"
data-cites="Repository">@Repository</span></td>
<td><span class="citation"
data-cites="Component的衍生注解">@Component的衍生注解</span></td>
<td>标注在数据访问类上（由于与mybatis整合，用的少）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="citation"
data-cites="Component">@Component</span></td>
<td>声明bean的基础注解</td>
<td>不属于以上三类时，用此注解</td>
</tr>
</tbody>
</table>
<p>在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。</p>
<p>注意事项:</p>
<ul>
<li>声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为首字母小写后的类名（类名EmpServiceA
-&gt;bean名empServiceA）。</li>
<li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</li>
</ul>
<p>使用四大注解声明的bean，要想生效，还需要被组件扫描注解==<span
class="citation"
data-cites="ComponentScan">@ComponentScan</span>==扫描</p>
<p><span class="citation"
data-cites="ComponentScan注解虽然没有显式配置">@ComponentScan注解虽然没有显式配置</span>，但是实际上已经包含在了引导类声明注解
<span class="citation"
data-cites="SpringBootApplication">@SpringBootApplication</span>
中，==<strong>默认扫描的范围是SpringBoot启动类所在包及其子包</strong>==。</p>
<p>在本项目中在：SpringbootWebReqRespApplication（启动类）</p>
<p>推荐做法（如下图）：</p>
<ul>
<li>将我们定义的controller，service，dao这些包呢，都放在引导类所在包com.ning的子包下，这样我们定义的bean就会被自动的扫描到，即让启动类.java代码和dao包等平级</li>
</ul>
<p>依赖注入DI，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p>
<p>在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：<strong>自动装配</strong>。</p>
<p><span class="citation"
data-cites="Autowired注解">@Autowired注解</span>，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p>
<blockquote>
<p>入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。</p>
</blockquote>
<p>那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204232154445.png" /></p>
<p><strong><em>程序运行会报错</em></strong></p>
<p>如何解决上述问题呢？Spring提供了以下几种解决方案：</p>
<ul>
<li><span class="citation" data-cites="Primary">@Primary</span>
默认的实现</li>
<li><span class="citation" data-cites="Qualifier">@Qualifier</span>
 value指定名称</li>
<li><span class="citation" data-cites="Resource">@Resource</span>
name属性指定要注入的bean的名称</li>
</ul>
<p>使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204232501679.png" /></p>
<p>使用@Qualifier注解：指定当前要注入的bean对象。
在@Qualifier的value属性中，指定注入的bean的名称。</p>
<ul>
<li><span class="citation"
data-cites="Qualifier注解不能单独使用">@Qualifier注解不能单独使用</span>，必须配合@Autowired使用</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204233333606.png" /></p>
<p>使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20221204233637735.png" /></p>
<blockquote>
<p>面试题 ： <span class="citation"
data-cites="Autowird">@Autowird</span> 与 <span class="citation"
data-cites="Resource的区别">@Resource的区别</span></p>
<ul>
<li><span class="citation" data-cites="Autowired">@Autowired</span>
是spring框架提供的注解，而@Resource是JDK提供的注解</li>
<li><span class="citation" data-cites="Autowired">@Autowired</span>
默认是按照类型注入，而@Resource是按照名称注入</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/04/25/Day8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/25/Day8/" class="post-title-link" itemprop="url">Day8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-24 21:40:50 / 修改时间：13:52:47" itemprop="dateCreated datePublished" datetime="2024-04-24T21:40:50Z">2024-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法">算法</h1>
<p>今天正式开始刷回溯专题的内容：</p>
<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a
target="_blank" rel="noopener" href="https://programmercarl.com/二叉树中递归带着回溯.html">二叉树：以为使用了递归，其实还隐藏着回溯
(opens new window)</a>。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong></p>
<h3 id="回溯法的效率">回溯法的效率</h3>
<p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<h3 id="回溯法解决的问题">回溯法解决的问题</h3>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>相信大家看着这些之后会发现，每个问题，都不简单！</strong></p>
<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<p>能够抽象成树的问题，都可以回溯解决，回溯的本质也是穷举</p>
<figure>
<img
src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png"
alt="回溯算法理论基础" />
<figcaption aria-hidden="true">回溯算法理论基础</figcaption>
</figure>
<p>回溯法模版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>回溯法的魅力，用递归控制for循环嵌套的数量！</strong>回溯问题抽象为树形结构，可以直观的看出其搜索的过程：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p></li>
<li><p>在<a
target="_blank" rel="noopener" href="https://programmercarl.com/0077.组合优化.html">回溯算法：组合问题再剪剪枝
(opens new
window)</a>中把回溯法代码做了剪枝优化，在文中依然把问题抽象为一个树形结构，大家可以一目了然剪的究竟是哪里。</p></li>
</ul>
<p><strong>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够
题目要求的k个元素了，就没有必要搜索了</strong>。</p>
<ul>
<li><p>一定注意题目范围！！！在<a
target="_blank" rel="noopener" href="https://programmercarl.com/0216.组合总和III.html">回溯算法：求组合总和！
(opens new
window)</a>中，题目给出了是1-9的数字，而不是n的，理清题目中对应到回溯法的n和k分别是什么含义，什么内容</p></li>
<li><p>在<a
target="_blank" rel="noopener" href="https://programmercarl.com/0017.电话号码的字母组合.html">回溯算法：电话号码的字母组合
(opens new
window)</a>中，开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。</p>
<p>例如这里for循环，可不像是在 <a
target="_blank" rel="noopener" href="https://programmercarl.com/0077.组合.html">回溯算法：求组合问题！
(opens new window)</a>和<a
target="_blank" rel="noopener" href="https://programmercarl.com/0216.组合总和III.html">回溯算法：求组合总和！
(opens new window)</a>中从startIndex开始遍历的。</p>
<p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而之前的问题都是是求同一个集合中的组合！</strong></p>
<p>此题很绕，debug了很久o(╥﹏╥)o（而且最后也没实现出来自己最初的方法，当初的设计就不合理，不好实现，可见初始设计的重要性）</p></li>
</ul>
<h1 id="开发">开发</h1>
<p>今天学了SpringWeb开发的基础内容，大多是一些入门部分，如SpringBoot入门，概述，Postman测试使用，注解是什么，针对不同的数据类的请求响应，重点应该在HTTP协议，面试中经常会问到，需要加精一下，具体内容在JavaWeb开发博客中~</p>
<h1 id="毕设">毕设</h1>
<p>毕设现在已经基本成稿，这几天绘制了一下相关图片，图片用的基本都是矢量图，对应表格也写了一下（<strong>latex</strong>写表真难啊，好在有latextable这种网站，救大命了属于是），就差最后的仿真部分了，准备全部内容完成后就开启仿真部分的工作；</p>
<p>现在的工作是每天都一半时间分给毕设，剩下一半时间是算法和学习开发的时间，毕业设计是作为学生的本分，虽然自己很急，但是先别急，不能本末倒置！以下是图片的部分展示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240424214422453.png" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/04/20/Day7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/20/Day7/" class="post-title-link" itemprop="url">Day7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-19 20:55:49 / 修改时间：13:19:42" itemprop="dateCreated datePublished" datetime="2024-04-19T20:55:49Z">2024-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法">算法</h1>
<p>这几天努了努力，把代码随想录的二叉树专题全刷完了：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240419210357930.png"
alt="image-20240419210357930" />
<figcaption aria-hidden="true">image-20240419210357930</figcaption>
</figure>
<p>简单按照网站中(<a
target="_blank" rel="noopener" href="https://www.programmercarl.com/周总结/20201017二叉树周末总结.html#周一">二叉树系列</a>)总结一下这几天刷的二叉树内容，然后对二叉树专题进行一个大总结。</p>
<ol type="1">
<li><p>合并两个二叉树时，平时我们都习惯了操作一个二叉树，一起操作两个树可能还有点陌生。其实套路是一样，只不过一起操作两个树，递归法还是同样的原理，无非是两个树同时开始比较；</p>
<p><strong>迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</strong></p></li>
<li><p>涉及到二叉搜索树（Binary Search Tree，BST）
，开始要换一个思路了，大多是二叉搜索树的题目，其实都离不开<strong>中序遍历</strong>，因为这样就是有序的，迭代法在处理某些情况也是很简单的，因为之间对比数值即可以控制root的左右变化</p></li>
<li><p>如果在验证BST的时候：首先在此强调一下二叉搜索树的特性：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>涉及到BST的陷阱：<strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>，而是左子树<strong>都</strong>小于中间节点，右子树<strong>都</strong>大于中间节点，因为有可能左子树的右节点比左子树本身的节点大这种情况。</p>
<p>推荐要通过中序遍历（得到有序数组），然后记录前一个数值（pre）和后一个数值比较（cur），得出最值。</p>
<p><strong>在二叉树中通过两个前后指针作比较，会经常用到</strong>。</p></li>
<li><p>在求众数集合的时候有一个技巧，因为题目中众数是可以有多个的，所以一般的方法需要<strong>遍历两遍</strong>才能求出众数的集合。</p>
<p><strong>但可以遍历一遍就可以求众数集合，使用了适时清空结果集的方法</strong>，这个方法还是很巧妙的。</p></li>
<li><p>公共祖先问题：<strong>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者
左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong>此外，实现从底向上遍历判断最好的方式是：<strong>后序遍历</strong></p></li>
</ol>
<h2 id="二叉树专题总结">二叉树专题总结</h2>
<p>到现在已经刷了30+二叉树经典题目，在每一道二叉树的题目中，使用递归三部曲来分析题目，看到二叉树，看到递归，都会想：<strong>返回值、参数是什么？终止条件是什么？单层逻辑是什么？</strong></p>
<ul>
<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>
<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li>
<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>
</ul>
<p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯<strong>求深度</strong>就用前序，<a
target="_blank" rel="noopener" href="https://programmercarl.com/0257.二叉树的所有路径.html">二叉树：找所有路径
(opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/20211030125421.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>随记：刷二叉树专题最后的时候，一直都比较晕晕的，每次遇到递归的时候，都要看着具体例子走一遍才能理解，不能做到深入浅出，宏观上把握，微观上约束，现在有点陷入微观上观察解题，而不注重回归递归的本质，还需要多做题，多总结。</p>
<p>此外，刷题也有一段时间了，今天浅看了一下已经刷了65道题了，数量见长的同时遗忘也随之而来，这就是没有做到及时总结的坏处，总是现看现总结，学过了就过了，没有做到很好地整理、反思、记录、总结，这是非常非常重要的，也是很贴合我自己的学习方法，需要坚持总结，坚持复盘，才能行稳致远。</p>
<h1 id="毕设">毕设</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240419205929107.png"
alt="image-20240419205929107" />
<figcaption aria-hidden="true">image-20240419205929107</figcaption>
</figure>
<p>目前毕设初稿已经基本完成，基本的逻辑框架和核心内容均已写完，预测总页数达到60余页。</p>
<p>尚未完成：</p>
<ul>
<li>绪论中研究工作部分，比较麻烦，一直没来得及整理研究工作的逻辑和发展；</li>
<li>文章中几乎所有的图片，都需要重制，保证清晰度，尽可能使用矢量图；</li>
<li>最后的实验仿真结果，也是最复杂的地方，还没完成实验仿真，也没法进行结果分析</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/Ning565/Ning565.github.io/2024/04/17/Day6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="NING565">
      <meta itemprop="description" content="记录下学习与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJN的个人小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/17/Day6/" class="post-title-link" itemprop="url">Day6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-16 21:45:17 / 修改时间：14:04:32" itemprop="dateCreated datePublished" datetime="2024-04-16T21:45:17Z">2024-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%9B%E5%8E%82%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">进厂学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近几天，每天的基本工作就是写毕设paper，同时做毕设实验，最后就是刷算法题，学习一下JavaWeb和背一下八股。</p>
<p>基本安排和内容都是这样，比较忙和紧张，
没有做到每天都总结，总结一下最近学的内容。</p>
<h1 id="算法">算法</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240416214750331.png"
alt="image-20240416214750331" />
<figcaption aria-hidden="true">image-20240416214750331</figcaption>
</figure>
<p>这是最近一段时间做的算法题，主要都是二叉树的相关内容，总结内容和结构如下：</p>
<p>1.红黑树和二叉平衡搜索树弄分开了，其实红黑树就是一种二叉平衡搜索树，这两个树不是独立的，所以C++中map、multimap、set、multiset的底层实现机制是二叉平衡搜索树，再具体一点是红黑树。</p>
<p>2.二叉树的顺序遍历（前序、中序、后序）分为：递归和迭代遍历，迭代是利用栈这一数据结构模拟递归的思想；层次遍历分为：迭代和递归，迭代是最常见和实用的，利用队列先进先出特点。</p>
<p>3.递归 VS
迭代在实现迭代法的过程中，有同学问了：递归与迭代究竟谁优谁劣呢？从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。递归更容易让程序员理解，但收敛不好，容易栈溢出。这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。</p>
<p><strong>在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。</strong></p>
<p>4.涉及到二叉树的遍历问题（Maybe隐含的，如翻转二叉树，对称二叉树，求深度/高度），一定要弄清用哪种遍历方法，不同问题用的不同顺序是不一样的；<strong>一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代</strong></p>
<p>5.在<a
target="_blank" rel="noopener" href="https://programmercarl.com/0257.二叉树的所有路径.html">二叉树：找我的所有路径？
(opens new
window)</a>中正式涉及到了回溯，回溯和递归都是相伴相生的，涉及到路径的问题（需要二叉树的节点返回出来结果时），就要回溯了！<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong></p>
<p>6.递归函数什么时候需要返回值？什么时候不需要返回值？一般情况下：<strong>如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</strong></p>
<p>这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况是113.路径总和II）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。
（这种情况我们在<a
target="_blank" rel="noopener" href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">236.
二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112.路径总和的情况）</li>
</ul>
<p>7.习惯了利用节点自身属性判断节点特征时，平时习惯了使用通过节点的左右孩子判断本节点的属性，但发现使用这个思路无法判断左叶子。此时需要相连的三层之间构成的约束条件，也就是要通过节点的父节点以及孩子节点来判断本节点的属性。</p>
<p>8.在构造二叉树时，<strong>有三个注意的点：</strong></p>
<ul>
<li>分割时候，坚持区间不变量原则，左闭右开，或者左闭又闭。</li>
<li>分割的时候，注意后序 或者
前序已经有一个节点作为中间节点了，不能继续使用了。</li>
<li>如何使用切割后的后序数组来切合中序数组？利用中序数组大小一定是和后序数组的大小相同这一特点来进行切割。</li>
</ul>
<p>9.注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过<strong>下标索引直接在原数组上</strong>操作，这样可以节约时间和空间上的开销。</p>
<p>10.一般情况来说：如果让<strong>空节点（空指针）进入递归，就不加if</strong>，如果<strong>不让空节点进入递归，就加if限制一下</strong>，
终止条件也会相应的调整。</p>
<h1 id="毕设">毕设</h1>
<p>目前毕业论文有效内容已经写了30余页：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ning565/picblog@main/img/image-20240416220125695.png"
alt="image-20240416220125695" />
<figcaption aria-hidden="true">image-20240416220125695</figcaption>
</figure>
<p>但是最后实验仿真和性能分析的部分害没有做出来，甚至设计都是一个很困难的问题，希望快点搞出来吧</p>
<h1 id="其他">其他</h1>
<p>学习 and
复习了Web前端开发的基础知识，如Web后端开发的基础(HTTP协议、请求响应)，并且也复习了数据库MySQL，以及通过Mybatis框架如何来完成数据库的基本操作。</p>
<p>还没学到案例部分，接下来学习的就是就通过一个案例（智能学习系统），来将前端开发、后端开发、数据库整合起来，涉及到SpringBootWeb的案例、登录认证、AOP等知识。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NING565"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">NING565</p>
  <div class="site-description" itemprop="description">记录下学习与生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NING565</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
        访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">
        访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/sjn/anime.min.js"></script>
  <script src="/sjn/velocity/velocity.min.js"></script>
  <script src="/sjn/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/js/markmap.js"></script></body>
</html>
